<?xml version="1.0"?>
<!DOCTYPE BOOK [
<!ATTLIST sect1 id ID #IMPLIED>
<!ATTLIST sect2 id ID #IMPLIED>
<!ATTLIST sect3 id ID #IMPLIED>
<!ATTLIST guisubmenu id ID #IMPLIED>
<!ATTLIST areaspec id ID #IMPLIED>
<!ATTLIST mousebutton id ID #IMPLIED>
<!ATTLIST guimenuitem id ID #IMPLIED>
<!ATTLIST subjectterm id ID #IMPLIED>
<!ATTLIST mediaobjectco id ID #IMPLIED>
<!ATTLIST constant id ID #IMPLIED>
<!ATTLIST titleabbrev id ID #IMPLIED>
<!ATTLIST tocentry id ID #IMPLIED>
<!ATTLIST refsect2 id ID #IMPLIED>
<!ATTLIST subjectset id ID #IMPLIED>
<!ATTLIST refsect1 id ID #IMPLIED>
<!ATTLIST graphic id ID #IMPLIED>
<!ATTLIST refsect3 id ID #IMPLIED>
<!ATTLIST pagenums id ID #IMPLIED>
<!ATTLIST figure id ID #IMPLIED>
<!ATTLIST sidebarinfo id ID #IMPLIED>
<!ATTLIST highlights id ID #IMPLIED>
<!ATTLIST quote id ID #IMPLIED>
<!ATTLIST videoobject id ID #IMPLIED>
<!ATTLIST term id ID #IMPLIED>
<!ATTLIST informalfigure id ID #IMPLIED>
<!ATTLIST programlistingco id ID #IMPLIED>
<!ATTLIST property id ID #IMPLIED>
<!ATTLIST bibliomset id ID #IMPLIED>
<!ATTLIST publisher id ID #IMPLIED>
<!ATTLIST tocfront id ID #IMPLIED>
<!ATTLIST funcparams id ID #IMPLIED>
<!ATTLIST author id ID #IMPLIED>
<!ATTLIST secondaryie id ID #IMPLIED>
<!ATTLIST street id ID #IMPLIED>
<!ATTLIST accel id ID #IMPLIED>
<!ATTLIST substeps id ID #IMPLIED>
<!ATTLIST seealsoie id ID #IMPLIED>
<!ATTLIST citation id ID #IMPLIED>
<!ATTLIST holder id ID #IMPLIED>
<!ATTLIST othername id ID #IMPLIED>
<!ATTLIST appendixinfo id ID #IMPLIED>
<!ATTLIST pubdate id ID #IMPLIED>
<!ATTLIST bibliographyinfo id ID #IMPLIED>
<!ATTLIST indexentry id ID #IMPLIED>
<!ATTLIST refsect3info id ID #IMPLIED>
<!ATTLIST edition id ID #IMPLIED>
<!ATTLIST articleinfo id ID #IMPLIED>
<!ATTLIST funcsynopsis id ID #IMPLIED>
<!ATTLIST refmiscinfo id ID #IMPLIED>
<!ATTLIST tocpart id ID #IMPLIED>
<!ATTLIST keysym id ID #IMPLIED>
<!ATTLIST printhistory id ID #IMPLIED>
<!ATTLIST token id ID #IMPLIED>
<!ATTLIST methodname id ID #IMPLIED>
<!ATTLIST tbody id ID #IMPLIED>
<!ATTLIST ulink id ID #IMPLIED>
<!ATTLIST fieldsynopsis id ID #IMPLIED>
<!ATTLIST literallayout id ID #IMPLIED>
<!ATTLIST screeninfo id ID #IMPLIED>
<!ATTLIST caption id ID #IMPLIED>
<!ATTLIST graphicco id ID #IMPLIED>
<!ATTLIST entry id ID #IMPLIED>
<!ATTLIST dedication id ID #IMPLIED>
<!ATTLIST section id ID #IMPLIED>
<!ATTLIST menuchoice id ID #IMPLIED>
<!ATTLIST initializer id ID #IMPLIED>
<!ATTLIST errorcode id ID #IMPLIED>
<!ATTLIST keyword id ID #IMPLIED>
<!ATTLIST secondary id ID #IMPLIED>
<!ATTLIST contractnum id ID #IMPLIED>
<!ATTLIST refentry id ID #IMPLIED>
<!ATTLIST screenco id ID #IMPLIED>
<!ATTLIST citerefentry id ID #IMPLIED>
<!ATTLIST note id ID #IMPLIED>
<!ATTLIST emphasis id ID #IMPLIED>
<!ATTLIST refname id ID #IMPLIED>
<!ATTLIST medialabel id ID #IMPLIED>
<!ATTLIST productname id ID #IMPLIED>
<!ATTLIST equation id ID #IMPLIED>
<!ATTLIST sect1info id ID #IMPLIED>
<!ATTLIST authorinitials id ID #IMPLIED>
<!ATTLIST sgmltag id ID #IMPLIED>
<!ATTLIST epigraph id ID #IMPLIED>
<!ATTLIST keywordset id ID #IMPLIED>
<!ATTLIST shortaffil id ID #IMPLIED>
<!ATTLIST country id ID #IMPLIED>
<!ATTLIST index id ID #IMPLIED>
<!ATTLIST guimenu id ID #IMPLIED>
<!ATTLIST indexdiv id ID #IMPLIED>
<!ATTLIST glossaryinfo id ID #IMPLIED>
<!ATTLIST label id ID #IMPLIED>
<!ATTLIST msgaud id ID #IMPLIED>
<!ATTLIST glosssee id ID #IMPLIED>
<!ATTLIST conftitle id ID #IMPLIED>
<!ATTLIST bibliomixed id ID #IMPLIED>
<!ATTLIST orgdiv id ID #IMPLIED>
<!ATTLIST simpara id ID #IMPLIED>
<!ATTLIST co id ID #IMPLIED>
<!ATTLIST attribution id ID #IMPLIED>
<!ATTLIST confdates id ID #IMPLIED>
<!ATTLIST refentryinfo id ID #IMPLIED>
<!ATTLIST biblioset id ID #IMPLIED>
<!ATTLIST guibutton id ID #IMPLIED>
<!ATTLIST type id ID #IMPLIED>
<!ATTLIST superscript id ID #IMPLIED>
<!ATTLIST footnoteref id ID #IMPLIED>
<!ATTLIST modifier id ID #IMPLIED>
<!ATTLIST indexterm id ID #IMPLIED>
<!ATTLIST setinfo id ID #IMPLIED>
<!ATTLIST confnum id ID #IMPLIED>
<!ATTLIST glossdef id ID #IMPLIED>
<!ATTLIST varlistentry id ID #IMPLIED>
<!ATTLIST segmentedlist id ID #IMPLIED>
<!ATTLIST returnvalue id ID #IMPLIED>
<!ATTLIST bridgehead id ID #IMPLIED>
<!ATTLIST computeroutput id ID #IMPLIED>
<!ATTLIST colophon id ID #IMPLIED>
<!ATTLIST phrase id ID #IMPLIED>
<!ATTLIST editor id ID #IMPLIED>
<!ATTLIST literal id ID #IMPLIED>
<!ATTLIST replaceable id ID #IMPLIED>
<!ATTLIST abbrev id ID #IMPLIED>
<!ATTLIST tocback id ID #IMPLIED>
<!ATTLIST itemizedlist id ID #IMPLIED>
<!ATTLIST glossentry id ID #IMPLIED>
<!ATTLIST cmdsynopsis id ID #IMPLIED>
<!ATTLIST othercredit id ID #IMPLIED>
<!ATTLIST state id ID #IMPLIED>
<!ATTLIST primary id ID #IMPLIED>
<!ATTLIST guilabel id ID #IMPLIED>
<!ATTLIST formalpara id ID #IMPLIED>
<!ATTLIST function id ID #IMPLIED>
<!ATTLIST sect2info id ID #IMPLIED>
<!ATTLIST classname id ID #IMPLIED>
<!ATTLIST mediaobject id ID #IMPLIED>
<!ATTLIST question id ID #IMPLIED>
<!ATTLIST funcdef id ID #IMPLIED>
<!ATTLIST keycap id ID #IMPLIED>
<!ATTLIST date id ID #IMPLIED>
<!ATTLIST title id ID #IMPLIED>
<!ATTLIST chapter id ID #IMPLIED>
<!ATTLIST msgmain id ID #IMPLIED>
<!ATTLIST collabname id ID #IMPLIED>
<!ATTLIST setindexinfo id ID #IMPLIED>
<!ATTLIST exceptionname id ID #IMPLIED>
<!ATTLIST msgsub id ID #IMPLIED>
<!ATTLIST entrytbl id ID #IMPLIED>
<!ATTLIST symbol id ID #IMPLIED>
<!ATTLIST olink id ID #IMPLIED>
<!ATTLIST tertiaryie id ID #IMPLIED>
<!ATTLIST funcprototype id ID #IMPLIED>
<!ATTLIST isbn id ID #IMPLIED>
<!ATTLIST copyright id ID #IMPLIED>
<!ATTLIST surname id ID #IMPLIED>
<!ATTLIST bibliography id ID #IMPLIED>
<!ATTLIST seriesvolnums id ID #IMPLIED>
<!ATTLIST indexinfo id ID #IMPLIED>
<!ATTLIST article id ID #IMPLIED>
<!ATTLIST para id ID #IMPLIED>
<!ATTLIST address id ID #IMPLIED>
<!ATTLIST glossdiv id ID #IMPLIED>
<!ATTLIST link id ID #IMPLIED>
<!ATTLIST modespec id ID #IMPLIED>
<!ATTLIST bibliodiv id ID #IMPLIED>
<!ATTLIST chapterinfo id ID #IMPLIED>
<!ATTLIST confgroup id ID #IMPLIED>
<!ATTLIST application id ID #IMPLIED>
<!ATTLIST part id ID #IMPLIED>
<!ATTLIST variablelist id ID #IMPLIED>
<!ATTLIST objectinfo id ID #IMPLIED>
<!ATTLIST optional id ID #IMPLIED>
<!ATTLIST table id ID #IMPLIED>
<!ATTLIST structfield id ID #IMPLIED>
<!ATTLIST sect3info id ID #IMPLIED>
<!ATTLIST lot id ID #IMPLIED>
<!ATTLIST footnote id ID #IMPLIED>
<!ATTLIST msgexplan id ID #IMPLIED>
<!ATTLIST interface id ID #IMPLIED>
<!ATTLIST contrib id ID #IMPLIED>
<!ATTLIST callout id ID #IMPLIED>
<!ATTLIST bookinfo id ID #IMPLIED>
<!ATTLIST beginpage id ID #IMPLIED>
<!ATTLIST lineannotation id ID #IMPLIED>
<!ATTLIST sbr id ID #IMPLIED>
<!ATTLIST refsynopsisdiv id ID #IMPLIED>
<!ATTLIST classsynopsisinfo id ID #IMPLIED>
<!ATTLIST ooexception id ID #IMPLIED>
<!ATTLIST abstract id ID #IMPLIED>
<!ATTLIST varargs id ID #IMPLIED>
<!ATTLIST qandaentry id ID #IMPLIED>
<!ATTLIST acronym id ID #IMPLIED>
<!ATTLIST keycombo id ID #IMPLIED>
<!ATTLIST phone id ID #IMPLIED>
<!ATTLIST step id ID #IMPLIED>
<!ATTLIST subscript id ID #IMPLIED>
<!ATTLIST partinfo id ID #IMPLIED>
<!ATTLIST simplemsgentry id ID #IMPLIED>
<!ATTLIST glosslist id ID #IMPLIED>
<!ATTLIST synopsis id ID #IMPLIED>
<!ATTLIST oointerface id ID #IMPLIED>
<!ATTLIST glossary id ID #IMPLIED>
<!ATTLIST blockquote id ID #IMPLIED>
<!ATTLIST inlinegraphic id ID #IMPLIED>
<!ATTLIST classsynopsis id ID #IMPLIED>
<!ATTLIST email id ID #IMPLIED>
<!ATTLIST group id ID #IMPLIED>
<!ATTLIST calloutlist id ID #IMPLIED>
<!ATTLIST revdescription id ID #IMPLIED>
<!ATTLIST refclass id ID #IMPLIED>
<!ATTLIST warning id ID #IMPLIED>
<!ATTLIST refdescriptor id ID #IMPLIED>
<!ATTLIST textobject id ID #IMPLIED>
<!ATTLIST see id ID #IMPLIED>
<!ATTLIST revhistory id ID #IMPLIED>
<!ATTLIST seg id ID #IMPLIED>
<!ATTLIST refmeta id ID #IMPLIED>
<!ATTLIST areaset id ID #IMPLIED>
<!ATTLIST set id ID #IMPLIED>
<!ATTLIST audiodata id ID #IMPLIED>
<!ATTLIST sect4info id ID #IMPLIED>
<!ATTLIST videodata id ID #IMPLIED>
<!ATTLIST void id ID #IMPLIED>
<!ATTLIST glossseealso id ID #IMPLIED>
<!ATTLIST member id ID #IMPLIED>
<!ATTLIST sidebar id ID #IMPLIED>
<!ATTLIST anchor id ID #IMPLIED>
<!ATTLIST shortcut id ID #IMPLIED>
<!ATTLIST msglevel id ID #IMPLIED>
<!ATTLIST authorgroup id ID #IMPLIED>
<!ATTLIST orderedlist id ID #IMPLIED>
<!ATTLIST prefaceinfo id ID #IMPLIED>
<!ATTLIST errorname id ID #IMPLIED>
<!ATTLIST releaseinfo id ID #IMPLIED>
<!ATTLIST hardware id ID #IMPLIED>
<!ATTLIST qandaset id ID #IMPLIED>
<!ATTLIST contractsponsor id ID #IMPLIED>
<!ATTLIST msgorig id ID #IMPLIED>
<!ATTLIST fax id ID #IMPLIED>
<!ATTLIST artpagenums id ID #IMPLIED>
<!ATTLIST msg id ID #IMPLIED>
<!ATTLIST volumenum id ID #IMPLIED>
<!ATTLIST listitem id ID #IMPLIED>
<!ATTLIST foreignphrase id ID #IMPLIED>
<!ATTLIST markup id ID #IMPLIED>
<!ATTLIST interfacename id ID #IMPLIED>
<!ATTLIST lineage id ID #IMPLIED>
<!ATTLIST corpname id ID #IMPLIED>
<!ATTLIST preface id ID #IMPLIED>
<!ATTLIST area id ID #IMPLIED>
<!ATTLIST honorific id ID #IMPLIED>
<!ATTLIST alt id ID #IMPLIED>
<!ATTLIST partintro id ID #IMPLIED>
<!ATTLIST setindex id ID #IMPLIED>
<!ATTLIST inlineequation id ID #IMPLIED>
<!ATTLIST authorblurb id ID #IMPLIED>
<!ATTLIST collab id ID #IMPLIED>
<!ATTLIST revremark id ID #IMPLIED>
<!ATTLIST refsynopsisdivinfo id ID #IMPLIED>
<!ATTLIST imagedata id ID #IMPLIED>
<!ATTLIST pob id ID #IMPLIED>
<!ATTLIST informalexample id ID #IMPLIED>
<!ATTLIST methodsynopsis id ID #IMPLIED>
<!ATTLIST synopfragmentref id ID #IMPLIED>
<!ATTLIST sect5info id ID #IMPLIED>
<!ATTLIST tertiary id ID #IMPLIED>
<!ATTLIST methodparam id ID #IMPLIED>
<!ATTLIST programlisting id ID #IMPLIED>
<!ATTLIST msginfo id ID #IMPLIED>
<!ATTLIST revnumber id ID #IMPLIED>
<!ATTLIST database id ID #IMPLIED>
<!ATTLIST inlinemediaobject id ID #IMPLIED>
<!ATTLIST option id ID #IMPLIED>
<!ATTLIST confsponsor id ID #IMPLIED>
<!ATTLIST envar id ID #IMPLIED>
<!ATTLIST informalequation id ID #IMPLIED>
<!ATTLIST informaltable id ID #IMPLIED>
<!ATTLIST postcode id ID #IMPLIED>
<!ATTLIST remark id ID #IMPLIED>
<!ATTLIST structname id ID #IMPLIED>
<!ATTLIST audioobject id ID #IMPLIED>
<!ATTLIST toclevel2 id ID #IMPLIED>
<!ATTLIST guiicon id ID #IMPLIED>
<!ATTLIST toclevel1 id ID #IMPLIED>
<!ATTLIST answer id ID #IMPLIED>
<!ATTLIST toclevel3 id ID #IMPLIED>
<!ATTLIST toclevel4 id ID #IMPLIED>
<!ATTLIST toclevel5 id ID #IMPLIED>
<!ATTLIST destructorsynopsis id ID #IMPLIED>
<!ATTLIST issuenum id ID #IMPLIED>
<!ATTLIST refnamediv id ID #IMPLIED>
<!ATTLIST manvolnum id ID #IMPLIED>
<!ATTLIST firstterm id ID #IMPLIED>
<!ATTLIST important id ID #IMPLIED>
<!ATTLIST command id ID #IMPLIED>
<!ATTLIST segtitle id ID #IMPLIED>
<!ATTLIST tgroup id ID #IMPLIED>
<!ATTLIST legalnotice id ID #IMPLIED>
<!ATTLIST firstname id ID #IMPLIED>
<!ATTLIST procedure id ID #IMPLIED>
<!ATTLIST msgtext id ID #IMPLIED>
<!ATTLIST imageobjectco id ID #IMPLIED>
<!ATTLIST tip id ID #IMPLIED>
<!ATTLIST caution id ID #IMPLIED>
<!ATTLIST appendix id ID #IMPLIED>
<!ATTLIST city id ID #IMPLIED>
<!ATTLIST otheraddr id ID #IMPLIED>
<!ATTLIST tocchap id ID #IMPLIED>
<!ATTLIST qandadiv id ID #IMPLIED>
<!ATTLIST orgname id ID #IMPLIED>
<!ATTLIST msgrel id ID #IMPLIED>
<!ATTLIST seeie id ID #IMPLIED>
<!ATTLIST errortype id ID #IMPLIED>
<!ATTLIST invpartnumber id ID #IMPLIED>
<!ATTLIST paramdef id ID #IMPLIED>
<!ATTLIST funcsynopsisinfo id ID #IMPLIED>
<!ATTLIST pubsnumber id ID #IMPLIED>
<!ATTLIST keycode id ID #IMPLIED>
<!ATTLIST varname id ID #IMPLIED>
<!ATTLIST reference id ID #IMPLIED>
<!ATTLIST ooclass id ID #IMPLIED>
<!ATTLIST xref id ID #IMPLIED>
<!ATTLIST row id ID #IMPLIED>
<!ATTLIST arg id ID #IMPLIED>
<!ATTLIST filename id ID #IMPLIED>
<!ATTLIST refsect1info id ID #IMPLIED>
<!ATTLIST wordasword id ID #IMPLIED>
<!ATTLIST tfoot id ID #IMPLIED>
<!ATTLIST constructorsynopsis id ID #IMPLIED>
<!ATTLIST revision id ID #IMPLIED>
<!ATTLIST refentrytitle id ID #IMPLIED>
<!ATTLIST msgset id ID #IMPLIED>
<!ATTLIST simplesect id ID #IMPLIED>
<!ATTLIST msgentry id ID #IMPLIED>
<!ATTLIST trademark id ID #IMPLIED>
<!ATTLIST jobtitle id ID #IMPLIED>
<!ATTLIST bibliomisc id ID #IMPLIED>
<!ATTLIST action id ID #IMPLIED>
<!ATTLIST biblioentry id ID #IMPLIED>
<!ATTLIST citetitle id ID #IMPLIED>
<!ATTLIST book id ID #IMPLIED>
<!ATTLIST ackno id ID #IMPLIED>
<!ATTLIST publishername id ID #IMPLIED>
<!ATTLIST imageobject id ID #IMPLIED>
<!ATTLIST referenceinfo id ID #IMPLIED>
<!ATTLIST parameter id ID #IMPLIED>
<!ATTLIST corpauthor id ID #IMPLIED>
<!ATTLIST seealso id ID #IMPLIED>
<!ATTLIST example id ID #IMPLIED>
<!ATTLIST itermset id ID #IMPLIED>
<!ATTLIST systemitem id ID #IMPLIED>
<!ATTLIST issn id ID #IMPLIED>
<!ATTLIST screen id ID #IMPLIED>
<!ATTLIST lotentry id ID #IMPLIED>
<!ATTLIST prompt id ID #IMPLIED>
<!ATTLIST toc id ID #IMPLIED>
<!ATTLIST affiliation id ID #IMPLIED>
<!ATTLIST thead id ID #IMPLIED>
<!ATTLIST productnumber id ID #IMPLIED>
<!ATTLIST seglistitem id ID #IMPLIED>
<!ATTLIST refpurpose id ID #IMPLIED>
<!ATTLIST userinput id ID #IMPLIED>
<!ATTLIST subject id ID #IMPLIED>
<!ATTLIST glossterm id ID #IMPLIED>
<!ATTLIST sectioninfo id ID #IMPLIED>
<!ATTLIST simplelist id ID #IMPLIED>
<!ATTLIST refsect2info id ID #IMPLIED>
<!ATTLIST subtitle id ID #IMPLIED>
<!ATTLIST synopfragment id ID #IMPLIED>
<!ATTLIST year id ID #IMPLIED>
<!ATTLIST primaryie id ID #IMPLIED>
<!ATTLIST sect5 id ID #IMPLIED>
<!ATTLIST screenshot id ID #IMPLIED>
<!ATTLIST sect4 id ID #IMPLIED>
]>
<book
><bookinfo
><title
>Using Perl and C</title><authorgroup
><author
><firstname
>Tim</firstname><surname
>Jenness</surname></author><author
><firstname
>Simon</firstname><surname
>Cozens</surname></author></authorgroup><edition
>Draft</edition><copyright
><year
>2000</year><year
>2001</year><holder
>Timothy Jenness, Simon Cozens</holder></copyright></bookinfo><toc
><tocpart
><tocentry
>You won't see this; this is just to make sure it
      autogenerates the TOC.</tocentry></tocpart></toc><chapter
id="intro"
><title
>Introduction</title><para
>TBD</para><sect1
><title
>Why interface to other languages?</title><para
>The flexibility of the Perl language means that it is
    possible to solve many programming problems without ever needing
    to use any other language. There are many modules on CPAN that are
    extremely useful and are written completely in Perl.</para><para
> In fact, writing a module in Perl has a number of
    advantages over using other languages:</para><itemizedlist
><listitem
><para
> It is far easier to write portable cross-platform code
	in perl than it is to use C. One of the successes of perl has
	been its support of many varied operating systems. It is
	unlikely that a module written in C could be as portable as a
	perl version without expending much more effort.</para></listitem><listitem
><para
>Some problems do not need the speed gain or added
	complexity that will come from using a compiled
	language. There are many programmers that are proficient in
	Perl (and/or Java) for whom writing a perl module would be
	much more efficient (in terms of programming effort) than
	writing the equivalent in C.</para></listitem></itemizedlist><para
>People program in perl for a reason and this should not be
    forgotten when it comes to deciding on reasons for not using perl.
    These issues were addressed in the development of the standard
    <classname
>File::Temp</classname> module (part of Perl
    5.6.1). This module provides a standard interface for creating
    temporary files from Perl. The original intention was that this
    module would be written in C but it quickly became apparent that a
    perl implementation would be easier because of portability
    problems (since it was to be a standard module it would have to
    work on all platforms supported by Perl) and speed would not be a
    real issue unless thousands of temporary files were
    required.</para><para
>Having addressed why not to use another language there are,
    of course, two important reasons why another language is
    required:</para><variablelist
><varlistentry
><term
>Speed</term><listitem
><para
>In some cases Perl is simply too slow for a particular
	  program. In this case the choice is either to change the
	  algorithm or to use a faster programming language. The Perl
	  Data Language was created specifically to address the case
	  of processing N-dimensional arrays but there are still times
	  when another language is required.</para></listitem></varlistentry><varlistentry
><term
>Functionality</term><listitem
><para
>There are many useful libraries available that have
	  been written in other languages (especially C, and for
	  numerical applications, Fortran). If new functionality is
	  required that is present in an external library then it is
	  usually far better to provide a perl interface to the
	  library than to recode the library in perl.</para></listitem></varlistentry></variablelist></sect1><sect1
><title
>Why embed Perl in other applications?</title><para
>TBD</para></sect1><sect1
><title
>The Perl internals</title><para
>TBD</para></sect1></chapter><chapter
id="cintro"
><title
>C for Perl Programmers</title><para
>When using C and Perl together, the first thing we need to realise is
that they are very different languages, requiring different styles and
different thought patterns. Perl spoils programmers by doing an awful
amount of the hard work for them; if you've never programmed in C
before, the language can feel very barren and empty. C is close to the
machine - Perl is close to the user.</para><para
>That being said, Perl's syntax borrows heavily from C's, and so most
of the elements of a C program should be familiar to a competent Perl
programmer with a little thought and a little preparation.</para><sect1
><title
>Hello, World</title><para
>The classic book on C programming is Kernighan and Ritchie's
<citetitle
>The C Programming Language</citetitle>, which begins with a
program a little like this:</para><example
id="cintro.hw"
><title
>``Hello world'', from C</title><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;

    int main(int argc, char **argv)
    {
      printf("hello, world\n");
      return(0);
    }</programlisting></example><para
>The classic book on Perl, on the other hand, is <citetitle
>Programming
Perl</citetitle>, by Larry Wall, Tom Christiansen and Randal Schwartz.
This begins with a fairly similar program:</para><example
><title
>``Hello world'', from Perl</title><programlisting
format="linespecific"
>    print "Howdy, world!\n";</programlisting></example><para
>First, notice that Perl is a lot more compact: there's no waffle, no
housekeeping. We want to print something, we tell Perl to print it.
C, on the other hand, requires a little more support from the
programmer.</para><para
>Let's first look at how we compile and run the C program, before
looking at how it's constructed.</para></sect1><sect1
><title
>The C compiler</title><para
>There's only one Perl, but there are a large variety of different C
compilers and implementations; these can have a graphical front-end,
such as the Microsoft Visual Studio, or a simple command-line
interface, such as the Free Software Foundation's GCC. We'll talk
about GCC here, since it's the most popular free compiler.</para><para
>The simplest way of calling GCC is to simply give it the name of a C
program to compile. GCC is particularly quiet; if all is well, it will
give no output on the screen:</para><screen
format="linespecific"
>   <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc hello.c</userinput>
   <prompt
moreinfo="none"
>%</prompt></screen><para
>This will produce an executable called <filename
moreinfo="none"
>a.out</filename>
<footnote
><para
>For historical reasons - <filename
moreinfo="none"
>a.out</filename> was the name of a
particular type of executable file format.</para></footnote>
in the current directory; if we run that:

    <screen
format="linespecific"
>    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>./a.out</userinput>
    <computeroutput
moreinfo="none"
>hello, world!</computeroutput></screen>
we get our tired and worn greeting.</para><para
>Sometimes we don't want our output called <filename
moreinfo="none"
>a.out</filename>,
so we can tell GCC to give it another name with the
<option
>-o</option> option:</para><screen
format="linespecific"
>    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -o hello hello.c</userinput></screen><para
>Perl encourages programmers to turn on the <option
>-w</option> flag
for warnings; we encourage C programmers to turn on the
<option
>-Wall</option> flag for all warnings<footnote
><para
>Of course,
if you are not using <command
moreinfo="none"
>gcc</command> the particular option will
be different. Ironically, <option
>-Wall</option> does not turn on all
the warnings in <command
moreinfo="none"
>gcc</command>; it only turns on the ones that
are felt to be important by the <command
moreinfo="none"
>gcc</command>
programmers. See the <command
moreinfo="none"
>gcc</command> documentation for the full
list. If you want to make sure your program will be ANSI compliant
rather than slipping in to using <command
moreinfo="none"
>gcc</command> extensions you
may want to consider using the <option
>-ansi -pedantic</option>
option. </para></footnote>:</para><screen
format="linespecific"
>    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -Wall -o hello hello.c</userinput></screen><para
>If you have a collection of C files that make up one program, you
could list them all:</para><screen
format="linespecific"
>    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -Wall -o bigproject one.c two.c three.c four.c</userinput></screen><para
>However, it's more popular to use GCC to convert each one to an
<firstterm
>object file</firstterm> (extension <filename
moreinfo="none"
>.o</filename>
with GCC, equivalent to <filename
moreinfo="none"
>.obj</filename> files on Windows) -
an intermediate stage in compilation - and then link all the object
files together; this allows you to change individual files without
needing to completely recompile everything.  To tell GCC to produce an
object file, use the <option
>-c</option> flag:</para><screen
format="linespecific"
>      <computeroutput
moreinfo="none"
>    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -Wall -o one.o -c one.c</userinput>
    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -Wall -o two.o -c two.c</userinput>
    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -Wall -o three.o -c three.c</userinput>
    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -Wall -o four.o -c four.c</userinput></computeroutput></screen><para
>And then simply list the object files to link them all together:</para><screen
format="linespecific"
>    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -Wall -o bigproject one.o two.o three.o four.o</userinput></screen><para
>There are more complicated ways of building large programs, using
static and dynamic libraries, but we need not go into those for the
examples here.</para></sect1><sect1
><title
>Header Files</title><para
>The first line in the C program is an <function
moreinfo="none"
>include</function>
statement: this is similar to Perl's <function
moreinfo="none"
>require</function> in
that it instructs the language to go and find a library file and read
it in. However, where Perl's <filename
moreinfo="none"
>.pm</filename> and
<filename
moreinfo="none"
>.pl</filename> library files contain real Perl code, C's
<filename
moreinfo="none"
>.h</filename> files (<firstterm
>header</firstterm> files)
contain only the <emphasis
>promise</emphasis> of code - they contain
function prototypes, and just like Perl's subroutine prototypes, these
allow the compiler to check our use of the functions while specifying
that the real code will come later.</para><para
>But what function's prototype do we need, and where will the real code
from? Well, the only function we use is <function
moreinfo="none"
>printf</function>,
in line 5 of our example. Perl has a <function
moreinfo="none"
>printf</function>
function too, and they are almost identical. However, all of Perl's
functions documented in <filename
moreinfo="none"
>perlfunc</filename> are built in to
the language - C, on the other hand, has <emphasis
>no</emphasis>
built-in functions. Everything is provided by a library called the
``standard C library'', which is included when any C program is
compiled. The <function
moreinfo="none"
>printf</function> function comes from a
section of the standard C library called the ``standard IO library'',
and to let the C compiler ensure that we are using it properly, we
have it read the header file which contains the prototypes for the
standard IO library, <filename
moreinfo="none"
>stdio.h</filename>.</para><sidebar
><para
>It's almost like <userinput
moreinfo="none"
>use strict</userinput> is always on - we
can't use any function without telling C where it's coming from (or at
least we shouldn't since if we fail to declare the prototype the
compiler will make some assumptions that are unlikely to be correct).</para></sidebar></sect1><sect1
><title
>The <function
moreinfo="none"
>main</function> function</title><para
>The main reason the Perl version was much smaller is because
everything in C must be inside a function - if you have Perl code
outside of any subroutine, it will all be executed in order. C needs
all of this code in one place, the <function
moreinfo="none"
>main</function> function.</para><sidebar
><para
>What you'd call a ``subroutine'' in Perl gets called a ``function'' in
C.</para></sidebar><para
>When your program begins, C arranges for this function to be called.</para><para
>This function, too, must have a prototype, and here it is
again:</para><funcsynopsis
><funcprototype
><funcdef
>int <function
moreinfo="none"
>main</function></funcdef><paramdef
>int <parameter
moreinfo="none"
>argc</parameter></paramdef><paramdef
>char <parameter
moreinfo="none"
>**argv</parameter></paramdef></funcprototype></funcsynopsis><para
>Perl's prototypes only tell you what type of data is coming into the
function: <userinput
moreinfo="none"
>sub main($@)</userinput> tells us that the
subroutine <function
moreinfo="none"
>main</function> takes a scalar and an array.</para><para
>In C, we're not only told what's coming into the function, we're told
what variables it should be stored in, and also what type of data the
function should return. Here, we're returning an <type
>int</type>eger,
and we're being given an integer called <varname
>argc</varname>, and
also something called <varname
>argv</varname>: we'll look at exactly
what <userinput
moreinfo="none"
>char **</userinput> means later on, but you
might be able to guess that <varname
>argv</varname> is similar to
Perl's <varname
>@ARGV</varname> - an array of the command line
parameters. <varname
>argc</varname> is actually the number of elements
in the array - that is, the number of command-line parameters passed
to the program. (The <emphasis
>arg</emphasis>ument
<emphasis
>c</emphasis>ount.) One difference between Perl and C is that
in C <varname
>argv</varname> contains the name of the command in
element <literal
moreinfo="none"
>0</literal> whereas in Perl <varname
>@ARGV</varname>
does not contain the command name (that can be retrieved using
<varname
>$0</varname>).</para><sidebar
><para
>Some compilers support a third argument to
      <function
moreinfo="none"
>main</function>:</para><funcsynopsis
><funcprototype
><funcdef
>int <function
moreinfo="none"
>main</function></funcdef><paramdef
>int <parameter
moreinfo="none"
>argc</parameter></paramdef><paramdef
>char <parameter
moreinfo="none"
>**argv</parameter></paramdef><paramdef
>char <parameter
moreinfo="none"
>**envp</parameter></paramdef></funcprototype></funcsynopsis><para
>Where <varname
>envp</varname> provides access to the
      process environment. This is not part of POSIX or the ANSI C89
      standard and so is not included here.</para></sidebar><para
>The <function
moreinfo="none"
>main</function> function almost always has the prototype
given above: it should take two parameters which represent the command
line, and return an integer value to the operating system, the
<firstterm
>exit status</firstterm>. Just as in Perl, the program may
end implicitly, when there is no more code to execute, or explicitly,
when the <function
moreinfo="none"
>exit</function> function is called. Our first
example ended by <function
moreinfo="none"
>return</function>ing a value to the
operating system, ending the <function
moreinfo="none"
>main</function> function. We
could also, theoretically, allow execution to ``fall off the end'' of
the <function
moreinfo="none"
>main</function> function:</para><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;

    int main(int argc, char **argv)
    {
      printf("hello, world\n");
      /* No return, just falls off. */
    }</programlisting><para
>Here you see the use of a C comment - comments are made up of matched
pairs of <userinput
moreinfo="none"
>/*</userinput> and
<userinput
moreinfo="none"
>*/</userinput><footnote
><para
>Many modern compilers (and
the C99 standard) also
implement C++ style <literal
moreinfo="none"
>//</literal> comments. These comments act
just like Perl <literal
moreinfo="none"
>#</literal> comments.</para></footnote>. Note that comments
cannot be nested. This is legal:</para><programlisting
format="linespecific"
>     /*
        Comment out some code:
        printf("This won't print\n");

        Now carry on with the program:
     */</programlisting><para
>But this isn't:</para><programlisting
format="linespecific"
>     /*
        Comment out some code:
        printf("This won't print\n"); /* A comment */

        Now carry on with the program:
     */</programlisting><para
>The comment will be ended at the first <userinput
moreinfo="none"
>*/</userinput> -
that is, after <userinput
moreinfo="none"
>A comment</userinput> - and the C compiler
will try and compile <userinput
moreinfo="none"
>Now carry on...</userinput>.</para><para
>Allowing execution to fall off the end of <function
moreinfo="none"
>main</function> is
not recommended; it produces a warning to the effect that C expected
our function to return a value, and it never did. Finally, we can also
call <function
moreinfo="none"
>exit</function> explicitly:</para><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;

    int main(int argc, char **argv)
    {
      printf("hello, world\n");
      exit(0);
    }</programlisting><para
>The compiler makes a special exemption for <function
moreinfo="none"
>exit</function>
as it knows that the function will not return.</para></sect1><sect1
><title
>Variables and Functions</title><para
>As well as having to define our function prototypes, C forces us to
define our variables, just like the <userinput
moreinfo="none"
>use strict</userinput>
mode of Perl. We can define four different types of variables:
function parameters, automatic variables, global variables, and static
variables.</para><sect2
><title
>Function parameters</title><para
>Function parameters are declared in the prototype of a function. Let's
look at a very simple function:</para><example
id="cintro.treble"
><title
>Function parameters</title><programlisting
format="linespecific"
>    int treble(int x)
    {
        x *= 3;
        return x;
    }</programlisting></example><para
>Here we've taken an integer, <varname
>x</varname>, multiplied it by 3,
and returned its new value. Note that we don't need the parentheses
around <function
moreinfo="none"
>return</function> - this is because
<function
moreinfo="none"
>return</function> is not really a function; it's actually a
keyword of the language. Unlike Perl, all functions in C require
parentheses.</para><para
>The Perl equivalent of the above function would look like this:</para><programlisting
format="linespecific"
>    sub treble {
        my $x = shift;
        $x *= 3;
        return $x;
    }</programlisting><para
>And we'd call it like this:</para><programlisting
format="linespecific"
>    print "Three times ten is ", treble(10), "\n";</programlisting><para
>Well, we don't have a direct equivalent to <function
moreinfo="none"
>print</function>
in C, but we can use <function
moreinfo="none"
>printf</function>:</para><example
><title
>Calling a function</title><programlistingco
><areaspec
><area
coords="2"
id="cintro.callfunc.stdlib"
></area><area
coords="10"
id="cintro.callfunc.printf"
></area><area
coords="11"
id="cintro.callfunc.exit"
></area></areaspec><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    int treble(int x) {
        x *= 3;
        return x;
    }

    int main(int argc, char** argv) {
        printf("Three times ten is %d\n", treble(10));
        return(EXIT_SUCCESS);
    }</programlisting><calloutlist
><callout
arearefs="cintro.callfunc.stdlib"
><para
>We include <filename
moreinfo="none"
>stdlib.h</filename> so that
we can use the <varname
>EXIT_SUCCESS</varname> macro.</para></callout><callout
arearefs="cintro.callfunc.printf"
><para
>The <function
moreinfo="none"
>printf</function> function has
	      similar functionality to the Perl version. The
	      <literal
moreinfo="none"
>%d</literal> format is used to format a signed integer
	      in both Perl and C.</para></callout><callout
arearefs="cintro.callfunc.exit"
><para
>Rather than explicitly returning a zero here we
	      use the <varname
>EXIT_SUCCESS</varname> macro provided
	      in ANSI C. This is more explicit than using a naked
	      zero. <varname
>EXIT_FAILURE</varname> can also be used
	      if required.</para></callout></calloutlist></programlistingco></example><para
>As we mentioned above, function prototypes must appear before they are
called, so that the compiler can check the types: hence the definition
of <function
moreinfo="none"
>treble</function> must appear before the
<function
moreinfo="none"
>main</function> function calls it. Otherwise, C assumes that
the return value will be <type
>int</type>, and you will receive a
warning from the compiler if warnings are turned on.</para><para
>Function parameters act just like lexical variables in Perl
(<function
moreinfo="none"
>my</function> variables); they have the same scope as their
enclosing block (which is always the function), and they are private
to that scope.</para></sect2><sect2
><title
>Automatic variables</title><para
>Automatic variables have similar scoping properties to function
parameters, but they can appear in any block. They are directly
equivalent to Perl's lexical variables.</para><para
>You declare an automatic variable by simply listing its type and its
name; however, declaring automatic variables <emphasis
>must</emphasis>
happen before any statements in the block. So, you may say this:</para><example
><title
>Automatic variables</title><programlisting
format="linespecific"
>    int main (int argc, char** argv) {
        int number;
        number = 4;

        printf("Hello world\n");
        return(EXIT_SUCCESS);
    }</programlisting></example><para
>But you may not say this:</para><programlisting
format="linespecific"
>    int main (int argc, char** argv) {
        printf("Hello world\n");

        int number;
        number = 4;

        return(EXIT_SUCCESS);
    }</programlisting><para
>You can also initialize your automatic variables when you declare
them, by saying, for instance <userinput
moreinfo="none"
>int number =
4;</userinput>. You may also start a new block to declare an automatic
variable:</para><programlisting
format="linespecific"
>    int some_function(int parameter) {
        int one = 1;

        {
            int two = 2;
            printf("one = %d, two = %d\n", one, two);
        }

        /* "two" is out of scope here */
        return one;
    }</programlisting><para
>Because of this property, it's likely that most of your temporary
variables - in fact, most of the variables you will use - will tend to
be automatic variables. But why are they called automatic variables?
Since C knows their scope and their type at compile time, it can
automatically make memory allocation for them.</para><para
>Just like in Perl, if we have two lexical variables with the same
name, only the most recently-declared one is in scope, ``hiding'' the
older one:</para><programlisting
format="linespecific"
>    int main(int argc, char** argv) {
        int number = 10;
        {
            int number = 20;
            printf("%d", number); /* Will print "20" */
        }
        return number;
    }</programlisting><para
>However, unlike perl in <classname
>strict</classname>
      mode, many C compilers may not give us a warning in this
      case.</para></sect2><sect2
><title
>Global variables</title><para
>If a variable is declared outside of a function, it's available to all
the functions in that file:</para><example
id="cintro.globvarex"
><title
>Global Variables</title><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    int counter = 0;

    void bump_it() {
        counter++;
    }

    int main(int argc, char** argv) {
        printf("The value of counter is %d\n", counter);
        bump_it();
        bump_it();
        printf("The value of counter is %d\n", counter);
        bump_it();
        printf("The value of counter is %d\n", counter);

        return(EXIT_SUCCESS);
    }</programlisting></example><para
>The function <function
moreinfo="none"
>bump_it</function> modifies the global variable
<varname
>counter</varname>, which <function
moreinfo="none"
>main</function>
reads. <function
moreinfo="none"
>bump_it</function> is declared to return type
<type
>void</type> - this just means ``it will not return anything'';
think of ``void context'' in Perl.</para><para
>It's also possible to share a global variable across multiple files,
by declaring it once in one file, and then prefixing the declaration
in other files with the <userinput
moreinfo="none"
>extern</userinput> keyword. For
instance, if we have a file called <filename
moreinfo="none"
>count1.c</filename>
containing the declaration and <function
moreinfo="none"
>main</function> function from
above:</para><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    int counter = 0;

    void bump_it();

    int main(int argc, char** argv) {
        printf("The value of counter is %d\n", counter);
        bump_it();
        bump_it();
        printf("The value of counter is %d\n", counter);

        return(EXIT_SUCCESS);
    }</programlisting><para
>(We still need to provide the prototype to
<function
moreinfo="none"
>bump_it</function>, just as <filename
moreinfo="none"
>stdio.h</filename>
provides the prototype for <function
moreinfo="none"
>printf</function>.) and also a
file called <filename
moreinfo="none"
>count2.c</filename> containing the
<function
moreinfo="none"
>bump_it</function> function:</para><programlisting
format="linespecific"
>    extern int counter;

    void bump_it() {
        counter++;
    }</programlisting><para
>We can now compile these files into object files and link them
together, like this:</para><programlisting
format="linespecific"
>    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -Wall -o count1.o -c count1.c</userinput>
    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -Wall -o count2.o -c count2.c</userinput>
    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -Wall -o count count1.o count2.o</userinput></programlisting><para
>The function in <filename
moreinfo="none"
>count2.c</filename> knows that it should be
able to access a global variable called <varname
>counter</varname>,
which is declared ``externally'' - somewhere else in the program. C
finds the global declaration of <varname
>counter</varname> in
<filename
moreinfo="none"
>count1.c</filename>, and so the function can access the global
variable.</para></sect2><sect2
><title
>Static Variables</title><para
>The final type of variables on offer are static variables; these
are variables which keep their value between calls to a function. One
way to do something like this in Perl would be:</para><programlisting
format="linespecific"
>    {
        my $x;
        sub foo {
            return ++$x;
        }
    }</programlisting><para
>or even to use a closure. But C does not allow us to declare bare
blocks in the same way as Perl does; the C equivalent would look like
this: </para><example
><title
>Static variables</title><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;

    int foo () {
        static int x = 0;
        return ++x;
    }

    int main(int argc, char** argv) {
        int i;

        for (i=1; i&lt;=10; i++)
            printf("%d\n",foo());

        return 0;
    }</programlisting></example><para
>There are a few things to notice here:
<itemizedlist
><listitem
><para
>To maintain a variable's state between calls,
	    declare the variable <userinput
moreinfo="none"
>static</userinput>.
 </para></listitem><listitem
><para
>There is no range operator, nor a special variable
	    like <varname
>$_</varname>, nor is there a one-argument
	    <function
moreinfo="none"
>foreach</function> loop to loop over an array;
	    we only have the three-argument <function
moreinfo="none"
>for</function>.</para></listitem><listitem
><para
>Calls to functions we declare <emphasis
>must</emphasis> contain
parentheses, even when they take no parameters; otherwise, we end up
taking the address of the function! (It's the difference between
<userinput
moreinfo="none"
>&amp;mysub</userinput> and <userinput
moreinfo="none"
>\&amp;mysub</userinput>.)</para></listitem><listitem
><para
>If the code inside a <function
moreinfo="none"
>for</function> loop is only one
statement, we do not need to enclose it in a block. If it's any more
than one statement, it must be enclosed in curly braces. This also
applies for the other control structures, <function
moreinfo="none"
>if</function> and
<function
moreinfo="none"
>while</function>.</para></listitem></itemizedlist></para><para
>C has no equivalent to Perl's dynamic scoping; (variables with
<function
moreinfo="none"
>local</function>) this is something that the Perl internals
attempt to get around, and we'll see how that's done in later
chapters.</para></sect2></sect1><sect1
><title
>Data Types</title><para
>If <varname
>argc</varname> is an <type
>int</type>eger and
<varname
>argv</varname> is an array of strings, what other data types
do we have? Perl only supports three types of variables (ignoring
globs for now): scalars for single data items, arrays for storing many
scalars and hashes for keyword/scalar pairs. A scalar is simply a
<emphasis
>thing</emphasis> that can be passed around and processed but
the type of the scalar is not important. In C, the compiler needs to
know whether you are using a number or a character and the type of
number you are using (integer, floating point number, double precision
floating point number). C supports quite a variety of data types
which can vary from machine to machine, and the Perl internals define
some special types which give us a machine-independent environment.</para><sect2
><title
>C Types</title><para
>First, let's look at the basic C types:</para><sect3
><title
><type
>int</type></title><para
>The <type
>int</type> type represents positive or negative integer
values. C's data types are defined primarily, however, not by what
they hold but by how many bits are used to represent them, since this
defines their limits.</para><para
>For example, an <type
>int</type> on my machine is represented using 32
bits of memory. One of these is used as a ``sign bit'' to determine
whether or not the value is positive or negative, and the other 31
bits are used to store the number; this means it has a range from
-2147483647 to 2147483647. We can tell C to not use a ``sign bit'' and
have all 32 bits available for storage by declaring an <type
>unsigned
int</type>, giving us a range from 0 to 4294967295.</para><para
>I say ``on my machine'' because the size of these types is not
guaranteed, nor is it defined by the C language; a compiler for a 64-bit
processor may choose to use 64 bits to represent an <type
>int</type>,
although it may not. While the C standard specifies the minimum size, it
doesn't guarantee the actual size. (This is why the Perl internals
define their own types, to guarantee sizes.) There are a number of ways
to determine the limits. The easiest is to set all the bits in an
unsigned variable to 1, and examine the number produced. Just as in Perl
we can set all the bits to 1 using the bitwise NOT operator,
<userinput
moreinfo="none"
>~</userinput>:</para><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    int main (int argc, char** argv) {
        unsigned int i = ~0;

        printf("i is %u\n", i);
        return(EXIT_SUCCESS);
    }</programlisting><para
>(Note that we use <userinput
moreinfo="none"
>%u</userinput> as the
<function
moreinfo="none"
>printf</function> format specifier for an unsigned integer -
this is the same as in Perl.)</para><para
>This tells me that the highest unsigned integer is 4294967295, and so
the highest signed integer must be one less than half of 1+4294967295.</para><para
>The other method is slightly more complex, but more flexible. The
header file <filename
moreinfo="none"
>limits.h</filename> defines some constants (See
<xref
linkend="cintro.macros"
></xref> for how this happens) which tell us the limits
of the various sizes:</para><example
><title
>Finding limits with <filename
moreinfo="none"
>limits.h</filename></title><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;limits.h&gt;

    int main (int argc, char **argv) {
        printf("The maximum signed integer is %d\n", INT_MAX);
        printf("The minimum signed integer is %d\n", INT_MIN);
        printf("The maximum unsigned integer is %u\n", UINT_MAX);
        /* UINT_MIN is not declared because it's obviously 0! */
        return(EXIT_SUCCESS);
    }</programlisting></example><para
>Produces:
<screen
format="linespecific"
><computeroutput
moreinfo="none"
>    The maximum signed integer is 2147483647
    The minimum signed integer is -2147483648
    The maximum unsigned integer is 4294967295
 </computeroutput></screen></para><para
>You should note that the <classname
>POSIX</classname> module in Perl
can also define these constants: (And notice how similar Perl with
<userinput
moreinfo="none"
>use POSIX</userinput> can be to C!)</para><programlisting
format="linespecific"
>    use POSIX;
    printf("The maximum signed integer is %d\n", INT_MAX);
    printf("The minimum signed integer is %d\n", INT_MIN);
    printf("The maximum unsigned integer is %u\n", UINT_MAX);</programlisting></sect3><sect3
><title
><type
>char</type></title><para
>Characters are nothing more than numbers. A character, to C, is merely
an integer of at least 8 bits; depending on your architecture and compiler, it
may be signed or unsigned. Since we're
more used to thinking of characters running from character 0 to
character 255, we can use <type
>unsigned char</type> to get that
range.</para><para
>Since characters are just numbers, a single-quoted character in C acts
like the <function
moreinfo="none"
>ord</function> operator in Perl - it produces an
integer representing the character set codepoint of that character:</para><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;

    int main(int argc, char** argv) {
        printf("%d\n", '*');
        return(EXIT_SUCCESS);
    }</programlisting><para
>This is equivalent to Perl's <userinput
moreinfo="none"
>print ord("*"),"\n"</userinput>. 
Similarly, we can turn numbers into characters with the
<function
moreinfo="none"
>printf</function> format specifier
<userinput
moreinfo="none"
>%c</userinput>, just as in Perl:</para><example
id="cintro.chardata"
><title
>Manipulating <type
>char</type> data</title><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;

    int main(int argc, char** argv) {
        unsigned char c;

        /* print "Character $_ is ", chr($_), "\n" for 0..255; */
        for (c=0; c &lt; 255; c++)
            printf("Character %d is %c\n", c, c);

        return (EXIT_SUCCESS);
    }</programlisting></example><para
>Why do we say <userinput
moreinfo="none"
>c &lt; 255</userinput> instead of
<userinput
moreinfo="none"
>i &lt;= 255</userinput>? Because of the way
<varname
>i</varname> is stored, it can only ever be between 0 and 255,
so our termination clause is useless. When a C value overflows the
storage of its variable, it ``wraps around'' - the higher bits are
truncated. For instance:</para><figure
float="0"
><title
>Overflowing storage</title><screen
format="linespecific"
>                       |87654321| - 8 bits of an unsigned char
                       | Binary |
    c = 254            |11111110|
    c++                |11111111|
    c = 255            |11111111|
    c++               1|00000000| - Overflow
    c = 0              |00000000| - Truncation</screen></figure><para
>So, for an <type
>unsigned char</type>, 255+1 = 0, and since 0 is less
than or equal to 255, our program would never have terminated.</para></sect3><sect3
><title
>short</title><para
>Sometimes an <type
>int</type> stores more bits than you need, so you
may want to use a smaller type. A <type
>short</type> (or <type
>short
int</type>) is usually half the size of an <type
>int</type>: the
limits <constant
>SHRT_MAX</constant> and <constant
>SHRT_MIN</constant>
should tell you the size.</para><programlisting
format="linespecific"
>    printf("The maximum short is %d\n", SHRT_MAX);
    printf("The minimum short is %d\n", SHRT_MIN);</programlisting><para
>(And you can run that in C or Perl at your choice...)</para><para
><type
>short</type>s are available in signed and unsigned flavours, but
are only rarely used.</para></sect3><sect3
><title
><type
>long</type></title><para
>For representing larger numbers, <type
>long</type>s (<type
>long
int</type>s) are sometimes available. On some machines, these are
twice the width of an <type
>int</type>; however, on many machines
<type
>long</type>s and <type
>int</type>s are equivalent. The new C standard,
C99, also allows <type
>long long ints</type>, which are twice as wide
again. Both types are available as <type
>unsigned</type> variants.</para></sect3><sect3
><title
><type
>float</type></title><para
>The world is not purely made up of integers; there are also floating
point values, and these need a separate data type to hold them. (Perl
is happy to have us put strings, integers and floating point values in
the same scalar, but C forces us to split them up.)</para><para
>Floating point types are always signed in C, and a floating point
value is represented by two numbers, the <firstterm
>exponent</firstterm>
(<varname
>e</varname>) and the <firstterm
>mantissa</firstterm>
(<varname
>m</varname>) such that the value to be stored is
<inlineequation
><inlinemediaobject
><imageobject
><imagedata
fileref="mantissa-exponent.eps"
format="eps"
></imagedata></imageobject><imageobject
><imagedata
fileref="mantissa-exponent.gif"
format="gif"
></imagedata></imageobject><textobject
><phrase
>n=m2<superscript
>e</superscript></phrase></textobject></inlinemediaobject></inlineequation>. The choice of the number of bits for exponent and
mantissa determines the accuracy and the range of the type.  It is
important to remember that a floating point number can not represent
every number with complete accuracy. Some numbers (for example
<literal
moreinfo="none"
>1/3</literal> and <literal
moreinfo="none"
>1/7</literal>) can never be
represented perfectly regardless of the number of bits in the float
and this has to be carefully considered if accuracy of numerical
calculations is important to you.</para><para
>You must also carefully consider the difference between floating point
operations and integer operations. Consider the following program:</para><programlisting
format="linespecific"
>#include &lt;stdio.h&gt;

int main (int argc, char** argv) {
  float fraction1 = 1 / 4;
  float fraction2 = 1 / 4.0;
  printf("%f %f\n", fraction1, fraction2);

  return 0;
}</programlisting><para
>When you run this program you may be surprised to get the following output:</para><screen
format="linespecific"
>0.000000 0.250000</screen><para
>Here <varname
>fraction2</varname> correctly has a value of
<literal
moreinfo="none"
>0.25</literal> but <varname
>fraction1</varname> has a value
of <literal
moreinfo="none"
>0.00</literal>. This seeming inconsistency is a product of
the compiler; when the compiler sees literal numbers it has to assign
a type to them. As there is no indication to the contrary, numbers that
look like integers are assigned to integer types and numbers that look
like floating point numbers are assigned floating point types.  This
means that the compiler translated the above assignments to

<programlisting
format="linespecific"
>float fraction1 = (int)1 / (int)4;
float fraction2 = (int)1 / (float)4.0;</programlisting></para><para
>When there is an arithmetic operation between two variables of
different types the compiler converts the variables to the highest
type using the rules given in <xref
linkend="cintro.casting"
></xref>. In this case,
and integer is converted to a <type
>float</type> when combined with
another <type
>float</type>:</para><programlisting
format="linespecific"
>float fraction1 = (int)1 / (int) 4;
float fraction2 = (float)1.0 / (float)4.0;</programlisting><para
>Now for the trick: the division operator performs integer division
(that is, effectively, <computeroutput
moreinfo="none"
>int(1/4)</computeroutput>) when
both of its operands are integers, and floating point division when
its operands are <type
>float</type>s. Hence, the value that's stored
into <varname
>fraction1</varname> is the result of
<emphasis
>integer</emphasis> division of <literal
moreinfo="none"
>1</literal> and
<literal
moreinfo="none"
>4</literal>, and the value that's stored into
<varname
>fraction2</varname> is the floating point division which
keeps the fractional part.</para><para
>The moral of the story is: if you want a floating point result from
your code, make sure that at least one of your operands is a
<type
>float</type>.</para></sect3><sect3
><title
><type
>double</type></title><para
> 
<type
>double</type>s are, very simply, high-precision
<type
>float</type>s; they contain a larger exponent, although how much
larger is unspecified - on this system, doubles can range from
<literal
moreinfo="none"
>2.2250738585072e-308</literal> all the way up to
<literal
moreinfo="none"
>1.79769313486232e+308</literal>; that's 10 bits of exponent
and 53 bits of mantissa.  </para><para
>On some systems, <type
>long double</type>s may be available for even
more bits.</para></sect3><sect3
><title
><type
>void</type></title><para
><type
>void</type> is a special data type which is used, as we've
seen in <xref
linkend="cintro.globvarex"
></xref> above, to indicate that a function
has no return value and should be called in void context.</para><para
>As we'll see in the next chapter, the <type
>void</type> type is also
used as a ``generic type'' to enable data of any type to be passed to
and from a function.</para></sect3></sect2><sect2
id="cintro.typedef"
><title
>Types defined in Perl</title><para
>To get around the implementation-specific nature of the limits of the
basic C types, Perl defines a number of types which are guaranteed to
have certain properties. Perl also defines a number of far more
complex types, which we'll look at in Chapter 3, which allow us to
represent Perl scalars, hashes and so on. For now, we'll examine the
simple types from which almost all variables inside Perl are made
up. For guaranteed portability, you should use these types when your
code interfaces with Perl, rather than the types above.</para><sect3
><title
><type
>I8</type>, <type
>I16</type>, <type
>I32</type></title><para
>This set of types are used for different sizes of integers, and have
the property that they are guaranteed to hold <emphasis
>at
least</emphasis> the number of bits that their name implies: an
<type
>I8</type> will definitely hold 8 bits, (and might hold more) and
so can be used to store values from -128 to 127. An <type
>I8</type> is
almost always equivalent to a <type
>char</type>.</para><para
>Each of these types has a corresponding unsigned type:
<type
>U8</type>, <type
>U16</type>, and <type
>U32</type>. On 64-bit
machines, <type
>I64</type> and <type
>U64</type> are also available. </para><para
>You may ask how these types are defined: C has a special convention
for defining types, the <userinput
moreinfo="none"
>typedef</userinput> operator, which
allows us to provide aliases for type names. Here is <xref
linkend="cintro.chardata"
></xref> reimplemented using <userinput
moreinfo="none"
>typedef</userinput>
and <type
>U8</type>.</para><example
><title
>Using <userinput
moreinfo="none"
>typedef</userinput></title><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;

    typedef unsigned char U8;

    int main(int argc, char** argv) {
        U8 i;

        for (i=0; i &lt; 255; i++)
            printf("Character %d is %c\n", i, i);

        return 0;
    }</programlisting></example></sect3><sect3
><title
><type
>IV</type>, <type
>UV</type></title><para
>An <type
>IV</type>, and its unsigned counterpart <type
>UV</type>, is
the type used to represent integers used in a Perl program. When you
say <userinput
moreinfo="none"
>$a = 123456;</userinput>, the <literal
moreinfo="none"
>123456</literal>
is stored in an <type
>IV</type> or <type
>UV</type>. The reason why
Perl uses an <type
>IV</type> rather than any guaranteed-size types of
the previous section is that <type
>IV</type> provides another
guarantee: it's big enough to be used to store a
<firstterm
>pointer</firstterm>, which is the C equivalent of a
reference. (We'll look into pointers in a lot more detail in the next
chapter, and see how they relate to Perl references in Chapter 3.)</para><remark
>Mention that in general IV is an I32? Maybe not.</remark></sect3><sect3
><title
><type
>NV</type></title><para
>An <type
>NV</type> is the type used to represent floating-point
numbers in a Perl program; once again, this is guaranteed to be able
to store a pointer, although it's hardly ever used to do so. This is
at least a <type
>double</type>.</para></sect3><sect3
><title
><type
>STRLEN</type></title><para
>Finally in our tour of types, <type
>STRLEN</type> is an unsigned
integer type which tells us how big something is in bytes; it's
usually used to represent the size of a string.</para></sect3></sect2></sect1><sect1
id="cintro.casting"
><title
>Casting</title><para
>C uses very simple rules to convert values between types: data will be
converted when it moves from a `smaller' type to a `bigger' type, such
as from an <type
>int</type> to a <type
>float</type>, but when
converting back down, only the portion of the representation which
`fits' in the smaller type will be retained. (This may or may not
trigger a warning from the compiler about information being lost.) For
instance, the following code:

<programlisting
format="linespecific"
>        int x = INT_MAX;
        short int y;
        y = x;</programlisting>

will leave <varname
>y</varname> equal to <literal
moreinfo="none"
>-1</literal>, because
all of the bits in the smaller type will be set. </para><para
>The conversion happens implicitly when two differently-typed values
are the operands to the arithmetic operators, or when one assigns one
value to a variable of different type; it also happens when the type
of a value passed as a function parameter is different to what the
function's prototype says it should be.</para><para
>You can also force the explicit conversion to one particular type by
the use of the <firstterm
>cast</firstterm> operator; simply put the
target type in parentheses before the expression you wish to
cast. This is rarely used for real values, but is extremely important
when we come to examine pointers and structures.</para></sect1><sect1
><title
>Control Constructs</title><para
>Because Perl borrowed its syntax heavily from C, C's control
constructs should be familar to you: we have <userinput
moreinfo="none"
>if (...) 
{...}</userinput>, <userinput
moreinfo="none"
>while (...) {...}</userinput>,
<userinput
moreinfo="none"
>do { ... } while (...)</userinput>and
<userinput
moreinfo="none"
>for(;;;)</userinput>, and these all work the same way they
do in Perl.</para><sect2
><title
>Statements and blocks</title><para
>In C one difference, however, is that one may omit the braces from a block
under a control construct if that block contains only one
statement. For instance, we may write:

<programlisting
format="linespecific"
>     if (a &gt; b) {
         max = a;
     } else {
         max = b;
     }</programlisting>

as:

<programlisting
format="linespecific"
>     if (a &gt; b)
         max = a;
     else
         max = b;</programlisting>
</para><para
>A control construct itself counts as ``only one statement'', so we may
also write such things as this program, to count the number of
printable characters in the character set:</para><programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;
    #include &lt;ctype.h&gt;

    int main(int argc, char **argv)
    {
        unsigned char i;
        int printables = 0;

        for (i=0; i&lt;255; i++)
            if (isprint(i))
                printables++;

        printf("%i printable characters\n", printables);
        return (EXIT_SUCCESS);
    }</programlisting><para
>The function <function
moreinfo="none"
>isprint</function>, whose prototype is in
<filename
moreinfo="none"
>ctype.h</filename> tells us whether or not a character, in
the range 0 to 255, is printable.</para><para
>When using nexted control structures without braces like this, it's
important to be aware of the `<firstterm
>dangling else</firstterm>'
problem; that is, in the following code, which <userinput
moreinfo="none"
>if</userinput>
does the <userinput
moreinfo="none"
>else</userinput> belong to?

<programlisting
format="linespecific"
>     if (utf)
        if (!haslen) 
            len = getlength(string);
     else
        len = 1;</programlisting>

Well, the indentation shows us what we <emphasis
>mean</emphasis> - we
want <varname
>len</varname> to be <literal
moreinfo="none"
>1</literal> if
<varname
>utf</varname> is not set - but that's not how the compiler
sees it; what really happens looks like this:

<programlisting
format="linespecific"
>     if (utf)
        if (!haslen) 
            len = getlength(string);
        else
            len = 1;</programlisting></para><para
>Editors such as <productname
class="trade"
>Emacs</productname> will automatically
indent code to the correct column when you press <keycap
moreinfo="none"
>Tab</keycap>,
but it's best to use braces in such cases anyway to reduce confusion.</para></sect2><sect2
><title
><userinput
moreinfo="none"
>break</userinput> and
      <userinput
moreinfo="none"
>continue</userinput></title><para
>Perl's <userinput
moreinfo="none"
>last</userinput> control statement is spelt
<userinput
moreinfo="none"
>break</userinput> in C. Here's a function which cuts off a
string after the first space character:</para><example
id="cintro.breakex"
><title
><userinput
moreinfo="none"
>break</userinput>ing out of a look</title><programlisting
format="linespecific"
>     int token (char s[]) {
         unsigned int len = strlen(s);
         int i;

         for (i=0; i &lt; len; i++)
             if (isspace(s[i]))
                 break;

         s[i] = '\0';
         return i;
     }</programlisting><para
>When a whitespace character (space, tab, new line, etc.) is found, the
<userinput
moreinfo="none"
>break</userinput> statement makes C immediately leave the
<userinput
moreinfo="none"
>for</userinput> loop, and makes that character the end of
the string. We return the character offset as the new length of the
string; in the next chapter, we'll see how we can use this to get at
the rest of the string.</para></example><para
>Similarly, <userinput
moreinfo="none"
>next</userinput> is replaced by
<userinput
moreinfo="none"
>continue</userinput>; this fragment of code (modified from
<filename
moreinfo="none"
>sv.c</filename> in the Perl core) only processes non-zero
elements in an array:

<programlisting
format="linespecific"
>   for (i=0; i &gt; oldsize; i++) {
        if (!ary[i])
            continue;
        curentp = ary + oldsize;
        ...
   }</programlisting></para><para
>There is no equivalent to Perl's <userinput
moreinfo="none"
>redo</userinput>. If you
really need it, you can use <userinput
moreinfo="none"
>goto</userinput> and labels
just like in Perl, but, just like in Perl, ten times out of ten, you don't.</para></sect2><sect2
><title
><userinput
moreinfo="none"
>switch</userinput></title><para
>One control structure that Perl doesn't have<footnote
><para
>Although Damian Conway's <classname
>Switch</classname>
module provides an implementation</para></footnote> is the <userinput
moreinfo="none"
>switch</userinput>
statement. This allows you to test an expression against multiple
(constant) values. It's a lot easier than using <userinput
moreinfo="none"
>else
if</userinput> over and over again. Here's an example from the Perl
core, when Perl has seen one of the <userinput
moreinfo="none"
>-X</userinput> file
test functions, and is trying to work out which one you mean. It has
the next character in <varname
>tmp</varname>, and is choosing from a
number of constants to set the value of <varname
>fstest</varname>:</para><programlisting
format="linespecific"
>     switch (tmp) {
        case 'r': 
                  ftst = OP_FTEREAD;    
                  break;

        case 'w': 
                  ftst = OP_FTEWRITE;   
                  break;

        case 'x': 
                  ftst = OP_FTEEXEC;    
                  break;

        case 'o': 
                  ftst = OP_FTEOWNED;   
                  break;
        ...
     }</programlisting><para
>Notice that we <userinput
moreinfo="none"
>break</userinput> after every single case;
this is because <userinput
moreinfo="none"
>switch</userinput> is, in fact, a glorified
computed <userinput
moreinfo="none"
>goto</userinput>. If we don't break, the program
control will ``fall through'' to the next case:
<programlisting
format="linespecific"
>     int i = 0;

     switch (i) {
        case 0:
                 printf("It's 0\n");
        case 1:
                 printf("It's 1\n");
        case 2:
                 printf("It's 2\n");
     }</programlisting>

The above code will actually execute <emphasis
>all three</emphasis> print
statements. Sometimes this really is what we want, but we should take
care to mark the ``fall through'' if we're likely to forget it. Here's
an example of how fall through could be useful. Note that we're
actually falling through the cases which have no statements as well;
if the character is <literal
moreinfo="none"
>1</literal>, then we fall through cases
<literal
moreinfo="none"
>2</literal>, <literal
moreinfo="none"
>3</literal>, ... <literal
moreinfo="none"
>7</literal>.</para><programlisting
format="linespecific"
>      switch (c) { /* "c" is some character"
         case '0': case '1': case '2': case '3':
         case '4': case '5': case '6': case '7':
                   could_be_octal = 1;
                   /* Fall through */

         case '8': case '9':
                   could_be_dec = 1;
                   /* Fall through */

         case 'A':
         case 'B':
                   /* This is actually fall through, too */ 
         case 'C':
         case 'D':
         case 'E':
         case 'F':
                   could_be_hex = 1;
       }</programlisting><remark
>Reviewer suggested that we show the equivalent code in perl</remark></sect2></sect1><sect1
id="cintro.macros"
><title
>Macros and the C Preprocessor</title><para
>Before your C code reaches the compiler, it goes through an
intermediary program, the <firstterm
>preprocessor</firstterm>. We've
already said that header files such as <filename
moreinfo="none"
>stdio.h</filename>
and <filename
moreinfo="none"
>ctype.h</filename> contain function prototypes - the
preprocessor is responsible for inserting the content of those files
into the current program. This is done with the
<userinput
moreinfo="none"
>#include</userinput> preprocessor directive:

<programlisting
format="linespecific"
>    #include "header.h"</programlisting>

will insert the contents of the file <filename
moreinfo="none"
>header.h</filename>
from the current directory into the copy of your source code that is
passed to the compiler.  </para><sidebar
><para
>Why did we have this:
<programlisting
format="linespecific"
>    #include "header.h"</programlisting>
but previously this?
<programlisting
format="linespecific"
>    #include &lt;stdio.h&gt;</programlisting></para><para
>The difference is that by using quotes, we are telling the
preprocessor that the file <filename
moreinfo="none"
>header.h</filename> is in our
current directory, but that <filename
moreinfo="none"
>stdio.h</filename> is somewhere
in the system and it should go and look for it; the preprocessor has a
built-in search path which includes the locations of the headers for
the standard library.</para></sidebar><para
>Header files may themselves use <userinput
moreinfo="none"
>#include</userinput>
directives to pull in other files; if we look at the pre-processed
output to our ``hello world'' example, <xref
linkend="cintro.hw"
></xref>, we would
see that many different header files have been included:

<programlisting
format="linespecific"
>    # 1 "/usr/include/stdio.h" 1 3
    # 1 "/usr/include/features.h" 1 3
    # 142 "/usr/include/features.h" 3
    # 208 "/usr/include/features.h" 3
    # 1 "/usr/include/sys/cdefs.h" 1 3
    # 65 "/usr/include/sys/cdefs.h" 3
    # 283 "/usr/include/features.h" 2 3
    # 1 "/usr/include/gnu/stubs.h" 1 3
    # 311 "/usr/include/features.h" 2 3
    # 27 "/usr/include/stdio.h" 2 3
    ...</programlisting> </para><para
>As well as including header files, we may use the preprocessor to
define <firstterm
>macros</firstterm>, pieces of text which will be
substituted in our source. The syntax for a macro is:
<programlisting
format="linespecific"
>    #define <replaceable
>text</replaceable> <replaceable
>replacement</replaceable></programlisting>

For instance, we may use macros to give meaningful names to particular
constants:</para><programlisting
format="linespecific"
>    #define MAX_RECURSE  64
    #define FAILURE      -1

    int recursive ( ... ) {
        static level=0;

        if (++level &gt; MAX_RECURSE) {
            printf("! Maximum recursion level reached!\n");
<remark
>Should be level minus minus</remark>
            level--;
            return FAILURE;
        }
 
        /* Do something here */

        return level--; 
    }</programlisting><para
>Macros may also be given arguments, so they appear to be like
functions; for instance, the <function
moreinfo="none"
>isspace</function> we used in
our <userinput
moreinfo="none"
>break</userinput> example, <xref
linkend="cintro.breakex"
></xref>, is
typically defined as a macro, like this:

<programlisting
format="linespecific"
>#define isspace(c)  ((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) =='\r' || (c) == '\f')</programlisting>

The replacement text will be placed into our program wherever we use
<function
moreinfo="none"
>isspace</function>, and the <varname
>c</varname> is replaced
by whatever argument we gave to it. Thus, when our example reached the
compiler, it probably looked a little more like this;

<programlisting
format="linespecific"
>     int token (char s[]) {
         unsigned int len = strlen(s);
         int i;

         for (i=0; i &lt; len; i++)
             if (((s[i]) == ' ' || (s[i]) == '\t' || (s[i]) == '\n' || (s[i]) =='\r' || (s[i]) == '\f'))
                 break;

         s[i] = '\0';
         return i;
     }</programlisting></para><sidebar
><para
>Because the text is literally replaced, we must be very careful when
calling macros (or things we suspect to be macros) when using
side-effects such as post-increment. If we'd said, for instance,

<programlisting
format="linespecific"
>         while (i &lt; len)
             if (isspace(s[i++]))
                 break;</programlisting>

the compiler would see

<programlisting
format="linespecific"
>         while (i &lt; len)
             if (((s[i++]) == ' '  || 
                  (s[i++]) == '\t' || 
                  (s[i++]) == '\n' || 
                  (s[i++]) == '\r' || 
                  (s[i++]) == '\f'))
                 break;</programlisting>

and <varname
>i</varname> would be incremented rather a lot faster than
we want. </para></sidebar><para
>As that line is very long, we may use backslash (<literal
moreinfo="none"
>\</literal>)
characters to break it up over several lines; when the preprocessor
sees a backslash at the end of a line, it is removed and the next line
is concatenated. Hence, this is equivalent:

<programlisting
format="linespecific"
>#define isspace(c)  ((c) == ' '  || \
                     (c) == '\t' || \
                     (c) == '\n' || \ 
                     (c) == '\r' || \
                     (c) == '\f')</programlisting></para><para
>Perl makes extremely heavy use of macros internally.</para></sect1><sect1
><title
>Library Functions</title><para
> 
As we've already mentioned, C provides a standard library of useful
functions - things like <function
moreinfo="none"
>printf</function> and
<function
moreinfo="none"
>isspace</function>. However, the effects and side-effects of
these library functions can vary between systems, so Perl reimplements
or redefines the useful portion of the standard library internally.</para><para
>The file <filename
moreinfo="none"
>pod/perlclib.pod</filename> in distributions after
5.6.0 and 5.7.0  contains a table of equivalents between the sort of
functions that you'd expect to see in an ordinary C program, and the
functions that should be used in XS, embedding and the Perl
internals, which you'll see in later chapters. </para></sect1><sect1
><title
>Summary</title><para
>We've seen an introduction to the C language from a Perl programmer's
point of view. The most important things you should take from this
chapter are:</para><itemizedlist
><listitem
><para
>In C, everything is a function, even the
	<userinput
moreinfo="none"
>main</userinput> body of your program, and all
	functions should have prototypes before they are called.</para></listitem><listitem
><para
>C has four different types of variable: parameter, automatic, global
and static. All variables <emphasis
>must</emphasis> be declared before
being used.</para></listitem><listitem
><para
>C is a <emphasis
>strongly typed</emphasis> language; it
	has a number of data types, and each variable can have one and
	only one type.</para></listitem><listitem
><para
>C has no built-in functions whatsoever, but it does have a standard
library of functions available; however, as we'll see in later
chapters, when using Perl and C, you're likely to use Perl's
reimplementations of the standard functions. </para></listitem><listitem
><para
>C's syntax is very similar to Perl's, but is more `austere': no
statement modifiers, no <userinput
moreinfo="none"
>foreach</userinput>, no
<userinput
moreinfo="none"
>redo</userinput>, but it does have a
<userinput
moreinfo="none"
>switch</userinput>. </para></listitem><listitem
><para
>C programs are automatically run through a preprocessor which can be
used to give meanings to tokens and create in-line functions.</para></listitem></itemizedlist><remark
>Review comments suggested that we should add something on
portability and linking. Especially since we assume dynamic linking
almost immediately.</remark></sect1></chapter><chapter
id="xsintro"
><title
>Introduction to XS</title><remark
>Assumes we have a book introduction that let's the reader
  know the level of perl and C required</remark><remark
>Reviewer suggestion even more material on module building in
  general. We need to decide whether this is what we really
  want.</remark><para
>This chapter will introduce the fundamentals of interfacing perl to
the C programming language. Before we can describe how to do this
we first have to explain how Perl modules work and how they are created.</para><sect1
id="xsi.modintro"
><title
>Perl Modules</title><para
>This section describes the anatomy of a Perl module distribution.  If
you are already familiar with how to create pure-perl modules then you
can safely skip to the next section. In essence a perl module is
simply a file containing perl code (usually in its own namespace using
the <function
moreinfo="none"
>package</function> keyword) with a file extension of
<filename
moreinfo="none"
>.pm</filename>. When you <function
moreinfo="none"
>use</function> a module,
perl searches through a series of directories (specified by the
<varname
>@INC</varname> array) looking for a file with the correct
name. Once found, the file is parsed and the routines made available
to the main program.  This mechanism allows code to be shared and
re-used and is the reason behind the success of the <firstterm
><ulink
url="http://www.cpan.org"
>Comprehensive Perl Archive
Network</ulink></firstterm> (CPAN).</para><para
>To maximize the reusability of your modules you should write them in
such a way that they do not interfere with other parts of Perl or
other modules.  If this is not done, it would be possible for your
module to clash with other modules or with the main program and this
is undesirable. There are three main ways that this is achieved:</para><itemizedlist
><listitem
><para
>You should assign a namespace to each module. This namespace is usually the
same as the module name but does not have to be. So long as another
part of your program does not choose the identical namespace the module
will only interact with the caller through its defined interface.</para></listitem><listitem
><para
>Your modules should export functions by request rather than by
default. If all the functions provided by a module are exported then
it is possible that they will clash with other functions already in
use. This is particularly important if new functions are added to a
module after the main program has been written since you may add a
routine that will overwrite a previous definition.  This is not
relevant when object-oriented classes are defined since they never
export functions explicitly.</para></listitem><listitem
><para
>Lexical variables (i.e. those declared with
	<function
moreinfo="none"
>my</function>) should be used in modules wherever
	possible to limit access from outside the namespace and to
	make it easier for the module to become
	"thread-safe"<footnote
><para
>We will not attempt to cover
	thread safety here. All you need to know for this book is that
	global variables and static memory hinder the use of threads
	since you have to make sure that parallel threads do not
	change the information in a variable whilst another thread is
	using the value. If you only use Perl lexical variables and C
	automatic variables you will be fine.</para></footnote>. Globals should only be used when absolutely
	necessary and in many cases you can limit them to
	<varname
>$VERSION</varname> for version numbering,
	<varname
>$DEBUG</varname> for switching debugging state and
	the <classname
>Exporter</classname> globals. In other words,
	globals that are not modified during program execution.</para></listitem></itemizedlist><para
>Here is an example of a minimalist module that shows how these
constraints can be implemented:</para><programlistingco
><areaspec
><area
coords="1"
id="xsi.mod.package"
></area><area
coords="3"
id="xsi.mod.perlversion"
></area><area
coords="4"
id="xsi.mod.strict"
></area><area
coords="6"
id="xsi.mod.export"
></area><area
coords="8"
id="xsi.mod.vers"
></area><area
coords="10"
id="xsi.mod.explist"
></area><area
coords="13"
id="xsi.mod.code"
></area><area
coords="15"
id="xsi.mod.retval"
></area></areaspec><programlisting
format="linespecific"
>package Example;

use 5.006;
use strict;

use base qw/Exporter/;

our $VERSION = '1.00';

our @EXPORT_OK = qw/ myfunc /;

# Code
sub myfunc { 1; }

1;</programlisting><calloutlist
><callout
arearefs="xsi.mod.package"
><para
>This is the namespace declaration. All code in this file
is only visible in this namespace unless explicitly referred
to from outside or until a new <function
moreinfo="none"
>package</function> function
is found.</para></callout><callout
arearefs="xsi.mod.perlversion"
><para
>This line makes sure that the perl version used by this module is at
least version 5.6.0 (5.006 in the old numbering style). This is
because the module makes use of the <function
moreinfo="none"
>our</function> variable
declaration that was introduced in this version of Perl</para></callout><callout
arearefs="xsi.mod.strict"
><para
>All Perl modules should have <classname
>strict</classname>
checking. Among other things, this pragma instructs Perl to tell you
of any undeclared variables that it comes across; an excellent way to
minimize obvious bugs in code.</para></callout><callout
arearefs="xsi.mod.export"
><para
>Here we inherit methods from the <classname
>Exporter</classname> class
in order to enable exporting of functions and variables to the
namespace that <function
moreinfo="none"
>use</function>es this module.</para></callout><callout
arearefs="xsi.mod.vers"
><para
>This line defines the version number of the module. It is used by CPAN
for indexing and to enable Perl to check that the correct version of a
module is available.</para></callout><callout
arearefs="xsi.mod.explist"
><para
>The <varname
>@EXPORT_OK</varname> array contains a list of all the
functions that can be exported by this routine. They will not be
exported unless explicitly requested. The <varname
>@EXPORT</varname>
array can be used to always export a function but that is not
desirable in most cases.</para></callout><callout
arearefs="xsi.mod.code"
><para
>This is the code that implements the module functionality. The actual
code for the module goes here.</para></callout><callout
arearefs="xsi.mod.retval"
><para
>All modules that are read into Perl must finish with a true value (in
this case <literal
moreinfo="none"
>1</literal>) so that Perl can determine that the
module was read without error.</para></callout></calloutlist></programlistingco><para
>If you name this file <filename
moreinfo="none"
>Example.pm</filename> we can load it with:</para><programlisting
format="linespecific"
>use Example qw/ myfunc /;</programlisting><para
>in order to import the named function into the current
namespace. Alternatively if you load it as</para><programlisting
format="linespecific"
>use Example;</programlisting><para
>the function <function
moreinfo="none"
>myfunc</function> will not be imported but can
still be accessed as <function
moreinfo="none"
>Example::myfunc()</function>. More
information on perl modules can be found in the
"<filename
moreinfo="none"
>perlmod</filename>" man page that comes with Perl.</para><sect2
id="xsi.moddist"
><title
>Module distributions</title><para
>With a single perl-only module installation could consist simply of copying
the file to a location that Perl searches in or by changing the
<envar
>PERL5LIB</envar> environment variable so that it contains the
relevant directory. For anything more complex or if the module is to
be distributed to other sites (for example via the CPAN) Perl provides
a framework that can be used to automate installation. In order to use
this framework we need to create a number of files in addition to the module:</para><variablelist
><varlistentry
><term
><filename
moreinfo="none"
>README</filename></term><listitem
><para
> This simply provides a short description of the module, how to
 install it and any additional information the author wanted to
 add. The file is not required by Perl but is useful to have and it is
 required for any module submitted to CPAN.</para></listitem></varlistentry><varlistentry
><term
><filename
moreinfo="none"
>Makefile.PL</filename></term><listitem
><remark
>More explicit description of make? Need to explain
	    how it works with reference to timestamps and
	    dependencies.</remark><para
>  Along with the module itself this is the most important file that
  should be supplied to help build a module. It is a Perl program that
  generates a make file when run <footnote
><para
>a makefile is a list
  of rules used by the <command
moreinfo="none"
>make</command> program to determine
  what action to take. <command
moreinfo="none"
>make</command> is a standard program
  on most unix distributions. On <trademark
class="trade"
>Windows</trademark> and
  other operating systems that lack compilers as standard, it will be
  necessary to install a version of
  <command
moreinfo="none"
>make</command></para></footnote>. It is this makefile that
  is used to build, test and install the module. A Perl module
  installation usually consists of:</para><screenco
><areaspec
><area
coords="1"
id="xsi.s1.pmakepl"
></area><area
coords="2"
id="xsi.s1.pmake"
></area><area
coords="3"
id="xsi.s1.pmaket"
></area><area
coords="4"
id="xsi.s1.pmakei"
></area></areaspec><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt><userinput
moreinfo="none"
> perl Makefile.PL</userinput>
<prompt
moreinfo="none"
>%</prompt><userinput
moreinfo="none"
> make</userinput>
<prompt
moreinfo="none"
>%</prompt><userinput
moreinfo="none"
> make test</userinput>
<prompt
moreinfo="none"
>%</prompt><userinput
moreinfo="none"
> make install</userinput>
</screen><calloutlist
><callout
arearefs="xsi.s1.pmakepl"
><para
>Generate the make file</para></callout><callout
arearefs="xsi.s1.pmake"
><para
>use the <filename
moreinfo="none"
>Makefile</filename> to build the module.</para></callout><callout
arearefs="xsi.s1.pmaket"
><para
>Run any included tests.</para></callout><callout
arearefs="xsi.s1.pmakei"
><para
>Install the module into the standard location.</para></callout></calloutlist></screenco><para
>  The <filename
moreinfo="none"
>Makefile.PL</filename> is useful since it deals with
  all the platform specific options that are required to build
  modules. This system guarantees that modules are built using the
  same parameters that were used to build Perl itself. This platform
  configuration information is stored by Perl in the
  <classname
>Config</classname> module.</para><para
>  At its simplest the <filename
moreinfo="none"
>Makefile.PL</filename> is a very short
  program that runs one subroutine:</para><programlisting
format="linespecific"
>   use ExtUtils::MakeMaker;
   # See lib/ExtUtils/MakeMaker.pm for details of how to influence
   # the contents of the Makefile that is written.
   WriteMakefile(
       'NAME'		=&gt; 'Example',
       'VERSION_FROM'	=&gt; 'Example.pm', # finds $VERSION
       'PREREQ_PM'	=&gt; {}, # e.g., Module::Name =&gt; 1.1
   );</programlisting><para
>  All of the system dependent functionality is provided by the
  <classname
>ExtUtils::MakeMaker</classname> module. The
  <function
moreinfo="none"
>WriteMakefile</function> routine accepts a hash that
  controls the contents of the makefile. In the above example NAME
  specifies the name of the module, VERSION_FROM indicates that the
  version number for the module should be read from the VERSION
  variable in the module itself and PREREQ_PM lists the dependencies
  for this module (the <classname
>CPAN</classname> module uses this to
  determine which other modules should be installed). Additional
  options will be described in later sections and a full description
  can be found in the documentation for
  <classname
>ExtUtils::MakeMaker</classname>.</para></listitem></varlistentry><varlistentry
><term
><filename
moreinfo="none"
>MANIFEST</filename></term><listitem
><para
> A list of all the files that are meant to be part of the
 distribution. When the <filename
moreinfo="none"
>Makefile.PL</filename> program is
 run it checks this file to make sure all the required files are
 available. This file is not required but is recommended in order to
 test the integrity of the distribution and for creating a
 distribution file when using "<userinput
moreinfo="none"
>make dist</userinput>".</para></listitem></varlistentry><varlistentry
><term
><filename
moreinfo="none"
>test.pl</filename></term><term
><filename
moreinfo="none"
>t</filename> directory</term><listitem
><para
> Although not a requirement, all module distributions should include a
 test suite. Test files are very important for testing the integrity
 of the module. They can be used to make sure that the module works
 now, that it works after improvements are made and that it works on
 platforms that may not be accessible by the module author. When Perl
 sees a <filename
moreinfo="none"
>test.pl</filename> file in the current directory the
 resultant <filename
moreinfo="none"
>Makefile</filename> includes a test target that
 will run this file and check the results. A good test suite is one
 that uses all the functionality of the module in strange ways. A bad
 test suite is one that simply loads the module and exits (or, even
 worse, no test suite at all). Perl provides two means of testing a
 module. The <filename
moreinfo="none"
>test.pl</filename> file is the simplest but a
 more extensible approach is to create a test directory (called simply
 <filename
moreinfo="none"
>t</filename>) containing multiple tests. The convention is
 that tests in the <filename
moreinfo="none"
>t</filename> directory have a file suffix
 of <filename
moreinfo="none"
>.t</filename> and are named after the functionality they
 are testing. (for example <filename
moreinfo="none"
>loading.t</filename>,
 <filename
moreinfo="none"
>ftp.t</filename>). Test programs are written using the
 framework provided by the <classname
>Test</classname> module. A
 simple example, based on <classname
>Example</classname> could be:</para><example
id="xsi.ex.test"
><title
>Simple test program</title><programlistingco
><areaspec
><area
coords="2"
id="xsi.testmod"
></area><area
coords="4"
id="xsi.begin"
></area><area
coords="6"
id="xsi.loadmod"
></area><area
coords="7"
id="xsi.testok"
></area><area
coords="10"
id="xsi.testrun"
></area></areaspec><programlisting
format="linespecific"
>use strict;
use Test;

BEGIN { plan tests =&gt; 2 }

use Example qw/ myfunc /;
ok(1);

my $result = myfunc(); 
ok( 1, $result );
</programlisting><calloutlist
><callout
arearefs="xsi.testmod"
><para
>Load the testing framework.</para></callout><callout
arearefs="xsi.begin"
><para
>Inform the test framework to expect two test results.</para></callout><callout
arearefs="xsi.loadmod"
><para
>Load the module that is being tested and import the required routines.</para></callout><callout
arearefs="xsi.testok"
><para
>The <function
moreinfo="none"
>ok</function> takes the supplied argument and checks to
see whether the argument is true or false. In this case the argument
is always true and the <function
moreinfo="none"
>ok</function> always prints an
<computeroutput
moreinfo="none"
>ok</computeroutput> message so long as the module has
been loaded successfully. If the module fails to load this line will
never be reached.</para></callout><callout
arearefs="xsi.testrun"
><para
>In this line, the <function
moreinfo="none"
>ok</function> routine accepts two
arguments: the expected result and the result from the current
test. An <computeroutput
moreinfo="none"
>ok</computeroutput> message is printed if the
two arguments are equal, <computeroutput
moreinfo="none"
>not ok</computeroutput> if
they are different.</para></callout></calloutlist></programlistingco></example></listitem></varlistentry></variablelist><remark
>Is there enough structure to have a diagram that shows
      the directory structure? There is only a t directory. so the
      structure is essentially:</remark><programlisting
format="linespecific"
>module dir -  Makefile.PL
              Module.pm
              MANIFEST
              t        -  test1.t
                          test2.t</programlisting><remark
>so it is not very interesting but might be worth it</remark><para
>Templates for these files can be created by using the
<command
moreinfo="none"
>h2xs</command> program that comes as part of perl. When used
with the <option
>-X</option> option a basic set of files are created:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>h2xs -X Example</userinput>
<computeroutput
moreinfo="none"
>Writing Example/Example.pm
Writing Example/Makefile.PL
Writing Example/README
Writing Example/test.pl
Writing Example/Changes
Writing Example/MANIFEST</computeroutput></screen><para
>In addition to the files described above <command
moreinfo="none"
>h2xs</command>
generates a file called <filename
moreinfo="none"
>Changes</filename> that can be used
to track changes that are made to the module during its lifetime. This
information is useful for checking what has happened to the module and
some editors (e.g. <application
moreinfo="none"
>emacs</application>) provide an easy
means of adding to these files as the code evolves. </para></sect2></sect1><sect1
id="xsi.xs"
><title
>Interfacing to another language - C from XS</title><para
>Now that we have covered how to create a module and
    determined that we need to interface to other languages, this
    section will describe the basics of how to combine C code with
    Perl. We start with C because that is the simplest (perl itself is
    written in C). Additionally, this section will only describe how
    to interface to C using facilities that are available in every
    perl distribution. Interfacing to C using other techniques
    (e.g. <application
moreinfo="none"
>SWIG</application> and the
    <classname
>Inline</classname> module) will be described in <xref
linkend="altxs"
></xref>. If you are familiar with the basics, more
    advanced XS topics are covered in <xref
linkend="advxs"
></xref>.</para><para
>Perl provides a system called XS (for eXternal Subroutines)  that can be used to link it to
other languages. XS is a glue language that is used to indicate to
Perl the types of variables to be passed into the function and the
variables that are to be returned. The XS file is translated to C code
that can be understood by the rest of the perl internals by the XS
compiler (called <command
moreinfo="none"
>xsubpp</command>). In addition to the XS
file, the compiler requires a file that knows how to deal with
specific variable types (for input and output). This file is called a
<firstterm
>typemap</firstterm> and, for example, contains information
on how to turn a perl scalar variable into a C integer.</para><para
>This section will begin by describing the changes that have to be made
to a standard Perl module in order to use XS and will then proceed
with an example of how to provide simple C routines to Perl.</para><sect2
><title
>The perl module</title><para
>As a first example, we will construct a perl module that provides
access to some of the examples from <xref
linkend="cintro"
></xref>.  The first
thing we need to do is to generate the standard module infrastructure
described in <xref
linkend="xsi.modintro"
></xref> using <command
moreinfo="none"
>h2xs</command>
but this time without the <option
>-X</option> option to indicate that
we are writing an XS extension. The module can be called
<classname
>Example</classname>:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>h2xs -A -n Example</userinput>
<computeroutput
moreinfo="none"
>Writing Example/Example.pm
Writing Example/Example.xs
Writing Example/Makefile.PL
Writing Example/README
Writing Example/test.pl
Writing Example/Changes
Writing Example/MANIFEST</computeroutput></screen><para
>The <option
>-A</option> option is used to indicate to
<command
moreinfo="none"
>h2xs</command> that constant autoloading is not required;
more on that later (see <xref
linkend="xsi.autoload"
></xref>).  The
<option
>-n</option> is used to specify the name of the module in the
absence of a C header file. Besides the creation of the
<filename
moreinfo="none"
>Example.xs</filename> file the only change made to the files
generated previously is to change the perl module (the
<filename
moreinfo="none"
>.pm</filename> file) so that it will load the C code that is
to be generated. The module created by <command
moreinfo="none"
>h2xs</command> has
many features that are not important for this discussion so we will
start from the minimalist module described in <xref
linkend="xsi.modintro"
></xref> and modify it to support shared libraries:</para><programlistingco
><areaspec
><area
coords="1"
id="xsi.expack"
></area><area
coords="6"
id="xsi.dynload"
></area><area
coords="9"
id="xsi.newexplist"
></area><area
coords="11"
id="xsi.bootstrap"
></area></areaspec><programlisting
format="linespecific"
>package Example;

use 5.006;
use strict;

use base qw/Exporter DynaLoader/;

our $VERSION = '0.01';
our @EXPORT_OK = qw/ print_hello /;

bootstrap Example $VERSION;
1;</programlisting><calloutlist
><callout
arearefs="xsi.expack"
><para
>Start a new package (namespace) named <classname
>Example</classname>.</para></callout><callout
arearefs="xsi.dynload"
><para
>This class now inherits from both <classname
>Exporter</classname> and <classname
>DynaLoader</classname>.</para></callout><callout
arearefs="xsi.newexplist"
><para
>The <function
moreinfo="none"
>print_hello</function> function is only referenced in
the export list; the shared library is responsible for supplying all
the information required by perl to implement this function.</para></callout><callout
arearefs="xsi.bootstrap"
><para
>Load the <classname
>Example</classname> shared library associated with the provided version number.</para></callout></calloutlist></programlistingco><para
>There are only two changes: The first is that the module now inherits
from the <classname
>DynaLoader</classname> module as well as the
<classname
>Exporter</classname> module. The
<classname
>DynaLoader</classname> provides the code necessary to load
shared libraries into Perl. The shared libraries are created from the
XS code on systems that support dynamic loading of shared libraries
<footnote
><para
>on other systems it is still possible to use
<classname
>DynaLoader</classname> but the module must be statically
linked into the perl binary by using <userinput
moreinfo="none"
>make perl</userinput>
rather than just <userinput
moreinfo="none"
>make</userinput> for the second
stage.</para></footnote>. The second change is the line added just
before the end of the module. The bootstrap function is the one that
does all the work of loading the dynamic library named
<classname
>Example</classname> making sure that the version matches
<varname
>$VERSION</varname>. The bootstrap function is technically a
method that is inherited from the <classname
>DynaLoader</classname>
class and is the equivalent of <userinput
moreinfo="none"
>Example-&gt;bootstrap($VERSION);</userinput></para></sect2><sect2
><title
>The XS File</title><para
>Now that the preliminaries are taken care of the XS file itself must
be examined and edited. The first part of any XS file is written as if
you are writing a C program and the contents are copied to the output
C file without modification. This section should always start by
including the standard perl include files so that the perl internal
functions are available:</para><programlisting
format="linespecific"
>#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"</programlisting><para
>These always have to be here and are not automatically added by the
xsub compiler (although <command
moreinfo="none"
>h2xs</command> includes them) when it
generates the C file. Any other C functions or definitions may be
included in the first section of the file.</para><para
>As a first example of interfacing Perl to C we will start by trying to
extend Perl to include functions described in <xref
linkend="cintro"
></xref>.  These must either be added to the
<filename
moreinfo="none"
>.xs</filename> file directly or included from either a specially
built library or a separate file in the distribution. For simplicity
we will start by adding the code from <xref
linkend="cintro.hw"
></xref> and <xref
linkend="cintro.treble"
></xref> directly to the <filename
moreinfo="none"
>.xs</filename> file:</para><programlistingco
><areaspec
><area
coords="3"
id="xsi.void"
></area></areaspec><programlisting
format="linespecific"
>#include &lt;stdio.h&gt;

<remark
>add <type
>void</type> argument to <function
moreinfo="none"
>print_hello</function>? if we want to be ANSI pedantic.</remark>

void print_hello () 
{
   printf("hello, world\n");
}

int treble(int x)
{
   x *= 3;
   return x;
}</programlisting><calloutlist
><callout
arearefs="xsi.void"
><para
>Here we have replaced the <function
moreinfo="none"
>main</function>
	    declaration of <xref
linkend="cintro.hw"
></xref> with a new
	    function name that can be called from elsewhere. This code
	    can not be run on its own - it needs to be called.</para></callout></calloutlist></programlistingco><para
>The XS part of the file is indicated by using the
<varname
>MODULE</varname> keyword.  This declares the module namespace
and defines the name of the shared library that is created. Anything
after this line must be in the <emphasis
>XS Language</emphasis>. The
name of the perl namespace to be used for functions is also defined on
this line. This allows multiple namespaces to be defined within a
single module.</para><programlisting
format="linespecific"
>MODULE = Example  PACKAGE = Example</programlisting><para
>Once the module and package name have been declared the XS functions
themselves can be added. </para></sect2><sect2
id="xsi.helloworld"
><title
>Example: &quot;Hello, world&quot;</title><para
>As a first example we will simply call the
<function
moreinfo="none"
>print_hello</function> declared at the start of the
file. This has the advantage of being the simplest type of function to
call from XS since it takes no arguments and has no return values. The
XS code to call this is therefore very simple:</para><programlistingco
><areaspec
><area
coords="1"
id="xsi.xs1.retval"
></area><area
coords="2"
id="xsi.xs1.func"
></area></areaspec><programlisting
format="linespecific"
>void
print_hello()
</programlisting><calloutlist
><callout
arearefs="xsi.xs1.retval"
><para
>Type of value returned to perl from this function. In this case
nothing is returned so the value is <type
>void</type></para></callout><callout
arearefs="xsi.xs1.func"
><para
>Name of the function as seen from perl and the arguments to be
passed in.</para></callout></calloutlist></programlistingco><para
>An XS function consists of a definition of the type of variable to be
returned to Perl, the name of the function with its arguments and then
a series of optional blocks that further define the function. 

<important
><para
>Unlike a C prototype XS must have the return type (in this case <type
>void</type>) by itself on the first line of the declaration with the function
name and arguments on the next. </para></important>

This
function is very simple so XS needs no extra information to work out
how to interface perl to the <function
moreinfo="none"
>print_hello</function>
function.</para><para
>Your XS file should now contain the following:</para><programlisting
format="linespecific"
>#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include &lt;stdio.h&gt;

void print_hello ()
{
   printf("hello, world\n");
}

int treble(int x)
{
   x *= 3;
   return x;
}

MODULE = Example  PACKAGE = Example

void
print_hello()</programlisting><para
>If this file is saved as <filename
moreinfo="none"
>Example.xs</filename> the module
can be built in the <emphasis
>normal</emphasis> way (don't forget to
add this file to the <filename
moreinfo="none"
>MANIFEST</filename> if it is not there
already):</para><example
id="xsi.build1"
><title
>Output from build of first XS example</title><screenco
><areaspec
><area
coords="2"
id="xsi.mk.manifest"
></area><area
coords="6"
id="xsi.mk.mkdir"
></area><area
coords="13"
id="xsi.mk.cppm"
></area><area
coords="16"
id="xsi.mk.xsubpp"
></area><area
coords="18"
id="xsi.mk.proto"
></area><area
coords="19"
id="xsi.mk.gcc"
></area><area
coords="23"
id="xsi.mk.ld"
></area></areaspec><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl Makefile.PL</userinput>
Checking if your kit is complete...
Looks good
Writing Makefile for Example
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>make</userinput>
mkdir blib
mkdir blib/lib
mkdir blib/arch
mkdir blib/arch/auto
mkdir blib/arch/auto/Example
mkdir blib/lib/auto
mkdir blib/lib/auto/Example
cp Example.pm blib/lib/Example.pm
/usr/bin/perl -I/usr/lib/perl5/5.6.0/i386-linux -I/usr/lib/perl5/5.6.0
  /usr/lib/perl5/5.6.0/ExtUtils/xsubpp  
  -typemap /usr/lib/perl5/5.6.0/ExtUtils/typemap Example.xs &gt; Example.xsc 
  &amp;&amp; mv Example.xsc Example.c
Please specify prototyping behavior for Example.xs (see perlxs manual)
gcc -c  -fno-strict-aliasing -O2 -march=i386 -mcpu=i686 -DVERSION=\"0.01\"
  -DXS_VERSION=\"0.01\" -fPIC -I/usr/lib/perl5/5.6.0/i386-linux/CORE  Example.c
Running Mkbootstrap for Example ()
chmod 644 Example.bs
LD_RUN_PATH="" gcc -o blib/arch/auto/Example/Example.so  
  -shared -L/usr/local/lib Example.o     
chmod 755 blib/arch/auto/Example/Example.so
cp Example.bs blib/arch/auto/Example/Example.bs
chmod 644 blib/arch/auto/Example/Example.bs</screen><calloutlist
><callout
arearefs="xsi.mk.manifest"
><para
>This checks that all the relevant parts of the
	      distribution are present by comparing the contents of
	      the directory with the contents listed in the
	      <filename
moreinfo="none"
>MANIFEST</filename> file.</para></callout><callout
arearefs="xsi.mk.mkdir"
><para
>The first step is to create the directory
	      structure that will receive the module files as the
	      build proceeds. This directory is called
	      <filename
moreinfo="none"
>blib</filename> for &quot;Build
	      Library&quot;.</para></callout><callout
arearefs="xsi.mk.cppm"
><para
>This copies all the perl files to the architecture
	      independent directory.</para></callout><callout
arearefs="xsi.mk.xsubpp"
><para
>This line runs the XS compiler and translates the
	      XS file to C code. The compiled file is written to a
	      temporary file and then moved to
	      <filename
moreinfo="none"
>Example.c</filename> rather than writing
	      straight to the C file. This is done to prevent
	      partially translated files being mistaken for valid C
	      code.</para></callout><callout
arearefs="xsi.mk.proto"
><para
>This warning can be ignored. It is informing you
	      that some XS functions were defined without specifying a
	      perl prototype. This warning can be removed either by
	      using <userinput
moreinfo="none"
>PROTOTYPES: DISABLE</userinput> in the
	      XS file after the <varname
>MODULE</varname> declaration
	      or by specifying a prototype for each XS function by
	      including a <varname
>PROTOTYPE:</varname> in each
	      definition.</para></callout><callout
arearefs="xsi.mk.gcc"
><para
>The C file generated by <command
moreinfo="none"
>xsubpp</command>
	      is then compiled. The compiler and compiler options are
	      the same as those used to compile perl itself. The
	      values can be retrieved from the
	      <classname
>Config</classname> module. Additional
	      arguments can be specified in the
	      <filename
moreinfo="none"
>Makefile.PL</filename>.</para></callout><callout
arearefs="xsi.mk.ld"
><para
>The final step in library creation is to combine
	      all the object files (there can be more than one if
	      additional code is required) and generate the shared
	      library. Again the method for this is platform dependent
	      and the methods are retrieved from the
	      <classname
>Config</classname> module.</para></callout></calloutlist></screenco></example><para
><remark
>We also may want to grab the output of the same thing on 
Windows NT to show how similar it is and where the differences lie.
Not because NT is the only other option, but to indicate that Perl
will take care of the differences for you.</remark></para><figure
float="0"
id="xsintro.xstoso"
><title
>Transforming an XS file to a shared library.</title><mediaobject
><imageobject
><imagedata
fileref="xstoso.eps"
format="eps"
></imagedata></imageobject><imageobject
><imagedata
fileref="xstoso.png"
format="png"
></imagedata></imageobject><caption
><para
>Flow diagram demonstrating the steps involved in
	    transforming a <filename
moreinfo="none"
>.xs</filename> file to a shared
	    library. The bracketed commands and the suffices for
	    object code and shared libraries will vary depending on
	    the operating system used. </para></caption></mediaobject></figure><para
>When the <command
moreinfo="none"
>Makefile.PL</command> is run it now
      finds a <filename
moreinfo="none"
>.xs</filename> file in the directory and
      modifies the resulting makefile to process that in addition to
      the perl module. The build procedure therefore adjusts itself to
      the presence of the <filename
moreinfo="none"
>.xs</filename> file. The
      additional steps in the procedure are illustrated in <xref
linkend="xsintro.xstoso"
></xref>. We don't yet have a test program but
      we can test the newly built module from the command line to see
      what happens:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MExample -e 'Example::print_hello'</userinput>
<computeroutput
moreinfo="none"
>Using /examples/Example/blib
hello, world</computeroutput></screen><para
>As expected, we now see the <computeroutput
moreinfo="none"
>hello,
world</computeroutput> message. The command-line options are standard
Perl but may require further explanation if you are not familiar with
using Perl in this way.  This example uses the <option
>-M</option>
option to ask perl to load the external modules
<classname
>blib</classname> and <classname
>Example</classname> and
then execute the string <function
moreinfo="none"
>Example::print_hello</function>. The
full package name is required for the subroutine name since Perl will
not import it into the <classname
>main</classname> namespace by
default. The <classname
>blib</classname> module simply configures perl
to use a build tree to search for new modules. This is required
because the <classname
>Example</classname> module has not yet been
installed. Running tests like this is not very efficient or scalable
so the next step in the creation of this module is to write a test
program. The testing framework provided by the
<classname
>Test</classname> module <footnote
><para
>Prior to versions
5.6.1 of Perl the test program created by <command
moreinfo="none"
>h2xs</command> does
not use the <classname
>Test</classname> module and is therefore more
complicated than is necessary</para></footnote> makes this easy. Here
the test program from <xref
linkend="xsi.ex.test"
></xref> has been modified to
test our <classname
>Example</classname> module:</para><programlisting
format="linespecific"
>use strict;
use Test;
BEGIN { plan tests =&gt; 2 }
use Example;

ok(1);
print_hello;
ok(1);</programlisting><para
>If the above program is saved to a file named
<filename
moreinfo="none"
>test.pl</filename> we can then use the make program to run
the test<footnote
><para
>It may be necessary to rerun the makefile
creation phase if the test program is created after the makefile has
been created. This is because Perl adjusts the contents of the
makefile depending upon what is present in the module
distribution.</para></footnote></para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>make test</userinput>
<computeroutput
moreinfo="none"
>PERL_DL_NONLAZY=1 /usr/bin/perl -Iblib/arch -Iblib/lib -I/usr/lib/perl5/5.6.0/i386-linux -I/usr/lib/perl5/5.6.0 test.pl
1..1
ok 1
hello, world
ok 2</computeroutput></screen><para
>The problem with the simple test above is that it is not really
testing the <function
moreinfo="none"
>print_hello</function> subroutine but simply
whether (a) the module has loaded (b) the
<function
moreinfo="none"
>print_hello</function> subroutine runs without
crashing. Whilst these are useful tests to do they do not tell us
anything about the subroutine itself. This is because the testing
system can only test variables and the
<function
moreinfo="none"
>print_hello</function> routine does not return anything to
the caller to indicate that everything is okay. The next section
will fix this by adding return values.</para></sect2><sect2
><title
>Return Values</title><para
>Adding a simple return value to an XS routine (i.e. a single scalar, not
a list) involves telling Perl the type of return value to expect. Our
<function
moreinfo="none"
>print_hello</function> C function does not have a return
value (it returns void) so it must be modified. We can do this by
adding this function to the top of our XS file:</para><example
id="xsi.ex.retval"
><title
>&quot;Hello, world&quot; with a return value.</title><programlisting
format="linespecific"
>int print_hello_retval ()
{
   int retval;
   retval = printf("hello, world\n");
   return retval;
}</programlisting></example><para
>Here we have added a new function with a slightly different name to
indicate that we are now returning an <type
>int</type>eger value. This
makes use of the fact that the <function
moreinfo="none"
>printf</function> returns
the number of characters that have been printed.</para><para
>We can now add a new function to our XS code to take the return value
into account:</para><programlisting
format="linespecific"
>int
print_hello_retval()</programlisting><para
>Here the function is absolutely identical to the XS code for
<function
moreinfo="none"
>print_hello</function> except that the <type
>void</type>
declaration has now been changed to an <type
>int</type>. Once this is
saved it can be rebuilt simply by typing <userinput
moreinfo="none"
>make</userinput>
as before. If we now modify the test script to add</para><programlisting
format="linespecific"
>my $retval = print_hello_retval();
ok( 13, $retval );</programlisting><para
>and change the planned number of test to three we can now test that
the routine is returning the correct value (in this case the number of
printed characters should be <literal
moreinfo="none"
>13</literal>):</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>make test</userinput>
<computeroutput
moreinfo="none"
>PERL_DL_NONLAZY=1 /usr/bin/perl -Iblib/arch -Iblib/lib -I/usr/lib/perl5/5.6.0/i386-linux -I/usr/lib/perl5/5.6.0 test.pl
1..3
ok 1
hello, world
ok 2
hello, world
ok 3</computeroutput></screen><para
>If the return value did not agree with the value we were expecting 
the test script would have told us there was a problem:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>make test</userinput>
<computeroutput
moreinfo="none"
>PERL_DL_NONLAZY=1 /usr/bin/perl -Iblib/arch -Iblib/lib -I/usr/lib/perl5/5.6.0/i386-linux -I/usr/lib/perl5/5.6.0 test.pl
1..3
ok 1
hello, world
ok 2
hello, world
not ok 3
# Test 3 got: '13' (test.pl at line 11)
#   Expected: '12'</computeroutput></screen></sect2><sect2
><title
>Arguments and return values</title><para
>Our <function
moreinfo="none"
>treble</function> function from <xref
linkend="cintro"
></xref> 
takes an integer argument and returns an integer. This would be
represented in XS as follows:</para><example
id="xsi.ex3"
><title
>XS for the treble function</title><programlistingco
><areaspec
><area
coords="1"
id="xsi.ex3.retval"
></area><area
coords="2"
id="xsi.ex3.proto"
></area><area
coords="3"
id="xsi.ex3.arg"
></area></areaspec><programlisting
format="linespecific"
>int
treble( x )
  int x
</programlisting><calloutlist
><callout
arearefs="xsi.ex3.retval"
><para
>Returns an integer</para></callout><callout
arearefs="xsi.ex3.proto"
><para
>This is the signature of the command as it will be visible to
Perl. There is now an input argument.</para></callout><callout
arearefs="xsi.ex3.arg"
><para
>All the arguments listed in the previous line are then typed in
this and successive lines. For simple C types Perl knows the
translation without having to be told.</para></callout></calloutlist></programlistingco></example><para
>The example from <xref
linkend="cintro"
></xref> could now be written as:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>cat treble.pl</userinput>
<computeroutput
moreinfo="none"
>use Example;
print "Three times ten is ", Example::treble(10), "\n";</computeroutput>
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib treble.pl</userinput>
<computeroutput
moreinfo="none"
>Three times ten is 30</computeroutput></screen></sect2></sect1><sect1
id="xsi.further"
><title
>Taking things further</title><para
>So far we have shown how to use XS to provide wrappers to simple C
functions with simple arguments where we want the signature of the
Perl subroutine to match the signature of the C function. In many
cases this is too simplistic an approach and extra code must be
supplied in the XS layer. The XS wrapper allows C code to be provided
as part of the subroutine definition using the
<function
moreinfo="none"
>CODE</function> keyword. XS keywords occur after the initial
XSUB declaration and are followed by a colon.  Here are <xref
linkend="xsi.ex.retval"
></xref> and <xref
linkend="xsi.ex3"
></xref> coded entirely in
XS without going through an extra function:</para><programlisting
format="linespecific"
>int
print_hello_retval ()
 CODE:
    RETVAL = printf("hello, world\n");
 OUTPUT:
    RETVAL

int
treble( x )
  int x
 CODE:
   RETVAL = 3*x;
 OUTPUT:
   RETVAL</programlisting><para
>Here the <function
moreinfo="none"
>CODE</function> keyword indicates that the
following lines will contain C code. The <varname
>RETVAL</varname>
variable is created automatically by the XSUB compiler and is used to
store the return value for the function; it is guaranteed to be the
same type as the declared return type of the XSUB (integer in both
these examples).  One complication is that the return value is not
automatically configured as a return value. <command
moreinfo="none"
>xsubpp</command>
needs to be told explicitly that <varname
>RETVAL</varname> should be
returned and this is done by using the <function
moreinfo="none"
>OUTPUT</function>
keyword.</para><sect2
><title
>Modifying input variables</title><para
>In some cases the input arguments are modified rather than or as well
as providing a return value. In that case XS needs to be told which
arguments are solely for input and which are output. The
<function
moreinfo="none"
>OUTPUT</function> keyword is used for this. Here we modify
the <function
moreinfo="none"
>treble</function> function so that the argument is
modified instead of providing the result as a return value:</para><programlisting
format="linespecific"
>void
treble_inplace( x )
  int x
 CODE:
  x *=3;
 OUTPUT:
  x </programlisting><para
>which is equivalent to this Perl subroutine:</para><programlisting
format="linespecific"
>sub treble_inplace {
  $_[0] *= 3;
  return;
}</programlisting><para
>or more pedantically:</para><programlisting
format="linespecific"
>sub treble_inplace {
  my $x = int($_[0]);
  $x *= 3;
  $_[0] = int($x);
  return;
}</programlisting><para
>and suffers from the same problem - the input argument must be a
variable and not a constant else it can not be modified. If a constant
is passed in (for example a straight number as in our previous
example) Perl will generate a <errorname
>Modification of a read-only
value attempted</errorname> runtime error. The
<function
moreinfo="none"
>OUTPUT</function> keyword forces the value of the variable
at the end of the XSUB to be copied back into the perl variable that
was passed in.</para></sect2><sect2
><title
>Output arguments</title><para
>In many C functions, some arguments are only returned
      (that is the value of the argument on entry is irrelevant and is
      set by the function itself). In these cases the XSUB must not
      only specify which arguments in the list are to be returned but
      which are to be ignored on input.</para><sidebar
><para
>To be pedantic, all arguments in C are
      passed in by value but some arguments are thought of as return
      values because they are passed in a pointer to some memory and
      that memory is modified by the function. The pointer itself is
      not affected. Here we will be using a non-pointer XS example as
      XS can be used to copy the results into the correct
      variable. More detailed examples explicitly involving pointers
      can be found in <xref
linkend="advxs"
></xref> </para></sidebar><para
>For example, if we wanted our <function
moreinfo="none"
>treble</function> function
      to return the result into a second argument:</para><programlisting
format="linespecific"
>&amp;treble(5, $out);</programlisting><para
>we would have to write XS code like this:</para><programlisting
format="linespecific"
>void
treble(in, out)
  int in
  int out = NO_INIT
 CODE:
  out = 3 * in;
 OUTPUT:
  out</programlisting><para
>Here, the NO_INIT flag tells the XS compiler that we don't
      care what the value of the second argument is when the function
      is called, only that the result is stored in it when we
      leave. This is functionally equivalent to the following perl
      code:</para><programlisting
format="linespecific"
>sub treble {
  $_[1] = 3 * $_[0];
  return;
}</programlisting><para
>Of course, this approach preserves a C-style calling signature and
forces that onto Perl. In some cases this is desirable, maybe for
familiarity with existing library interfaces, but in other cases not
so. This brings us to the question of interface design and that topic
is addressed in <xref
linkend="xsi.design"
></xref></para></sect2><sect2
id="xsi.autoload"
><title
>Compiler Constants</title><para
>Providing access to functions is only part of the problem when
interfacing to external libraries. Many libraries define constants
(usually in the form of preprocessor <function
moreinfo="none"
>define</function>s)
that are useful to Perl programmers as well as C
programmers. <command
moreinfo="none"
>h2xs</command> automatically provides the code
necessary to import preprocessor constants unless it is invoked with
the <option
>-c</option> or <option
>-A</option> options. The approach
taken by <command
moreinfo="none"
>h2xs</command> is to use the
<classname
>AutoLoader</classname> module to determine the value of
constants on demand at runtime rather than importing every constant
when the program starts.</para><sidebar
><para
>An extreme example is the standard
<classname
>POSIX</classname> module. This defines over 350 compiler
constants and creating this many subroutines during loading would
impose a large overhead.</para></sidebar><para
>The autoloading is implemented in two parts. Firstly an
<function
moreinfo="none"
>AUTOLOAD</function> is added to the <filename
moreinfo="none"
>.pm</filename>
file. For versions of Perl before 5.8.0 the code will look something like this:</para><programlistingco
><areaspec
><area
coords="2"
id="xsi.al.useerr"
></area><area
coords="3"
id="xsi.al.useal"
></area><area
coords="4"
id="xsi.al.usecarp"
></area><area
coords="6"
id="xsi.al.start"
></area><area
coords="7"
id="xsi.al.sub"
></area><area
coords="8"
id="xsi.al.const"
></area><area
coords="9"
id="xsi.al.val"
></area><area
coords="10"
id="xsi.al.errno"
></area><areaset
coords=""
id="xsi.al.none"
><area
coords="11"
id="xsi.al.none.al1"
></area><area
coords="12"
id="xsi.al.none.al2"
></area><area
coords="13"
id="xsi.al.none.al3"
></area></areaset><area
coords="15"
id="xsi.al.croak"
></area><areaset
coords=""
id="xsi.al.eval"
><area
coords="19"
id="xsi.al.strict"
></area><area
coords="20"
id="xsi.al.glob"
></area></areaset><area
coords="22"
id="xsi.al.goto"
></area></areaspec><programlisting
format="linespecific"
>use strict;
use Errno;
use AutoLoader;
use Carp;

sub AUTOLOAD {
    my $sub = $AUTOLOAD;
    (my $constname = $sub) =~ s/.*:://;
    my $val = constant($constname);
    if ($! != 0) {
        if ($! =~ /Invalid/ || $!{EINVAL}) {
            $AutoLoader::AUTOLOAD = $sub;
            goto &amp;AutoLoader::AUTOLOAD;
        } else {
            croak "Your vendor has not defined constant $constname";
        }
    }
    {
        no strict 'refs';
        *$sub = sub () { $val };
    }
    goto &amp;$sub;
}</programlisting><calloutlist
><callout
arearefs="xsi.al.useerr"
><para
>We use this module so that we can check for explicit values of the <varname
>errno</varname> variable.</para></callout><callout
arearefs="xsi.al.useal"
><para
>Load the <classname
>AutoLoader</classname>
	    module. This is only required if you want to dynamically
	    load additional functions from disk.</para></callout><callout
arearefs="xsi.al.usecarp"
><para
>Load the <classname
>Carp</classname> module. This
imports the <function
moreinfo="none"
>croak</function> function.</para></callout><callout
arearefs="xsi.al.start"
><para
>The subroutine must be called
	    <function
moreinfo="none"
>AUTOLOAD</function> so that Perl will call it
	    automatically when it can not find a definition for the
	    subroutine in this package.</para></callout><callout
arearefs="xsi.al.sub"
><para
>The <varname
>$AUTOLOAD</varname> package variable contains the
name of the subroutine that is being requested. Here we copy that
value to a lexical for convenience.</para></callout><callout
arearefs="xsi.al.const"
><para
>This strips the package name (and associated colons)
	    from the requested function name, leaving just the name of
	    the function in the current namespace.</para></callout><callout
arearefs="xsi.al.val"
><para
>This runs the <function
moreinfo="none"
>constant</function> function that
returns the value of the required constant. This routine is an XS
function that is created by the <command
moreinfo="none"
>h2xs</command> command; more
on that later. The code generated by <command
moreinfo="none"
>h2xs</command> passes a
second argument to this routine (<varname
>$_[0]</varname>) but for
simple constants it can usually be removed from the routine.</para></callout><callout
arearefs="xsi.al.errno"
><para
>This checks the error status from the <function
moreinfo="none"
>constant</function>. In
C a common way of setting status is for the function to set a global
variable <varname
>errno</varname> and for the caller of the function
to check <varname
>errno</varname> when control is returned to it. In
Perl this behaviour is implemented by the <varname
>$!</varname>
variable. <varname
>$!</varname> is tied to the C
<varname
>errno</varname> variable so that Perl can check the value
after system calls. Here the <function
moreinfo="none"
>constant</function> sets
<varname
>errno</varname> if the requested constant can not be
located.</para></callout><callout
arearefs="xsi.al.none"
><para
>These lines check to see if <varname
>errno</varname> has returned with
	    errors that indicate that the constant does not exist at
all. In that case it passes control to
<classname
>AutoLoader</classname> in case some functions are to be
autoloaded from <filename
moreinfo="none"
>.al</filename> files. These checks are only
required if auto-loaded routines are expected, else this is simply an
extra overhead for the program.</para></callout><callout
arearefs="xsi.al.croak"
><para
>If the constant should be available but was not defined this line
	    stops the program. <function
moreinfo="none"
>croak</function> is used
rather than <function
moreinfo="none"
>die</function> so that the line number in the
callers code is printed in the error message rather than the line
number in the <function
moreinfo="none"
>AUTOLOAD</function> subroutine.</para></callout><callout
arearefs="xsi.al.eval"
><para
>At this point in the routine the value of the constant has been
determined and, in principle, that value could be retuned to the
caller. Whilst it is valid to do that in practice the constant will
probably be called more than once. If the value is returned
immediately, then the <function
moreinfo="none"
>AUTOLOAD</function> subroutine will be
called every single time the constant is requested; very
inefficient. To overcome this inefficiency the
<function
moreinfo="none"
>AUTUOLOAD</function> subroutine creates a new subroutine in
this package that simply returns the constant value. In the example
this is done by creating an anonymous subroutine and storing it in a
glob (see <xref
linkend="perlvar.gv"
></xref> for more explicit details of how this
can work). The name of the glob is stored in <varname
>$sub</varname>
and therefore requires that soft references are allowed. The
<userinput
moreinfo="none"
>no strict 'refs'</userinput> turns off strict checking to
allow this. If you are uncomfortable with glob assignments the same
effect can be achieved simply by using a string
<function
moreinfo="none"
>eval</function>: <userinput
moreinfo="none"
>eval "sub $sub () { $val }";</userinput>.</para></callout><callout
arearefs="xsi.al.goto"
><para
>Finally, Perl is instructed to jump to the newly created
subroutine and resume execution there. Using <function
moreinfo="none"
>goto</function>
allows the program to run as if <function
moreinfo="none"
>AUTOLOAD</function> was
never called.</para></callout></calloutlist></programlistingco><para
>The second part of the solution generated by <command
moreinfo="none"
>h2xs</command>
lies in the <function
moreinfo="none"
>constant</function> function in the
<filename
moreinfo="none"
>.xs</filename> file. Here is a simple yet functional form of the
code generated by <command
moreinfo="none"
>h2xs</command> for some of the file
constants that are available from the <classname
>Fcntl</classname> module:</para><programlistingco
><areaspec
><area
coords="1"
id="xsi.co.ret"
></area><area
coords="4"
id="xsi.co.errno"
></area><area
coords="5"
id="xsi.co.sw"
></area><area
coords="6"
id="xsi.co.case"
></area><area
coords="7"
id="xsi.co.streq"
></area><areaset
coords=""
id="xsi.co.ifdef"
><area
coords="8"
id="xsi.co.if"
></area><area
coords="9"
id="xsi.co.retdef"
></area><area
coords="11"
id="xsi.co.goto"
></area></areaset><area
coords="26"
id="xsi.co.brk"
></area><area
coords="28"
id="xsi.co.errno1"
></area><area
coords="31"
id="xsi.co.notthere"
></area><area
coords="36"
id="xsi.co.mod"
></area><area
coords="38"
id="xsi.co.xsiv"
></area></areaspec><programlisting
format="linespecific"
>static IV
constant(char *name)
{
  errno = 0;
  switch (*name) {
  case 'S':
     if (strEQ(name, "S_ISGID"))
#ifdef S_ISGID
         return S_ISGID;
#else
	  goto not_there;
#endif
  case 'O':
     if (strEQ(name, "O_RDONLY"))
#ifdef O_RDONLY
	 return O_RDONLY;
#else
	 goto not_there;
#endif
     if (strEQ(name, "O_RDWR"))
#ifdef O_RDWR
	 return O_RDWR;
#else
	 goto not_there;
#endif
    break;
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

MODULE = Fcntl_demo PACKAGE = Fcntl_demo

IV
constant(name)
   char * name

        </programlisting><calloutlist
><callout
arearefs="xsi.co.ret"
><para
>The return type of the function. In this case the return type is
forced to be the perl integer type (see <xref
linkend="cintro.typedef"
></xref>)</para></callout><callout
arearefs="xsi.co.errno"
><para
>Sets <varname
>errno</varname> to zero (no error) so that its
value can be checked on exit from the function.</para></callout><callout
arearefs="xsi.co.sw"
><para
>This denotes the start of a block that will switch on the first
character of the requested constant name.</para></callout><callout
arearefs="xsi.co.case"
><para
>This block is executed if the constant name starts with a
&quot;S&quot;.</para></callout><callout
arearefs="xsi.co.streq"
><para
>Compare the requested name with the string
&quot;<literal
moreinfo="none"
>S_ISGID</literal>&quot;</para></callout><callout
arearefs="xsi.co.ifdef"
><para
>This is the block that does all the work. The C-preprocessor is
used to determine the code that is passed to the compiler. If the
symbol is defined its value is returned, if it is not defined the code
branches to the <function
moreinfo="none"
>not_there</function> label.</para></callout><callout
arearefs="xsi.co.brk"
><para
>If the constant can not be found even though it started with the
correct letter the switch is exited since there is no chance of it
matching the remaining tests.</para></callout><callout
arearefs="xsi.co.errno1"
><para
>If the constant name did not match anything in the switch block
<varname
>errno</varname> is set to <literal
moreinfo="none"
>EINVAL</literal>
(&quot;Invalid argument&quot;) and the function returns
<literal
moreinfo="none"
>0</literal>.</para></callout><callout
arearefs="xsi.co.notthere"
><para
>If the requested name was valid and present in the switch but
was not available (maybe because the constant was not defined on this
operating system) the function sets <varname
>errno</varname> to
<literal
moreinfo="none"
>ENOENT</literal> (literally &quot;No such file or
directory&quot;) and returns.</para></callout><callout
arearefs="xsi.co.mod"
><para
>This defines the start of the XS part of the file.</para></callout><callout
arearefs="xsi.co.xsiv"
><para
>The XSUB definition for <function
moreinfo="none"
>constant</function> is very
simple with a single string argument and a return type of
<type
>IV</type>.</para></callout></calloutlist></programlistingco><para
>It is important to realise that this example only deals with numeric
constants (in the above example the constants are assumed to be just
integers). String constants must be handled differently - especially if
a mixture of numeric and string constants are required.</para><sect3
><title
>ExtUtils::Constant</title><para
>From perl 5.8.0 a new module has been added,
<classname
>ExtUtils::Constant</classname>, that simplifies the
handling of constants. With this module the XS and C code required to
deal with the compiler constants is generated automatically when
<filename
moreinfo="none"
>Makefile.PL</filename> is executed. This has a number of
advantages over the current scheme:</para><itemizedlist
><listitem
><para
>Improvements in the constant handling code can be
	    made without having to touch every single module that
	    uses constants.</para></listitem><listitem
><para
>The XS files are now much simpler. No longer are the
	    files dominated by long repetitive lists of constants and
	    C pre-processor directives.</para></listitem><listitem
><para
>The new system allows compiler constants to have
	    different types. An integer constant is treated
	    differently to a floating point constant.</para></listitem></itemizedlist></sect3></sect2></sect1><sect1
><title
>What about that <filename
moreinfo="none"
>Makefile.PL</filename>?</title><para
>So far we have not really addressed the contents of the file that is
instrumental in configuring the build process. When building simple
perl modules the <filename
moreinfo="none"
>Makefile.PL</filename> is almost empty
providing just the name of the module and a means for determining the
location to install the module (see <xref
linkend="xsi.moddist"
></xref>).  The
<filename
moreinfo="none"
>Makefile.PL</filename> program is much more important when
building XS extensions since the makefile that is generated must
include information on how to translate the XS code to C, how to run
the C compiler and how to generate shared libraries. In all the
examples presented so far this has been handled automatically by the
<function
moreinfo="none"
>WriteMakefile</function> function since it
detects the presence of an XS file and sets up the appropriate
makefile targets. However, this only works if the module can be built
without additional configurations above and beyond that used to build
perl originally. So far the examples have not required
anything more than standard include files and libraries. What would
happen if we were building a wrapper around a library that was not
included by default? Add the following code to the XS example to find out.
It should print out the version of the XPM library on your system.
The include directive should go after the Perl includes and the XS
declaration in the XS section.</para><programlisting
format="linespecific"
>#include &lt;X11/xpm.h&gt;

...

int
XpmLibraryVersion()</programlisting><para
>If the above XS code is added to our example file and built we get
this:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt><userinput
moreinfo="none"
> perl Makefile.PL</userinput>
Checking if your kit is complete...
Looks good
Writing Makefile for Example
<prompt
moreinfo="none"
>%</prompt><userinput
moreinfo="none"
> make</userinput>
mkdir blib
mkdir blib/lib
mkdir blib/arch
mkdir blib/arch/auto
mkdir blib/arch/auto/Example
mkdir blib/lib/auto
mkdir blib/lib/auto/Example
cp Example.pm blib/lib/Example.pm
/usr/bin/perl -I/usr/lib/perl5/5.6.0/i386-linux -I/usr/lib/perl5/5.6.0
    /usr/lib/perl5/5.6.0/ExtUtils/xsubpp  
    -typemap /usr/lib/perl5/5.6.0/ExtUtils/typemap Example.xs 
    &gt; Example.xsc &amp;&amp; mv Example.xsc Example.c
Please specify prototyping behavior for Example.xs (see perlxs manual)
gcc -c  -fno-strict-aliasing -O2 -march=i386 -mcpu=i686 -DVERSION=\"0.01\"
    -DXS_VERSION=\"0.01\" -fPIC -I/usr/lib/perl5/5.6.0/i386-linux/CORE  Example.c
Running Mkbootstrap for Example ()
chmod 644 Example.bs
LD_RUN_PATH="" gcc -o blib/arch/auto/Example/Example.so  -shared 
    -L/usr/local/lib Example.o     
chmod 755 blib/arch/auto/Example/Example.so
cp Example.bs blib/arch/auto/Example/Example.bs
chmod 644 blib/arch/auto/Example/Example.bs</screen><para
>It looks like everything worked fine. Let's try it out:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MExample -e 'Example::print_hello'</userinput>
Using ..../Example3/blib
hello, world

<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MExample -e 'print Example::XpmLibraryVersion'</userinput>
Using ..../Example3/blib
perl: error while loading shared libraries: 
    /home/timj/perl/perlbook/book/Example3/blib/arch/auto/Example/Example.so: 
    undefined symbol: XpmLibraryVersion</screen><para
>The above output indicates that the earlier routines
(e.g. <function
moreinfo="none"
>print_hello</function>) still work but the new routine
doesn't. The error message indicates that Perl could not find
<function
moreinfo="none"
>XpmLibraryVersion</function> in any of the libraries that it
has already loaded. This is not surprising since Perl is not linked
against graphics libraries during a standard build. To overcome this
problem we can use the <filename
moreinfo="none"
>Makefile.PL</filename> to provide the
information necessary to locate the correct libraries. The
<filename
moreinfo="none"
>Makefile.PL</filename> generated by <command
moreinfo="none"
>h2xs</command>
looks something like this:</para><programlisting
format="linespecific"
>use ExtUtils::MakeMaker;
# See lib/ExtUtils/MakeMaker.pm for details of how to influence
# the contents of the Makefile that is written.
WriteMakefile(
    'NAME'         =&gt; 'Example',
    'VERSION_FROM' =&gt; 'Example.pm', # finds $VERSION
    'PREREQ_PM'	   =&gt; {}, # e.g., Module::Name =&gt; 1.1
    'LIBS'         =&gt; [' '], # e.g., '-lm'
    'DEFINE'       =&gt; ' ', # e.g., '-DHAVE_SOMETHING'
    'INC'          =&gt; ' ', # e.g., '-I/usr/include/other'
);</programlisting><para
>The hash provided to <function
moreinfo="none"
>WriteMakefile</function> can contain
many different keys but the ones that are usually modified for simple
XS projects are LIBS and INC. The LIBS key can be used to specify
additional libraries that are needed to build the module. The string
must be in the form expected by the linker on your system. Usually
this means a format of <userinput
moreinfo="none"
>-L/dir/path -lmylib</userinput>
where <userinput
moreinfo="none"
>-L</userinput> indicates additional search
directories and <userinput
moreinfo="none"
>-l</userinput> indicates the name of actual
libraries.  <footnote
><para
>On Unix systems
<userinput
moreinfo="none"
>-lmylib</userinput> refers to a file on disk called
<filename
moreinfo="none"
>libmylib.a</filename> or
<filename
moreinfo="none"
>libmylib.so</filename>. The former is a static library, the
latter is a shared library that is loaded at
runtime.</para></footnote> <function
moreinfo="none"
>WriteMakefile</function> expects
the LIBS argument to be either a simple scalar or a reference to an
array. In most cases a scalar is all that is required but the array
allows multiple sets of library combinations to be provided and
<classname
>MakeMaker</classname> will use the first that refers to a
library that can be found on disk.  In order to fix our example we
have to change the LIBS entry so that the <filename
moreinfo="none"
>Xpm</filename>
library will be included:</para><programlisting
format="linespecific"
>'LIBS'	=&gt; '-L/usr/X11R6/lib -lX11 -lXpm', # all X11 programs require -lX11</programlisting><para
>Rebuilding the module now gives:</para><screenco
><areaspec
><area
coords="10"
id="xsi.mpl.libs"
></area></areaspec><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl Makefile.PL</userinput>
Writing Makefile for Example
<prompt
moreinfo="none"
>%</prompt> make
gcc -c  -fno-strict-aliasing -O2 -march=i386 -mcpu=i686 -DVERSION=\"0.01\" 
    -DXS_VERSION=\"0.01\" -fPIC -I/usr/lib/perl5/5.6.0/i386-linux/CORE
    Example.c
Running Mkbootstrap for Example ()
chmod 644 Example.bs
LD_RUN_PATH="/usr/X11R6/lib" gcc -o blib/arch/auto/Example/Example.so
    -shared -L/usr/local/lib Example.o    -L/usr/X11R6/lib -lX11 -lXpm 
chmod 755 blib/arch/auto/Example/Example.so
cp Example.bs blib/arch/auto/Example/Example.bs
chmod 644 blib/arch/auto/Example/Example.bs
</screen><calloutlist
><callout
arearefs="xsi.mpl.libs"
><para
>The value specifed for LIBS appears on this line</para></callout></calloutlist></screenco><para
>and the test runs as expected:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MExample -e 'print Example::XpmLibraryVersion'</userinput>
Using ..../Example3/blib
30411</screen><para
>Similarly, extra include paths (reference to chapter 1?) can be added using the
<varname
>INC</varname> key. This value is always a scalar and contains
a list of directories to search for include files in the format
expected by your compiler. This is usually of the form
<userinput
moreinfo="none"
>-I/some/dir</userinput>.</para><sect2
><title
>It really is a Perl program</title><para
>It is really important to remember that the
<filename
moreinfo="none"
>Makefile.PL</filename> really is a normal Perl program. All
that matters is that <function
moreinfo="none"
>WriteMakefile</function> is called with
the correct arguments to generate the <filename
moreinfo="none"
>makefile</filename>.
You can write arbritrarily complex code to generate those arguments,
you can prompt the user for information (e.g. the
<filename
moreinfo="none"
>libnet</filename> package), you can even dynamically
generate the perl module itself!</para><para
>As an example let's suppose we wanted to build an interface to a Gnome library
<footnote
><para
>Modules for many Gnome libraries are already on
CPAN</para></footnote>. Most Gnome libraries come with configuration
scripts that can be used to determine the required libraries and
include directories and these must be used inside the
<filename
moreinfo="none"
>Makefile.PL</filename> rather than hard-wiring the location
of the Gnome system into the program.<footnote
><para
>Gnome is usually
installed into <filename
moreinfo="none"
>/usr</filename> on Linux but
<filename
moreinfo="none"
>/opt/gnome</filename> on Solaris</para></footnote>
To support this, the <filename
moreinfo="none"
>Makefile.PL</filename> may look
something like this:</para><programlisting
format="linespecific"
>use ExtUtils::MakeMaker;

# Use gnome-config to determine libs
my $libs = qx/ gnome-config --libs gnome /;

# Use gnome-config to determine include path
my $incs = qx/ gnome-config --cflags gnome /;

# Remove new lines
chomp($libs);
chomp($incs);

# Might want to exit with an error if the $libs or $incs 
# variables are empty

# See lib/ExtUtils/MakeMaker.pm for details of how to influence
# the contents of the Makefile that is written.
WriteMakefile(
    'NAME'         =&gt; 'Gnome',
    'VERSION_FROM' =&gt; 'Gnome.pm', # finds $VERSION
    'PREREQ_PM'	   =&gt; {}, # e.g., Module::Name =&gt; 1.1
    'LIBS'         =&gt; $libs, # all X11 programs require -lX11
    'DEFINE'       =&gt; ' ', # e.g., '-DHAVE_SOMETHING'
    'INC'          =&gt; $incs, # e.g., '-I/usr/include/other'
);</programlisting></sect2></sect1><sect1
id="xsi.design"
><title
>Interface Design - Part 1</title><para
>Now that we have seen how to create Perl interfaces to simple C
functions and library routines this section will provide some advice
on how these C routines should behave in a Perl world. </para><itemizedlist
><listitem
><para
>When interfacing Perl to another language it is important to take a
step back and design the Perl interface so that a Perl programmer
would be comfortable with it rather than a C programmer.</para></listitem><listitem
><para
>In C although all arguments are passed by value, arguments can act as
input arguments, return arguments or both and there is no way to
distinguish this behaviour from the prototype (knowing you are using a
pointer can not tell you whether the data will change). In Perl, input
arguments are supplied and return arguments are returned.  A C
function such as:</para><funcsynopsis
><funcprototype
><funcdef
>int <function
moreinfo="none"
>compute</function></funcdef><paramdef
>int <parameter
moreinfo="none"
>factor</parameter></paramdef><paramdef
>double *<parameter
moreinfo="none"
>result</parameter></paramdef></funcprototype></funcsynopsis><para
>that may take take an input integer, store a value into a double (the
asterisk indicates a pointer in C, we will talk about those in the
next chapter) and return an integer status is
almost always better written in perl as:</para><programlisting
format="linespecific"
>($status, $result) = compute( $factor ); </programlisting><para
>rather than:</para><programlisting
format="linespecific"
>$status = compute( $factor, $result );</programlisting><para
>In versions of <command
moreinfo="none"
>xsubpp</command> prior to v1.9508 the only way
to do this is to manipulate the argument stack by hand (described in
<xref
linkend="advxs"
></xref>). In newer versions of
<command
moreinfo="none"
>xsubpp</command> it is possible to indicate that some
arguments are to be returned differently using modifiers when
declaring the function signature. </para><programlisting
format="linespecific"
>REQUIRE: 1.9508            <co
id="xsi.eg.outlist.req"
></co>

int
compute( factor, OUTLIST result )
  int factor
  double result</programlisting><calloutlist
><callout
arearefs="xsi.eg.outlist.req"
><para
>Make sure that we are using a version of <command
moreinfo="none"
>xsubpp</command>
that is new enough.</para></callout></calloutlist><para
>The <function
moreinfo="none"
>OUTLIST</function> keyword indicates that the argument
is a return value that should be placed on the output list. In fact,
if the status is only telling us whether something worked or failed we
may want to consider removing it completely:</para><programlisting
format="linespecific"
>$result = compute( $factor );</programlisting><para
>Returning <literal
moreinfo="none"
>undef</literal> if an error
	occurs. We'll see how to do this in <xref
linkend="advxs.design"
></xref>.</para></listitem><listitem
><para
>Do not ask the Perl programmer to provide information that Perl
already knows. For example, the C function might need to know the size
of a buffer being passed in. Since Perl already knows the length it is
redundant and error-prone to ask the programmer to provide that
information explicitly.</para></listitem><listitem
><para
>When interfacing to a library do not blindly import every single
function into Perl. It is possible that many of the functions are
support functions needed by the C interface but irrelevant to
Perl. Additionally many of the constants may not be needed.</para></listitem><listitem
><para
>Make use of Perl namespaces. Many C libraries use the library name as
a prefix to every function (for example, many functions in the <ulink
url="http://www.gnome.org"
>Gnome</ulink> library start with
<function
moreinfo="none"
>gnome_</function>) so use the package name to indicate that
information and strip the common prefix. The
<function
moreinfo="none"
>PREFIX</function> keyword can be used for this:</para><remark
>Maybe choose a non-pointer example here and save
	pointers for later?</remark><programlisting
format="linespecific"
>MODULE = GNOME  PACKAGE = GNOME  PREFIX = gnome_

char *
gnome_util_user_shell()</programlisting><para
>The above XS segment indicates that the function should appear to Perl
as <userinput
moreinfo="none"
>GNOME::util_user_shell</userinput> rather than the more
verbose and repetitive
<userinput
moreinfo="none"
>GNOME::gnome_util_user_shell</userinput>.</para></listitem><listitem
><para
>If a library provides a single and double precision interface consider
using just the double precision interface unless there is a major
performance penalty between the two. This is because all Perl floating
point variables are already double precision and there is little point
converting precision when transferring data between Perl and the
library. If it is necessary to preserve the function names inside Perl
(but as noted in a previous comment it may be better to adopt
a more unified interface on the Perl side) 
it is possible to export both the single and double precisions names 
but only use the double precision function from the library. XS
provides a way of doing this using the ALIAS keyword. For example:</para><programlisting
format="linespecific"
>double
CalcDouble( arg )
   double arg
 ALIAS:
    CalcFloat = 1
 CODE:
    printf("# ix = %d\n", ix );
    RETVAL = CalcDouble( arg );
 OUTPUT:
   RETVAL</programlisting><para
>Here <function
moreinfo="none"
>CalcFloat</function> is setup as an alias
	for <function
moreinfo="none"
>CalcDouble</function>. The <varname
>ix</varname>
	variable is provided automatically and can be used to
	determine how the function was called. In the above example,
	if this function is called as <function
moreinfo="none"
>CalcDouble</function>
	<varname
>ix</varname> will have a value of
	<literal
moreinfo="none"
>0</literal> whereas ff the function is called as
	<function
moreinfo="none"
>CalcFloat</function> <varname
>ix</varname> will have
	a value of <literal
moreinfo="none"
>1</literal>.</para></listitem></itemizedlist></sect1><sect1
><title
>Further Reading</title><para
>More information on Perl modules and XS can be 
found at the following locations:</para><variablelist
><varlistentry
><term
>perlmod</term><term
>perlmodlib</term><listitem
><para
>Standard Perl manual pages on module creation.</para></listitem></varlistentry><varlistentry
><term
>ExtUtils::MakeMaker</term><listitem
><para
>Description of <filename
moreinfo="none"
>Makefile.PL</filename> options.</para></listitem></varlistentry><varlistentry
><term
>perlxstut</term><term
>perlxs</term><listitem
><para
>These are the standard XS tutorial and documentation
	  that come with Perl itself. They cover everything about perl
	  and XS but they rapidly move onto advanced topics.</para></listitem></varlistentry></variablelist></sect1></chapter><chapter
id="cadv"
><title
>Advanced C</title><para
>So far we have provided a simple introduction to the C
  programming language and used that knowledge to provide perl
  interfaces to simple C functions. Before we can progress on to a
  description of the perl internals, and the implementation of perl
  variables in particular, we need to introduce some more advanced C
  programming concepts. In this chapter we will show how to use arrays
  and data structures and how to deal with memory management.</para><sect1
id="cadv.arrays"
><title
>Arrays</title><para
>In Perl arrays are simply collections of scalars. Perl knows
    how many elements are in the array and allocates memory for new
    elements as required. In C, arrays are simply a contiguous block
    of memory that can only store variables of a specific type; an
    array of integers can only contain integers.  <xref
linkend="cadv.arr.eg"
></xref> shows how you can create and access arrays
    of a known size in C along with the Perl equivalent. The use of
    square brackets is identical to the usage in Perl.</para><remark
>It has been suggested that this example is too contrived</remark><example
id="cadv.arr.eg"
><title
>Array handling in C</title><programlistingco
><areaspec
><areaset
coords=""
id="cadv.arr.eg.inc"
><area
coords="1"
id="cadv.arr.eg.inc.a"
></area><area
coords="2"
id="cadv.arr.eg.inc.b"
></area></areaset><area
coords="6"
id="cadv.arr.eg.iarr"
></area><area
coords="7"
id="cadv.arr.eg.darr"
></area><area
coords="10"
id="cadv.arr.eg.popd"
></area><area
coords="14"
id="cadv.arr.eg.printf"
></area></areaspec><programlisting
format="linespecific"
>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main () {
  int i;
  int iarr[5] = { 10,20,30,40,50 };
  double darr[10];
  
  for (i=0; i&lt;10; i++) {
    darr[i] = i/100.0;
  } 

  for (i=0; i&lt;5; i++) {
    printf("%d %d %f\n", i, iarr[i], darr[i]);
  }

  exit(0);
}

#!/usr/bin/perl

@iarr = ( 10, 20, 30, 40, 50 );

for (0..9) {
  $darr[$_] = $_/100.0;
}

for (0..4) {
  printf("%d %d %f\n", $_, $iarr[$_], $darr[$_]);
}</programlisting><calloutlist
><callout
arearefs="cadv.arr.eg.inc"
><para
>Standard include files. These provide prototypes for
<function
moreinfo="none"
>printf</function> and <function
moreinfo="none"
>exit</function>.</para></callout><callout
arearefs="cadv.arr.eg.iarr"
><para
> Declare an integer array with 5 elements and then
	    assign the elements using a comma-separated list. (Note
	    the use of <userinput
moreinfo="none"
>{ x, y, z }</userinput> for Perl's
	    <userinput
moreinfo="none"
>(x, y, z)</userinput>.)</para></callout><callout
arearefs="cadv.arr.eg.darr"
><para
>Create an array containing 10 double precision
	    numbers. This array is created empty.</para></callout><callout
arearefs="cadv.arr.eg.popd"
><para
>Assign values to each of the elements in the double
	    precision array.</para></callout><callout
arearefs="cadv.arr.eg.printf"
><para
>Print the contents of the first 5 elements of
	    <varname
>iarr</varname> and
	    <varname
>darr</varname>.</para></callout></calloutlist></programlistingco></example><para
> One complication for a C programmer is that you must keep
    track of the number of elements in the array and must allocate
    a larger chunk of  memory if more elements are required (see <xref
linkend="cadv.mem.chg"
></xref>). This is because the C compiler only
    allocates the memory that it knows you will need and not the
    memory you might need. To make things worse, C will not stop you
    <quote
>walking off the end</quote> of the array, by assigning to
    an element that you have not allocated memory for. For instance,
    this is perfectly legal (for some definitions of legal...):</para><programlisting
format="linespecific"
>int array[10];

array[20] = 1234;
      </programlisting><para
>However, it will almost certainly cause annoying and
    occasionally difficult to detect problems, as you will be writing
    either into unallocated memory, possibly causing a segmentation
    fault, or, worse, into another variable's allocated
    storage.</para></sect1><sect1
id="cadv.pointers"
><title
>Pointers</title><para
> In the same way as in Perl all arguments in C are passed
    into subroutines by value so if you have a C function such
    as:</para><funcsynopsis
><funcprototype
><funcdef
>int <function
moreinfo="none"
>findsum</function></funcdef><paramdef
>int <parameter
moreinfo="none"
>in1</parameter></paramdef><paramdef
>int <parameter
moreinfo="none"
>in2</parameter></paramdef></funcprototype></funcsynopsis><para
>the subroutine will simply retrieve the values of
    <varname
>in1</varname> and <varname
>in2</varname> but will not be
    able to modify those variables directly. This is analogous to the
    Perl subroutine:</para><programlisting
format="linespecific"
>sub findsum {
  my $in1 = shift;
  my $in2 = shift;
  return ($in1 + $in2);
}</programlisting><para
>where the arguments are read from the stack and then used in
    the subroutine. In C there is no analogue of the variable aliasing
    trick available in perl (where <varname
>@_</varname> can be
    modified in place) and in order to modify a variable the memory
    address of the variable must be passed to the function. Once the
    memory address is available it can be used to modify the value
    <emphasis
>pointed</emphasis> to by this address. Given this
    definition it is not surprising to find that a variable that
    contains a memory address is called a
    <firstterm
>pointer</firstterm>.</para><para
>Pointers are associated with a particular variable type
    (much like a reference to a Perl hash is different from a
    reference to a Perl scalar) although, unlike in Perl, they can be
    converted to other types by using type-casting. This all means
    that a pointer to an integer is not the same as a pointer to a
    character <emphasis
>although you can force it to be treated as
    such</emphasis>.  In order to dereference a C pointer and modify
    the value of the variable the <userinput
moreinfo="none"
>*</userinput> notation is
    used and this is reflected in the declaration of a pointer:</para><programlisting
format="linespecific"
>char *str;
int  *x;
double *y;</programlisting><para
>This notation indicates that since, for example,
    <varname
>*x</varname> is an integer then <varname
>x</varname>
    itself must therefore be a pointer to an integer. An alternative
    reading is to think of <varname
>x</varname> as a variable of type
    <type
>int *</type> which is a pointer to an integer. A function
    that multiplies a variable by three could be implemented as:</para><programlisting
format="linespecific"
>void treble ( int * value ) {
    *value *= 3;
}</programlisting><para
>Here the input variable is declared as a pointer and the
    value in the variable is multiplied by three by dereferencing the
    pointer. This could be called as follows:</para><programlisting
format="linespecific"
>int number = 5;
treble( &amp;number );</programlisting><para
>where we use an ampersand to indicate that we want to take
    the memory address of <varname
>number</varname> and pass it to the
    function rather than simply passing in the value. The Perl
    equivalents would be:</para><programlisting
format="linespecific"
>$number = 5;
&amp;treble( \$number );

sub treble {
  my $value = shift;
  $$value *= 3;
}</programlisting><para
>To summarise, <varname
>&amp;variable</varname> is used to
    retrieve the memory address and <varname
>*variable</varname> is
    used to find the thing pointed to by the memory address stored in
    the variable.</para><para
>There are some important differences between Perl references
    and C pointers.  In Perl the reference can only be dereferenced
    and once dereferenced behaves as the original Perl data
    type. Generally, in C the memory address can be examined and
    modified. Modifying pointers can lead to errors though since bad
    things can happen if the pointer does not point to a valid
    location in memory. Additionally, a C pointer simply contains a
    memory address therefore from that pointer it is not possible to
    determine whether it points to an array of variables or a single
    variable.</para><para
>A special type of pointer is a pointer to a void
    (<varname
>void *</varname>).  This simply indicates to the
    compiler that the contents are a pointer but we do not care what
    type of pointer it contains. This is very useful when designing
    data structures that are designed to be extensible or contain data
    of type that is not known until the program is run.</para><sect2
id="cadv.pointers.arrays"
><title
>Pointers and Arrays</title><para
>In Perl if you need to pass an array into a subroutine you
      usually do it by taking a reference to the array and storing it
      in a Perl scalar variable. Once the reference is stored in a
      scalar it must be dereferenced in order to retrieve the original
      variable:</para><programlisting
format="linespecific"
>&amp;foo( \@bar, \%baz );

sub foo {
  my ($refArr, $refHash) = @_;
  $refArr-&gt;[3] = "foo";
  $refHash-&gt;{"bar"} = "foo";
}</programlisting><para
>In C the equivalent of this reference is a pointer. When
      an array is used in a context expecting a pointer, the pointer
      to the first element is used automatically. This can be seen in
      <xref
linkend="cadv.pntr.arrequiv"
></xref> where an array is declared
      normally but is passed to another function as a pointer and also
      treated as a pointer by <function
moreinfo="none"
>printf</function>.</para><example
id="cadv.pntr.arrequiv"
><title
>Equivalence of arrays and pointers</title><programlistingco
><areaspec
><area
coords="4"
id="cadv.pntr.arreq.fooarr"
></area><area
coords="8"
id="cadv.pntr.arreq.foopntr"
></area><area
coords="13"
id="cadv.pntr.arreq.decl"
></area><areaset
coords="0"
id="cadv.pntr.arreq.call"
><area
coords="15"
id="cadv.pntr.arreq.callfooarr"
></area><area
coords="16"
id="cadv.pntr.arreq.callfoopntr"
></area></areaset><area
coords="18"
id="cadv.pntr.arreq.prntfooarr"
></area><area
coords="19"
id="cadv.pntr.arreq.prntfoopntr"
></area></areaspec><programlisting
format="linespecific"
>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void foo_as_array ( int array[] ) {
  array[0] = 1;
}

void foo_as_pntr ( int * array ) {
  array[1] = 2;
}

int main () {
  int array[5];

  foo_as_array( array );
  foo_as_pntr( array );

  printf("First  element is %d\n", array[0]);
  printf("Second element is %d\n", *(array+1) );
  
  return EXIT_SUCCESS;
}</programlisting><calloutlist
><callout
arearefs="cadv.pntr.arreq.fooarr"
><para
>This function has a single argument that is
	      declared explicitly as an integer array. The empty
	      square brackets indicate that the size of the array is
	      not known.</para></callout><callout
arearefs="cadv.pntr.arreq.foopntr"
><para
>This function has a single argument that is
	      declared simply as a pointer to an integer. Note that
	      this does not distinguish between a pointer to a single
	      integer or a pointer from an actual array (and the
	      compiler doesn't care either).</para></callout><callout
arearefs="cadv.pntr.arreq.decl"
><para
>Declare an integer array with 5 elements but do
	      not populate it.</para></callout><callout
arearefs="cadv.pntr.arreq.call"
><para
>Both routines are called with the same syntax
	      regardless of whether the function is expecting a
	      pointer or an array.</para></callout><callout
arearefs="cadv.pntr.arreq.prntfooarr"
><para
>Print the value of the first array element
	      using standard array syntax.</para></callout><callout
arearefs="cadv.pntr.arreq.prntfoopntr"
><para
>Print the value of the second element. Here we use
	      pointer syntax to retrieve the second value. In fact,
	      the method we used first to retrieve element
	      <userinput
moreinfo="none"
>n</userinput> from an array,
	      <userinput
moreinfo="none"
>array[n]</userinput>, is functionally
	      equivalent to incrementing the pointer to the start of
	      the array by <userinput
moreinfo="none"
>n</userinput> and dereferencing
	      the result: <userinput
moreinfo="none"
>*(array+n)</userinput>. This
	      works because the compiler knows how many bytes to
	      increment the pointer because it knows the size of each
	      type.</para></callout></calloutlist></programlistingco></example><para
>A key difference between a real C array and a pointer to
      it is that the C compiler knows exactly how large an array is
      but does not know the amount of memory that a pointer refers
      to. This can be demonstrated in the following:</para><programlisting
format="linespecific"
>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main () {
  int array[5];
  int *pntr;

  printf("Size of array: %d bytes\n",sizeof(array));
  printf("Size of array: %d elements\n",sizeof(array)/sizeof(int));
  
  pntr = array;
  printf("Size of pointer: %d bytes\n", sizeof(pntr));

  return EXIT_SUCCESS;
}</programlisting><para
>which gives the following output:</para><screen
format="linespecific"
>Size of array: 20 bytes
Size of array: 5 elements
Size of pointer: 4 bytes</screen><para
>In general though, this ability to determine the size of
      an array using <function
moreinfo="none"
>sizeof</function> is not that useful
      since you only ever use arrays of unknown size when they have
      been created dynamically (in which case
      <function
moreinfo="none"
>sizeof</function> is irrelevant). <xref
linkend="cadv.mem"
></xref> contains more details on how to allocate
      memory for arrays.</para></sect2></sect1><sect1
id="cadv.strings"
><title
>Strings</title><para
>As mentioned previously a string in C is treated as an array
    of characters. In general, a <type
>char</type> is a single
    character and a <type
>char *</type> is a pointer to an array of
    characters<footnote
><para
>A character is not necessarily a single
    byte. This is true in ASCII but not in
    UNICODE <remark
>Are we going to expand on this?</remark></para></footnote>. Since a C compiler does not know how
    many characters are contained in a particular piece of memory that
    is being referenced the convention in C is that a special
    character value is used to indicate the end of a
    string<footnote
><para
>This leads to problems when linking Perl via
    C to languages that do not use this particular convention. Fortran
    is a popular example where the compiler does know how long each
    string is and therefore does not need a special string termination
    character</para></footnote>.  This string termination character is
    character <literal
moreinfo="none"
>\0</literal> (the character with value 0 in the
    character set [<userinput
moreinfo="none"
>chr(0)</userinput> in Perl] not
    character zero [<userinput
moreinfo="none"
>ord(0)</userinput> in Perl]) and is
    known as the NUL character. <xref
linkend="cadv.fig.cstr"
></xref> shows a
    simple example of string manipulation using a pointer and a Perl
    translation. The example shows that in Perl a dereferenced
    reference is no different to the original (the example would be
    identical if <varname
>$$b</varname> was replaced with
    <varname
>$a</varname> throughout) and that a string in Perl is a
    single entity whereas in C it is a group of characters.</para><figure
float="0"
id="cadv.fig.cstr"
><title
>String manipulation</title><mediaobject
><imageobject
><imagedata
fileref="hello_c.eps"
format="eps"
></imagedata></imageobject><imageobject
><imagedata
fileref="hello_c.gif"
format="gif"
></imagedata></imageobject><caption
><programlisting
format="linespecific"
>$a = "hello";
$b = \$a;
substr($$b, 0, 1) = 'm';
substr($$b, 3, 1) = 'd';
$a = substr($$b, 0,4);</programlisting><para
>Example of how a string can be manipulated a character at a
time using pointers along with a somewhat contrived  Perl equivalent 
since perl manipulates strings but C manipulates characters.</para></caption></mediaobject></figure><sect2
id="cadv.stringarr"
><title
>Arrays of strings</title><para
>Unlike numeric arrays where multi-dimensional arrays are a contiguous
block of memory (since a single number is always represented by a
fixed number of bytes), arrays of strings are arrays of pointers to
strings. The strings themselves can be in completely unrelated areas
of memory.  A pointer to an array of pointers to chracters is
represented by the type <type
>char**</type>. If the variable
<varname
>x</varname> is a <type
>char**</type>, <varname
>*x</varname>
is a pointer to a string and <type
>**x</type> is the single
character at the start of the string. This is represented graphically
in <xref
linkend="cadv.fig.cstrstr"
></xref>.</para><figure
float="0"
id="cadv.fig.cstrstr"
><title
>Arrays of strings</title><mediaobject
><imageobject
><imagedata
fileref="charstarstar.eps"
format="eps"
></imagedata></imageobject><imageobject
><imagedata
fileref="charstarstar.png"
format="png"
></imagedata></imageobject><caption
><para
>The memory organization of an array of strings. On
	    the left we have a simple pointer. This pointer (a
	    <type
>char**</type>) points to an array of pointers (shown
	    in the middle). These pointers are of type
	    <type
>char*</type> and point to the first character in
	    each string. We use the NULL at the end of the pointer
	    array to tell us where the end of the array is.</para></caption></mediaobject></figure><para
>As a simple example, of using a <type
>char**</type> we can make
use of the Unix environment. The environment is available to
programmers as an array of strings. For example, if we wanted to write
a small program to print our current environment (similar to the
<command
moreinfo="none"
>printenv</command> shell command) we could do something like
this:</para><programlistingco
><areaspec
><area
coords="3"
id="cadv.strarr.environ"
></area><area
coords="7"
id="cadv.strarr.cpenv"
></area><area
coords="9"
id="cadv.strarr.loop"
></area></areaspec><programlisting
format="linespecific"
>#include &lt;stdio.h&gt;

extern char** environ;

int main () {
  int i;
  char **array = environ;

  while (*array) {
    printf("%s\n", *array);
    array++;
  }

  return(0);
}</programlisting><calloutlist
><callout
arearefs="cadv.strarr.environ"
><para
><varname
>environ</varname> is a special variable
	    provided by the system and populated when the process
	    starts. The <type
>extern</type> declaration tells the
	    compiler that we are using a variable declared in some
	    other file.</para></callout><callout
arearefs="cadv.strarr.cpenv"
><para
>Here we declare a new <type
>char**</type> and copy
	    the pointer from the environment array. We do this so that
	    we can manipulate the pointer without affecting the base
	    pointer.</para></callout><callout
arearefs="cadv.strarr.loop"
><para
>This <function
moreinfo="none"
>while</function> loop continues until
	    <varname
>*array</varname> evaluates to false. Since
	    <varname
>*array</varname> is itself a pointer this only
	    happens when <varname
>*array</varname> is NULL. Each time round
	    the loop we print out the string associated with the
	    current pointer value and then increment the pointer so
	    that we move to the next element in the array. When we
	    reach the end of the array we hit the null and terminate
	    the loop.</para></callout></calloutlist></programlistingco></sect2></sect1><sect1
id="cadv.struct"
><title
>Structures</title><para
>In many cases it is desirable to group related data into a single unit
that can be passed easily into subroutines. In perl this is achieved
by using a hash or an array which can themselves contain references to
any of the standard perl data types and can even be blessed into
classes and treated as objects. In C arrays can only contain variables
of the same type<footnote
><para
>although in principle you could have
an array of pointers to items of different type in practice it is
difficult to keep track of which element points to which data
type.</para></footnote> and an alternative method is provided for
grouping data into structures that can contain named elements similar
to a Perl hash.  These structures, declared using the
<function
moreinfo="none"
>struct</function> keyword, can be given an arbritrary type
and can also include any other variable type:</para><programlisting
format="linespecific"
>struct person {
   double income; /* A double precision number */
   int    age;    /* An integer */
   char*  name;   /* Pointer to a character string */
};

struct survey {
   struct person* respondent; /* Pointer to a structure of type person */
   float length;       /* Floating point number (single precision) */
   int* answers;       /* Pointer to an array of integers */
};</programlisting><para
>Once a structure has been declared variables can be declared
    of that type in the normal way:</para><programlisting
format="linespecific"
>struct person mystruct; /* mystruct is now a variable of type person */
struct survey* mypoint; /* mypoint is now a pointer to a struct of type survey */</programlisting><para
>A common trick to save typing is to instruct the compiler to
    use an alias rather than having to type <userinput
moreinfo="none"
>struct
    person</userinput> all the time. The <function
moreinfo="none"
>typedef</function>
    command allows any variable type to be aliased to another:</para><programlisting
format="linespecific"
>typedef int myint;  /* myint is now identical to an int declaration */
typedef struct person PERSON;  /* PERSON is now an alias for struct person */
struct person mystruct; /* mystruct declared as a struct person */
PERSON mystruct;        /* Same as previous line */</programlisting><para
>This technique is used a lot in the Perl source code where
    you very rarely see an explicit <type
>struct</type>. All struct
    accesses are done with aliases (and even more commonly done with C
    pre-processor macros).</para><para
>Accessing the members of the structure depends on whether
    you have a pointer to the structure or have declared the structure
    variable directly. The following example shows C struct accessors
    with a corresponding perl hash accessor:</para><programlisting
format="linespecific"
>mystruct.age = 5; /* Set member 'age' to 5 */
$mystruct{'age'} = 5;  # perl

mypoint-&gt;length = 5.234; /* Set member y by dereferencing pointer */
$mypoint-&gt;{'length'} = 5.234; # Perl dereference

(*mypoint).length = 5.234; /* Same as previous line */
$$mypoint{'length'} = 5.234; # Alternative form of dereferencing</programlisting><para
>The main difference between a struct and a hash is that all
    the members of a struct must be declared beforehand and no extra
    members can be created as the program executes. This is because a
    struct, like an array, is a contiguous block of memory of a fixed
    size. Even if a particular element of a struct is not initialised
    it will still take up the same amount of memory as a fully
    initialised struct. Our <type
>struct person</type> declared above
    consists of a <type
>double</type>, an <type
>int</type> and a
    pointer to a string. On a normal 32-bit system this will most
    likely take up 8+4+4=16 bytes of memory; the standard
    <function
moreinfo="none"
>sizeof</function> can be used to determine how much
    memory the structure actually uses (in some cases a compiler will
    pad the structure with extra bytes to make it a convenient size
    for the underlying architecture). Structures must be well-defined
    like this so that the compiler can decide on how much memory to
    allocate to each one. This is all clearly different from a perl
    hash where keys can be added at any time and the memory
    requirement is not fixed. Details on how hashes are implemented in
    C to overcome any restriction of this kind can be found in <xref
linkend="perlvar.hashes"
></xref>.<footnote
><para
>Additionally as a
    structure is represented by a single contiguous block of memory
    (just like arrays) it is possible to simply step the required
    number of bytes into a structure to extract out information but
    this is not recommended and can lead to confusion and difficulty
    in porting the code to other platforms; always use the standard
    accessor techniques.</para></footnote></para><para
>In a similar manner to arrays, it is possible to initialise
    a structure in one statement:</para><programlisting
format="linespecific"
>struct example {
  double a;
  float b;
  int c;
};

struct example eg = { 52.8 , 65.4, 40 };</programlisting><para
>This provides a useful shorthand way of configuring
    structures without having to address each member by name. The
    curly brackets effectively packing the data into a single block of
    memory and is exactly the same as using the Perl
    <function
moreinfo="none"
>pack</function>:</para><programlisting
format="linespecific"
>$packed = pack("dfi", 52.8,65.4,40);</programlisting></sect1><sect1
id="cadv.fileio"
><title
>File I/O</title><para
>In C, just as in Perl<footnote
><para
>simply because Perl
    provides interfaces to both types of I/O in the standard C
    library</para></footnote>, there are two approaches to handling
    input from and output to external files<footnote
><para
>This
    includes sockets and devices. On Unix all devices are treated as
    files.</para></footnote>:</para><itemizedlist
><listitem
><para
>Stream-based I/O provides a high level interface,
	specifically providing buffering facilities and the ability to
	move forwards and backwards within a file. Buffered I/O is
	important for performance reasons (when writing to real
	hardware it is usually more efficient to store up writes to a
	disk into large chunks rather than sending a byte at a
	time). By default perl filehandles use streams and the
	buffering can be turned on or off using the special variable
	<varname
>$|</varname> (the default is to turn on buffering
	leading to much confusion from people the first time they
	write a CGI script!). In C a stream is represented by a
	<varname
>FILE*</varname> (a pointer to a FILE). This is an
	opaque structure since you never look inside the structure -
	that is left to the low level implementation in the C library
	itself. To open a stream you can use
	<function
moreinfo="none"
>fopen</function>:</para><funcsynopsis
><funcprototype
><funcdef
>FILE *<function
moreinfo="none"
>fopen</function></funcdef><paramdef
>const char *<parameter
moreinfo="none"
>path</parameter></paramdef><paramdef
>const char *<parameter
moreinfo="none"
>mode</parameter></paramdef></funcprototype></funcsynopsis><para
>and to print to a file you can use
	<function
moreinfo="none"
>fprintf</function></para><funcsynopsis
><funcprototype
><funcdef
>int <function
moreinfo="none"
>fprintf</function></funcdef><paramdef
>FILE *<parameter
moreinfo="none"
>stream</parameter></paramdef><paramdef
>const char *<parameter
moreinfo="none"
>format</parameter></paramdef><paramdef
>...</paramdef></funcprototype></funcsynopsis><para
>To close it you use, predictably,
	<function
moreinfo="none"
>fclose</function>:</para><funcsynopsis
><funcprototype
><funcdef
>int <function
moreinfo="none"
>fclose</function></funcdef><paramdef
>FILE *<parameter
moreinfo="none"
>stream</parameter></paramdef></funcprototype></funcsynopsis><para
>These are very similar to the corresponding perl
	routines, <function
moreinfo="none"
>open</function>,
	<function
moreinfo="none"
>printf</function> and
	<function
moreinfo="none"
>close</function>.</para></listitem><listitem
><para
>A lower level approach to I/O (at least on UNIX-like
	systems) is to use <firstterm
>file
	descriptors</firstterm>. These are simple integers (you can
	get the file descriptor from a perl filehandle using the
	<function
moreinfo="none"
>fileno</function> routine). File descriptors can be
	used for non-buffered I/O and are especially useful for socket
	communication. The C functions <function
moreinfo="none"
>open</function>,
	<function
moreinfo="none"
>close</function>, <function
moreinfo="none"
>read</function> and
	<function
moreinfo="none"
>write</function> are direct equivalents of the Perl
	functions <function
moreinfo="none"
>sysopen</function>,
	<function
moreinfo="none"
>close</function>, <function
moreinfo="none"
>sysread</function> and
	<function
moreinfo="none"
>syswrite</function>. Just as in Perl, you should not
	mix stream-based I/O with file descriptor I/O on the same file
	handle.</para></listitem></itemizedlist><para
>In general all of the perl file I/O operations have
    analogues in the C library either as stream-based functions or
    functions using file descriptors (the
    <filename
moreinfo="none"
>perlfunc</filename> documentation is careful to
    distinguish between the two).</para><remark
>Reviewer asked for an explicit example here. I was holding
    of on this because the commands are so close to the standard perl
    functions.</remark></sect1><sect1
id="cadv.mem"
><title
>Memory Management</title><para
>So far we have explained the different variable types and
    always made sure that our program has specified the amount of
    memory required to use them. In <xref
linkend="cadv.arr.eg"
></xref> we
    specified the number of elements for each array. The memory for
    these variables is allocated by the compiler which works out the
    total amount of memory required by the program. Unfortunately,
    sometimes you can not know at compile time how much memory you
    program will need. For example, if you are writing some image
    processing software you may not know how big an image you will
    need to process. One solution, required if you use a language such
    as Fortran77<footnote
><para
>although most modern implementations
    of Fortran77 ignore the restriction</para></footnote>, is to make
    an inspired guess of the maxium image size you wish to process and
    hard-wire the dimensions into your program. This will work but has
    two problems:</para><itemizedlist
><listitem
><para
>If you need to process larger images you will need to
	recompile your program (presumably this is easy because you
	have specified the dimensions in a header file?)</para></listitem><listitem
><para
>Even if you are processing small images the program will
	require the same amount of memory as it uses for large
	images.</para></listitem></itemizedlist><para
>Clearly an alternative approach is required. What we really
    want to do is to determine the image size that we are intending to
    process and then allocate that memory when the program is
    running.</para><sect2
id="cadv.mem.run"
><title
>Allocating memory at runtime</title><para
>The main C function for <emphasis
>dynamically</emphasis>
    allocating memory is <function
moreinfo="none"
>malloc</function>:</para><funcsynopsis
><funcprototype
><funcdef
>void * <function
moreinfo="none"
>malloc</function></funcdef><paramdef
>size_t <parameter
moreinfo="none"
>size</parameter></paramdef></funcprototype></funcsynopsis><para
>The argument specifies the number of bytes required and
      the function returns a pointer which can be type-cast to the
      correct type. Recall that if you declare a pointer variable, you
      have to make sure that it points to some allocated memory. So
      far we have done this by obtaining the pointer from some other
      variable. For example:</para><programlisting
format="linespecific"
>  char * pointer_to_char;
  char a_string[4];
  int an_integer;
  int * pointer_to_int;

  pointer_to_char = a_string;
  pointer_to_int = &amp;an_integer;</programlisting><para
>With dynamic memory allocation we can do this (the
      prototype for <function
moreinfo="none"
>malloc</function> can be found in
      <filename
moreinfo="none"
>stdlib.h</filename>):</para><programlisting
format="linespecific"
>  #include &lt;stdlib.h&gt;
  char * pointer_to_char;

  pointer_to_char = malloc(4);</programlisting><para
>Here we have requested 4 bytes of memory and we have
      stored the pointer returned by <function
moreinfo="none"
>malloc</function> in
      the variable <varname
>pointer_to_char</varname>. It is important
      to realise here that the memory has been allocated but not
      necessarily initialised (the contents will be undefined). You
      are responsible for storing information in that memory.</para><para
>The downside of dynamic memory allocation in C is that the
      programmer is responsible for giving the memory back when it is
      no longer required. If we keep on requesting memory but never
      give it back we will rapidly run out of resources. This is known
      as a <firstterm
>memory leak</firstterm>. C provides the
      <function
moreinfo="none"
>free</function> to allow you to return memory to the
      system:</para><funcsynopsis
><funcprototype
><funcdef
>void  <function
moreinfo="none"
>free</function></funcdef><paramdef
>void * <parameter
moreinfo="none"
>ptr</parameter></paramdef></funcprototype></funcsynopsis><para
>This function takes a single pointer argument and will
      free the memory at that address. This memory must have been
      allocated by a call to <function
moreinfo="none"
>malloc</function> (or the
      related functions <function
moreinfo="none"
>calloc</function> and
      <function
moreinfo="none"
>realloc</function>) and care should be taken that it
      is not called twice with the same pointer value (strange things
      may happen since the system may have already given that memory
      to something else!).</para><para
>Memory management is one of the hardest things to get
      right in C. With a large program containing many dynamic memory
      allocations it is very hard to guarantee that the memory will be
      freed correctly in all cases. One of the key advantages of Perl,
      Java and others is that they handle all the memory allocation
      and freeing, allowing the programmer to focus on core
      functionality of the program.</para></sect2><sect2
id="cadv.mem.chg"
><title
>Altering the size of memory</title><para
>Occasionally you may realise that the memory you requested
      was not enough for the task in hand: maybe you want to extend an
      array so that it can hold more elements, maybe you want to
      extend a string. The <emphasis
>obvious</emphasis> approach is to
      allocate a new string of the correct size, copy the contents
      from the first string and then free the memory associated with
      it. This is painful but luckily the standard C library comes
      with a function that will do this for you:</para><funcsynopsis
><funcprototype
><funcdef
>void  * <function
moreinfo="none"
>realloc</function></funcdef><paramdef
>void * <parameter
moreinfo="none"
>ptr</parameter></paramdef><paramdef
>size_t <parameter
moreinfo="none"
>bytes</parameter></paramdef></funcprototype></funcsynopsis><para
>This function will resize the available memory pointed to
      by <varname
>ptr</varname>.  The original contents of the memory
      will be retained and any new memory will be unintialized. If
      <varname
>bytes</varname> is less than the previous size then the
      additional memory will be freed. <function
moreinfo="none"
>realloc</function>
      returns a new memory address which will not necessarily be the
      same as that stored in <varname
>ptr</varname>. You should always
      use the return value rather than assuming that you will be
      getting memory at the same location.</para><note
><para
>Recall that arguments in C are passed by value. Since the
	content of <varname
>ptr</varname> is passed in as a memory
	address the function will not be able to modify the contents
	of <varname
>ptr</varname> in the calling routine. This could
	have been overcome by passing in a pointer to the pointer (!) 
	but the designers of the interface for
	<function
moreinfo="none"
>realloc</function> decided to return the new pointer
	directly as a return argument.</para><programlisting
format="linespecific"
>ptr = realloc( ptr, nbytes );</programlisting></note><para
>As with all memory allocation routines. Do not forget to
      check the returned pointer to make sure it is non-NULL. All
      these routines return null pointers if the memory can not be
      allocated.</para></sect2><sect2
id="cadv.mem.manip"
><title
>Manipulating Memory</title><para
>Now that you have your memory allocated, what can you do
      with it? If you want to copy it to another variable (for example
      to copy the contents of a structure before it is reused) you can
      use <function
moreinfo="none"
>memcpy</function> (use <function
moreinfo="none"
>memmove</function> if
      the memory destination lies within the chunk of data that is
      being copied).</para><programlistingco
><areaspec
><areaset
coords="1"
id="memcpy.includes"
><area
coords="1"
id="memcpy.inc.stdlib"
></area><area
coords="2"
id="memcpy.inc.stdio"
></area><area
coords="3"
id="memcpy.inc.string"
></area></areaset><area
coords="5"
id="memcpy.decl.struct"
></area><area
coords="11"
id="memcpy.main"
></area><areaset
coords="13"
id="memcpy.decl"
><area
coords="13"
id="memcpy.decl.char"
></area><area
coords="14"
id="memcpy.decl.person"
></area><area
coords="15"
id="memcpy.decl.person.ptr"
></area></areaset><area
coords="17"
id="memcpy.alloc"
></area><area
coords="18"
id="memcpy.cpy"
></area><area
coords="20"
id="memcpy.test.other.income"
></area><area
coords="21"
id="memcpy.test.someone"
></area><area
coords="24"
id="memcpy.test.someone.name"
></area><area
coords="25"
id="memcpy.test.other"
></area><area
coords="28"
id="memcpy.free"
></area></areaspec><programlisting
format="linespecific"
>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

typedef struct {
   double income; /* A double precision number */
   int    age;    /* An integer */
   char*  name;   /* Pointer to a character string */
} person;

int main () {

  char name[6] = "fred";
  person someone = { 20000.0, 5, name };
  person *other;

  other = malloc(sizeof(*other));
  memcpy(other, &amp;someone, sizeof(*other));

  other-&gt;income = 0.0;
  printf("Someone: %d, %6.0f, %s\n", someone.age, someone.income,
	 someone.name);

  strcpy(someone.name, "wilma");
  printf("Other:   %d, %6.0f, %s\n", other-&gt;age, other-&gt;income,
	 other-&gt;name);

  free(other);
  return(0);
}</programlisting><calloutlist
><callout
arearefs="memcpy.includes"
><para
>These include files declare the prototypes for
	    <function
moreinfo="none"
>malloc</function>, <function
moreinfo="none"
>printf</function>,
	    <function
moreinfo="none"
>memcpy</function> and
	    <function
moreinfo="none"
>strcpy</function></para></callout><callout
arearefs="memcpy.decl.struct"
><para
>Here we create an anonymous structure and
	    simultaneously typedef it to a <type
>person</type>.</para></callout><callout
arearefs="memcpy.main"
><para
>This is the standard C main routine but here we do
	    not declare any arguments since we are not interested in
	    them.</para></callout><callout
arearefs="memcpy.decl"
><para
>Variable declarations. We allocate a string,
	    initialise a <type
>person</type> structure (that includes
	    the previously declared string) and declare a pointer to a
	    <type
>person</type>.</para></callout><callout
arearefs="memcpy.alloc"
><para
>Allocate memory for a new structure. We determine
	    the number of bytes required by using
	    <function
moreinfo="none"
>sizeof</function>. One thing to note here is
	    that we calculate the size of <varname
>*other</varname>
	    rather than <type
>person</type>. Either approach would
	    work but using the variable name rather than the type
	    would allow for simpler editing if we were to change the
	    type in a later version of the code.</para></callout><callout
arearefs="memcpy.cpy"
><para
>Use <function
moreinfo="none"
>memcpy</function> to copy the contents
	    of <varname
>someone</varname> to the memory indicated by
	    <varname
>other</varname>. We must supply the size of the
	    structure in bytes.</para></callout><callout
arearefs="memcpy.test.other.income"
><para
>Set the income in <varname
>other</varname> to zero.</para></callout><callout
arearefs="memcpy.test.someone"
><para
>Print out the contents of the original structure.</para></callout><callout
arearefs="memcpy.test.someone.name"
><para
>Set the name in the original structure to
	    <quote
>wilma</quote></para></callout><callout
arearefs="memcpy.test.other"
><para
>Print out the contents of the copy.</para></callout><callout
arearefs="memcpy.free"
><para
>Free the dynamically allocated memory.</para></callout></calloutlist></programlistingco><para
>If we run the above program we get the following
      output:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>gcc -Wall memcpy.c -o memcpy</userinput>
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>./memcpy</userinput>
Someone: 5,  20000, fred
Other:   5,      0, wilma</screen><para
>So, when we modified the income of
      <varname
>other</varname> it did not affect the contents of
      <varname
>someone</varname> but when we modified the name of
      <varname
>someone</varname> it did affect
      <varname
>other</varname>. What is going on here? The answer lies
      in the struct declaration. When the structure is copied,
      everything is copied exactly to the destination. The first two
      entries are simply numbers and are copied as such. If they are
      modified the bytes change as we would expect without affecting
      anything else. The third member is simply a pointer. This means
      that the pointer is identical in both structures and if that
      memory is modified both structures <quote
>see</quote> the
      change.</para><para
>If you want to initialise an array with a default value
      you can use the <function
moreinfo="none"
>memset</function> function (or you can allocate
      the array using the <function
moreinfo="none"
>calloc</function> function which allocates
      the memory and then sets all bits to zero)</para><programlistingco
><areaspec
><areaset
coords="1"
id="mem.includes"
><area
coords="1"
id="mem.inc.stdlib"
></area><area
coords="2"
id="mem.inc.stdio"
></area><area
coords="3"
id="mem.inc.string"
></area></areaset><area
coords="5"
id="mem.define"
></area><area
coords="7"
id="mem.main"
></area><area
coords="10"
id="mem.decl"
></area><area
coords="11"
id="mem.alloc"
></area><area
coords="12"
id="mem.set"
></area><area
coords="15"
id="mem.test"
></area><area
coords="18"
id="mem.free"
></area></areaspec><programlisting
format="linespecific"
>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define NELEM 10

int main () {

  int i;
  int * array;
  array = malloc(sizeof(int)*NELEM);
  memset(array, 0, sizeof(int)*NELEM);

  for (i=0; i&lt;NELEM; i++) {
    printf("Index %d element %d\n",i, array[i]);
  }

  free(array);
  return(0);
}</programlisting><calloutlist
><callout
arearefs="mem.includes"
><para
>These include files declare the prototypes for
	    <function
moreinfo="none"
>malloc</function>, <function
moreinfo="none"
>printf</function>
	    and <function
moreinfo="none"
>memset</function> respectively.</para></callout><callout
arearefs="mem.define"
><para
>We declare the size of the array in a single place
	    so that we don't need to rely on a bare number in the
	    code. Remember that C arrays do not know their
	    size.</para></callout><callout
arearefs="mem.main"
><para
>As with the previous example this is the standard C
	    main routine but we do not declare any arguments
	    since we are not interested in them.</para></callout><callout
arearefs="mem.decl"
><para
>Declare <varname
>array</varname> as a pointer to an
	    integer.</para></callout><callout
arearefs="mem.alloc"
><para
>Allocate <varname
>NELEM</varname> integers.  We
	    multiply the number of elements by the number of bytes in
	    each integer to determine the total number of bytes
	    required.</para></callout><callout
arearefs="mem.set"
><para
>Set each byte in the new array to zero.</para></callout><callout
arearefs="mem.test"
><para
>Loop through each element of the array, printing it
	    to the screen.</para></callout><callout
arearefs="mem.free"
><para
>Free the memory.</para></callout></calloutlist></programlistingco><para
>In some architectures, setting all bytes to zero does not
      initialize all values to zero (since a number is represented by
      multiple bytes). To be absolutely sure that you are initialising
      the memory correctly an explict loop is probably the safest
      solution.</para></sect2><sect2
id="cadv.mem.perl"
><title
>Memory manipulation and Perl</title><remark
>This is discussed to some extent in the chapter on perl
      API and we could get away with moving this section straight into
      that chapter. We want to describe these specially here because
      they are the most common wrappers that are used by XS. They are
      not the only ones and we may feel a need to include the others
      listed in <filename
moreinfo="none"
>perlclib</filename> as well. If this becomes
      an appendix we really need to have this stuff early on in the
      book. Having it here as a summary is fine so long as there is a
      ref to more explicit coverage.</remark><para
>Having said all this, in the perl source code you will
      never use any of the functions for memory allocation and
      manipulation that we have described above. In the interests of
      cross-platform portability and debugging support Perl uses
      private definitions of these functions by providing C
      pre-processor macros. The <function
moreinfo="none"
>New</function> may
      eventually translate to a <function
moreinfo="none"
>malloc</function> but it
      doesn't have to. If we are attempting to check for memory leaks
      we may want to redefine <function
moreinfo="none"
>New</function> so that it
      keeps track of the allocations and corresponding frees and a
      macro makes this extremely simple. <xref
linkend="cadv.tab.malloc"
></xref> contains a list of the standard C
      library functions and the Perl equivalents. In the table
      <literal
moreinfo="none"
>t</literal> indicates a variable type,
      <literal
moreinfo="none"
>p</literal> indicates a pointer, <literal
moreinfo="none"
>n</literal>
      is a number and <literal
moreinfo="none"
>s</literal> is a
      string. <literal
moreinfo="none"
>dst</literal>, <literal
moreinfo="none"
>src</literal> and
      <literal
moreinfo="none"
>id</literal> indicate destination pointer, source
      pointer and identification tag respectively. The
      <literal
moreinfo="none"
>id</literal> could be used to track memory leaks
      although it is not currently used in the Perl source.</para><table
id="cadv.tab.malloc"
><title
>Perl macros for memory manipulation</title><tgroup
cols="2"
><tbody
><row
><entry
>Perl source</entry><entry
>C library</entry></row><row
><entry
><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>New</function></funcdef><paramdef
><parameter
moreinfo="none"
>id</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>p</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>n</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>t</parameter></paramdef></funcprototype></funcsynopsis></entry><entry
><funcsynopsis
><funcprototype
><funcdef
>t* p = <function
moreinfo="none"
>malloc</function></funcdef><paramdef
><parameter
moreinfo="none"
>n</parameter></paramdef></funcprototype></funcsynopsis></entry></row><row
><entry
><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>Newz</function></funcdef><paramdef
><parameter
moreinfo="none"
>id</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>p</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>n</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>t</parameter></paramdef></funcprototype></funcsynopsis></entry><entry
><funcsynopsis
><funcprototype
><funcdef
>t* p = <function
moreinfo="none"
>calloc</function></funcdef><paramdef
><parameter
moreinfo="none"
>n</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>s</parameter></paramdef></funcprototype></funcsynopsis></entry></row><row
><entry
><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>Renew</function></funcdef><paramdef
><parameter
moreinfo="none"
>p</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>n</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>t</parameter></paramdef></funcprototype></funcsynopsis></entry><entry
><funcsynopsis
><funcprototype
><funcdef
>p = <function
moreinfo="none"
>realloc</function></funcdef><paramdef
><parameter
moreinfo="none"
>p</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>n</parameter></paramdef></funcprototype></funcsynopsis></entry></row><row
><entry
><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>Safefree</function></funcdef><paramdef
><parameter
moreinfo="none"
>p</parameter></paramdef></funcprototype></funcsynopsis></entry><entry
><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>free</function></funcdef><paramdef
><parameter
moreinfo="none"
>p</parameter></paramdef></funcprototype></funcsynopsis></entry></row><row
><entry
><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>Copy</function></funcdef><paramdef
><parameter
moreinfo="none"
>src</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>dst</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>n</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>t</parameter></paramdef></funcprototype></funcsynopsis></entry><entry
><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>memcpy</function></funcdef><paramdef
><parameter
moreinfo="none"
>dst</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>src</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>n</parameter></paramdef></funcprototype></funcsynopsis></entry></row><row
><entry
><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>StructCopy</function></funcdef><paramdef
><parameter
moreinfo="none"
>src</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>dst</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>t</parameter></paramdef></funcprototype></funcsynopsis></entry><entry
><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>memcpy</function></funcdef><paramdef
><parameter
moreinfo="none"
>dst</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>src</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>n</parameter></paramdef></funcprototype></funcsynopsis> (structures only)</entry></row><row
><entry
><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>Move</function></funcdef><paramdef
><parameter
moreinfo="none"
>src</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>dst</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>n</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>t</parameter></paramdef></funcprototype></funcsynopsis></entry><entry
><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>memmove</function></funcdef><paramdef
><parameter
moreinfo="none"
>dst</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>src</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>n</parameter></paramdef></funcprototype></funcsynopsis></entry></row></tbody></tgroup></table></sect2></sect1><sect1
><title
>C Traps</title><remark
>Still TBD.</remark><remark
>What are we really going to put in here?</remark></sect1><sect1
id="cadv.summary"
><title
>Summary</title><para
>In this chapter we have learnt the following:</para><itemizedlist
><listitem
><para
>Arguments are passed into functions by value. In order
	to modify a variable in a function a pointer to the variable
	must be used.</para></listitem><listitem
><para
>Arrays in C are simply blocks of memory that can be
	addressed by a pointer. They can not be re-sized without
	allocating more memory and, when dynamically allocated, they
	do not know how long they are.</para></listitem><listitem
><para
>C has no native hashes, only fixed size structures.</para></listitem><listitem
><para
>C will not automatically allocate more memory as you
	need it. You have to explicitly ask for more memory and you
	have to make sure you give it back to the system when it is no
	longer required.</para></listitem></itemizedlist></sect1><sect1
id="cadv.reading"
><title
>Further reading</title><para
>There are many books available on the C programming language
    and we can not recommend all of them. The standard reference works
    are Kernighan &amp; Ritchie's <quote
>The C programming
    language</quote> and Harbison &amp; Steele. <quote
>C: A Reference
    Manual</quote>. Also, all the library functions described here
    have corresponding manual pages on most systems. The <ulink
url="http://www.eskimo.com/~scs/C-faq/faq.html"
>comp.lang.c
    FAQ</ulink> is also useful.</para><para
>Finally, the Perl wrappers for standard C functions are
    described in the <filename
moreinfo="none"
>perlclib</filename> documentation that
    comes with perl.</para></sect1></chapter><chapter
id="perlvar"
><title
>Perl's Variable Types</title><para
>Before we can delve deeper into the secrets of XS we need to find out
how variables exist in Perl.  This chapter will explain how Perl
variables (scalars, arrays, hashes and globs) are represented inside
Perl. Starting from the various scalar types (<varname
>$x</varname> in
Perl) it will then continue to discuss magic (for example, ties), the
more complex data types and the organisation of namespaces and lexical
(<quote
><type
>my</type></quote>) variables.</para><para
>This will be the first detailed look inside Perl and will use
knowledge of the types of variables used in C and how C data
structures are implemented. This chapter assumes no more knowledge of C than
that found in the previous chapters.</para><sect1
><title
>Scalar variables</title><para
>A Perl variable is much cleverer than a simple C variable. Perl knows
how many characters the variable needs, how to convert it from a
number to a string and how many other variables know about it (so that
Perl can tidy up after itself). This is achieved by using a C data
structure (a <type
>struct</type>) rather than a simple variable or array.
As explained in the previous chapter a C struct is a block of memory
that can contain any number of variables of any type. Each entry in
the struct can be accessed by name and is functionally equivalent to a
simplified Perl hash.</para><para
>The simplest of all perl variable types is a scalar (e.g.
<varname
>$xyz</varname>) and this is represented inside Perl as a C
structure of type <type
>SV</type> (<type
>SV</type> stands for
<firstterm
>Scalar Value</firstterm>)<footnote
><para
>inside Perl the
<type
>SV</type> type is a typedef (or alias) for a structure of type
<type
>sv</type> (a <type
>struct sv</type>) defined in the
<filename
moreinfo="none"
>sv.h</filename> include file.</para></footnote>.</para><sect2
><title
>SvNULL</title><para
>The basic implementation of an <type
>SV</type> from which all perl
variables are derived is the <type
>SvNULL</type> structure:</para><remark
>Would like to show these and similar diagrams in a more graphical way
showing the data structure in a more approachable way. That is why I
also give a "perl" equivalent. Would be annotated in the way indicated
to show sv_any, sv_refcnt, sv_flags and explaining that a U32 is a int
of at least 4 bytes</remark><programlistingco
><areaspec
><area
coords="1"
id="perlvar.name"
></area><area
coords="2"
id="perlvar.any"
></area><areaset
coords=""
id="perlvar.u32"
><area
coords="3"
id="perlvar.u32.c1"
></area><area
coords="4"
id="perlvar.u32.c2"
></area></areaset></areaspec><programlisting
format="linespecific"
>struct sv {
   void* sv_any;
   U32   sv_refcnt;
   U32   sv_flags;
}</programlisting><calloutlist
><callout
arearefs="perlvar.name"
><para
>This creates a new structure named <varname
>sv</varname></para></callout><callout
arearefs="perlvar.any"
><para
>This is simply a pointer of any allowed type.</para></callout><callout
arearefs="perlvar.u32"
><para
>This is an unsigned integer that must be at least 4 bytes (32 bits) long.</para></callout></calloutlist></programlistingco><para
>Using perl hash syntax this would become:</para><programlisting
format="linespecific"
>$sv = {
        sv_any =&gt; undef,
        sv_refcnt =&gt; 1,
        sv_flags  =&gt; 0
      };</programlisting><para
>The actual fields (<varname
>sv_any</varname>,
<varname
>sv_refcnt</varname> and <varname
>sv_flags</varname>) can be
accessed using C macros (defined in the <filename
moreinfo="none"
>sv.h</filename>
include file) <function
moreinfo="none"
>SvANY</function>,
<function
moreinfo="none"
>SvREFCNT</function> and <function
moreinfo="none"
>SvFLAGS</function> (these
also match the output provided by the
<classname
>Devel::Peek</classname> module described later).  From now
on, the structure fields will be named after the macro name (without
the leading <type
>Sv</type> string) rather than the actual name used to
define the structure since all programs written using the internals go
through the provided macros rather than directly to the structure.</para><para
>The <varname
>ANY</varname> field is used to point to an additional
structure that contains the specific state of the variable and can be
changed depending on whether an integer (<type
>IV</type>), double
precision floating point number (<type
>NV</type>) or character string
(<type
>PV</type>; standing for pointer value rather than
<emphasis
>string value</emphasis> since <type
>SV</type> is already
taken and a string in C is defined by using a pointer to the memory
location of the first character). Variables are implemented in this
way so that the basic structure of the variable is well defined such
that all Perl variables, however complex the implementation, still
have the same toplevel organization.  Whenever it is necessary to
store new information in the <type
>SV</type> the structure pointed to
by the <varname
>ANY</varname> field is changed to accomodate the new
data (it is <emphasis
>upgraded</emphasis> to the new form).  It is not
possible to <emphasis
>downgrade</emphasis> an <type
>SV</type> to a
type containing less information since that would throw information
away. The different types are discussed later on in this chapter.</para><para
>For an <type
>SvNULL</type> structure the <varname
>ANY</varname> field
does not point to anything (it contains a <literal
moreinfo="none"
>NULL</literal>
pointer)<footnote
><para
><type
>NULL</type> is the C equivalent of
<function
moreinfo="none"
>undef</function></para></footnote> so this structure represents a
scalar with a value of <function
moreinfo="none"
>undef</function>.</para><para
>The <varname
>REFCNT</varname> field contains the current reference
count for the variable. Perl decides whether the memory associated
with a variable can be recycled on the basis of reference
counting. When a variable is created it has a reference count of
1. Whenever a reference of that variable is stored somewhere the
reference count is increased by 1 and whenever a reference is no
longer required the reference count is decreased by 1. If the
reference count goes to zero the variable can no longer be used by
Perl and the memory associated with it is freed.</para><para
>The <varname
>FLAGS</varname> field contains bit flags that can be used to
determine the behaviour of certain fields and the current state of the 
variable (for example, whether the variable is a package variable or a lexical
variable).</para></sect2><sect2
><title
>Looking inside - <classname
>Devel::Peek</classname></title><para
>When you are developing Perl extensions (or are simply interested in
what is happening to a variable) it is very useful to be able to
examine the internal structure of a Perl variable from a Perl
program. The <classname
>Devel::Peek</classname> module is available as
part of the standard perl distribution and provides the functionality
for doing just that. It can be used to list the current state of a
variable in detail.</para><para
>In the following example, the Perl code is on the left and the
corresponding output from each line is on the right:</para><programlistingco
><areaspec
><area
coords="3"
id="devel-peek.1.1"
></area><area
coords="4"
id="devel-peek.1.2"
></area><area
coords="5"
id="devel-peek.1.3"
></area><area
coords="9"
id="devel-peek.1.4"
></area><area
coords="12"
id="devel-peek.1.5"
></area></areaspec><programlisting
format="linespecific"
>  use Devel::Peek;                                     
  $a = undef;            
  Dump $a;                      SV = NULL(0x0) at 0x80f9bf0 
                                  REFCNT = 1
                                  FLAGS = ()

  $b = \$a;
  Dump $a;                      SV = NULL(0x0) at 0x80f9bf0 
                                  REFCNT = 2
                                  FLAGS = ()

  print $b;                     SCALAR(0x80f9bf0)
</programlisting><calloutlist
><callout
arearefs="devel-peek.1.1"
><para
><classname
>Devel::Peek</classname> shows us that we have an SVNULL
structure, and it tells us the memory address of that structure -
<literal
moreinfo="none"
>0x80f9bf0</literal> in this particular instance; expect your
output to show a different location. The address in brackets
(<literal
moreinfo="none"
>0x0</literal>) tells us where the <varname
>ANY</varname>
field in the SV's structure is pointing - in the case of an SVNULL,
this is zero, but in more complicated SVs, it will point to another
structure in memory.</para></callout><callout
arearefs="devel-peek.1.2"
><para
>Initially, we have one reference to the <type
>SV</type>.</para></callout><callout
arearefs="devel-peek.1.3"
><para
>The SV's flags are empty.</para></callout><callout
arearefs="devel-peek.1.4"
><para
>When we create a new reference to the <type
>SV</type>, its reference
count increases by one.</para></callout><callout
arearefs="devel-peek.1.5"
><para
>When the reference is printed (the contents of
<varname
>$b</varname>) note that the stringified reference that Perl
generates includes the memory address.</para></callout></calloutlist></programlistingco></sect2><sect2
><title
>Flags</title><para
>Much of the state information for an <type
>SV</type> is contained in
the <varname
>FLAGS</varname> field and before proceeding further with
the more complex <type
>SV</type> structures we will explain how the
flag system works. All computer data are stored in terms of binary
digits (bits). A particular bit can either be set (a value of
<literal
moreinfo="none"
>1</literal>) or unset (<literal
moreinfo="none"
>0</literal>) and the state of
a bit can be checked by comparing it with a bit mask using binary
logic (a bitwise <function
moreinfo="none"
>AND</function> can be used to determine if
a bit is set, a bitwise <function
moreinfo="none"
>OR</function> can be used to set a
bit). The following example uses a 4-bit number and compares it with a
bitmask to determine whether the specific flag is set (that is, both
the bit in the number to be checked and the bit in the bitmask are
set):</para><screen
format="linespecific"
>               Binary     Decimal
Bit number     3 2 1 0
               
FLAG           0 1 1 0      6
BITMASK        0 0 1 0      2
               -------
AND            0 0 1 0      2</screen><para
>Here the flag has a decimal value of 6 (<literal
moreinfo="none"
>0b0110</literal> in
binary) and when a bitwise <function
moreinfo="none"
>AND</function> operation is
performed with the bit mask the result is non-zero and indicates that
the bit that is set in the bit mask is also set in the flag. If the
result of the operation was zero it would mean that the flag was not
set. In the above example 4 independent states can be stored since we
are using a 4 bit number. In \perl\ the <varname
>FLAGS</varname> field
is implemented using a 32-bit integer and so it is possible to record
32 different states. The actual size of the flag variable or the bit
number associated with each of the states is completely irrelevant as
those values are set internally in the C include values. All that
really matters is that Perl provides C routines that can be used to
query an <type
>SV</type> for a particular state.  For example, in
order to see whether an <type
>SV</type> is readonly the
<function
moreinfo="none"
>SvREADONLY</function> macro can be used:</para><programlisting
format="linespecific"
>  if ( SvREADONLY( sv ) ) 
      printf "SV is readonly\n";</programlisting><para
>The following example shows how a Perl implementation of the READONLY
flag used above could look. This Perl implementation is very similar
to that found in the perl C include files:</para><programlisting
format="linespecific"
>use 5.006;  # binary 0b0010 notation needs perl 5.6
use constant SVf_READONLY =&gt; 0b0010; # Set the mask bit

sub SvREADONLY { $_[0] &amp; SVf_READONLY } # Test the mask bit
sub SvREADONLY_on( $_[0] |= SVf_READONLY } # Set the READONLY bit
sub SvREADONLY_off( $_[0] &amp;= ~SVf_READONLY } # Unset READONLY bit

# Set the flag
$flag = 0;
SvREADONLY_on( $flag );

# Test for the flag
print "Flag is readonly\n" if SvREADONLY( $flag );</programlisting><para
>The important point is that in the above example the programmer only
ever uses the <function
moreinfo="none"
>SvREADONLY</function> subroutines and never
needs to use the <varname
>SVf_READONLY</varname> value directly (or even care
what its value is).</para><para
>When the <classname
>Devel::Peek</classname> module is used it lists
all the flags that are currently set in the variable:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -MDevel::Peek -e 'Dump( my $a )'</userinput>
<computeroutput
moreinfo="none"
>SV = NULL(0x0) at 0x80e58c8
  REFCNT = 1
  FLAGS = (PADBUSY,PADMY)</computeroutput></screen><para
>Here the PADMY flag is set indicating that <varname
>$a</varname> is a
lexical variable (The PADBUSY flag is set for the same reason; see
<xref
linkend="perlvar.my"
></xref>). The important flags will be discussed in this
chapter as the relevant variable types are discussed.</para></sect2><sect2
><title
>SvRV - references</title><para
>The simplest possible perl variable that actually contains data is the
<type
>SvRV</type> subtype and it is used to contain references to
other <type
>SV</type>'s. An <type
>SvRV</type> is simply an
<type
>SV</type> where the <varname
>ANY</varname> field points to a
simple structure (named <varname
>xrv</varname>) that contains a single field
that is a pointer to another <type
>SV</type> (an <type
>SV*</type>):</para><programlisting
format="linespecific"
>struct xrv {
    SV *        xrv_rv;         /* pointer to another SV */
};</programlisting><para
>Represented as a perl structure <userinput
moreinfo="none"
>$b=\$a</userinput> would be</para><programlisting
format="linespecific"
>  $b = {                             
          ANY    =&gt; { RV =&gt; \$a },
          REFCNT =&gt; 1,
          FLAGS  =&gt; ROK
       }</programlisting><para
>or using <classname
>Devel::Peek</classname>:</para><screenco
><areaspec
><area
coords="1"
id="rv.1"
></area><area
coords="2"
id="rv.2"
></area><area
coords="3"
id="rv.3"
></area><area
coords="5"
id="rv.4"
></area><area
coords="6"
id="rv.5"
></area></areaspec><screen
format="linespecific"
>SV = RV(0x80fbabc) at 0x80f9c3c
  REFCNT = 1                   
  FLAGS = (ROK)                
  RV = 0x80ef888
  SV = NULL(0x0) at 0x80ef888  
    REFCNT = 2                 
    FLAGS = ()                 </screen><calloutlist
><callout
arearefs="rv.1"
><para
>This <type
>SV</type> is of type <type
>SvRV</type></para></callout><callout
arearefs="rv.2"
><para
>This reference has a ref count of 1 - that is, <varname
>$b</varname></para></callout><callout
arearefs="rv.3"
><para
>The ROK flag (<emphasis
>Reference OK</emphasis>) bit is set to true to
indicate that the reference is valid (if ROK is false the
variable contains the undefined value).</para></callout><callout
arearefs="rv.4"
><para
>This line tells us about the SV that is being referred to, the SV
stored in <varname
>$a</varname>.</para></callout><callout
arearefs="rv.5"
><para
>We see that this <type
>SV</type> has two references: the value itself,
in <varname
>$a</varname>, and the reference to it, in <varname
>$b</varname>.</para></callout></calloutlist></screenco></sect2><sect2
><title
>SvPV - string values</title><para
>Perl variables that contain just a string representation are type
<type
>SvPV</type> (they simply contain a PV).  They are represented by
a <type
>SV</type> with the <varname
>ANY</varname> field pointing to a
structure that contains a pointer to a string (a <type
>char *</type>
that is named <varname
>PVX</varname>) and two length fields (the
<varname
>CUR</varname> and <varname
>LEN</varname>
fields).<footnote
><para
>the actual name of the <type
>SvPV</type>
struct in the Perl include files is <type
>xpv</type> (similarly an
<type
>SvPVIV</type> uses a struct named <type
>xpviv</type>).  For the
rest of this chapter the struct name will not be explcitly
stated.</para></footnote></para><screen
format="linespecific"
>     ANY  =&gt;  PVX  =&gt;        hello world\0
              CUR  =&gt;        &lt;---------&gt;
              LEN  =&gt;        &lt;-----------&gt;
     REFCNT
     FLAGS =&gt; POK | pPOK    &lt;--- POINTER OK flag</screen><para
>The <varname
>PVX</varname> field contains a pointer to the start of
the string representation of the <type
>SV</type>. The
<varname
>CUR</varname> field is an integer containing the length of
the perl string and the <varname
>LEN</varname> field is an integer
containing the actual number of bytes allocated to the string.
Additionally, the byte at position <userinput
moreinfo="none"
>(PVX + CUR)</userinput>
must be a <quote
>\0</quote> (C uses a <type
>NUL</type> byte to indicate
the end of a string) so that other C functions that receive this
string will handle it correctly. This means that
<varname
>LEN</varname> must be at least 1 more than the value of
<varname
>CUR</varname>. Perl's memory management is such that for
efficiency it will not deallocate memory for the string once it has
been allocated if the string is made smaller. It is much more
efficient simply to change the value of <varname
>CUR</varname> than it
is to free the unused memory when a string becomes shorter.</para><programlisting
format="linespecific"
>  use Devel::Peek;

  $a = "hello world";
  Dump $a;                SV = PV(0x80e5b04) at 0x80f9d98  
                            REFCNT = 1                     
                            FLAGS = (POK,pPOK)             
                            PV = 0x80e9660 "hello world"\0 
                            CUR = 11                       
                            LEN = 12

  $a = "hello";           SV = PV(0x80e5b04) at 0x80f9d98  
  Dump $a;                  REFCNT = 1                     
                            FLAGS = (POK,pPOK)             
                            PV = 0x80e9660 "hello"\0       
                            CUR = 5                        
                            LEN = 12</programlisting><para
>The POK flag indicates that the <type
>PV</type> stored in the variable
is valid and can be used. The pPOK flag is related to this but is an
internal flag to indicate to the Magic system (see
<xref
linkend="perlvar.magic"
></xref>) that the PV is valid.</para></sect2><sect2
><title
>SvPVIV - integers</title><para
>In C, it is not possible to store a number or a string in a variable
interchangably. Perl overcomes this restriction by using a data
structure that contains both a string part and an integer part, using
the flags to indicate which part of the structure contains valid data.
The name <type
>SvPVIV</type> indicates that the structure contains a
string (PV) and an integer (IV) and is simply an <type
>SvPV</type>
with an extra integer field.</para><programlisting
format="linespecific"
>    ANY   =&gt; { PVX  =&gt;  ''
               CUR  =&gt;  0,
               LEN  =&gt;  0,
               IVX  =&gt;  52,
             }
    FLAGS =&gt; IOK | pIOK | IsUV   &lt;--- Integer OK and is an unsigned value</programlisting><para
>This structure introduces three flags. The IOK and pIOK flags indicate
that the <varname
>IVX</varname> field is valid (in the same way that
POK and pPOK indicate that the string part is valid) and the IsUV flag
indicates that the integer part is unsigned (a UV) rather than signed
(an IV).  This is useful in cases where a large positive integer is
required (such as inside loops) since a UV has twice the positive
range of a signed integer and is the default state when a new variable
is created that contains a positive integer.</para><para
>When a string value is requested (using the <function
moreinfo="none"
>SvPV</function>
function) the integer is converted to a string representation and
stored in the <varname
>PVX</varname> field and the POK and pPOK flags
are set to true to prevent the conversion happening every time a string
is requested.</para><programlistingco
><areaspec
><areaset
coords="6"
id="perlvar.1"
><area
coords="6"
id="perlvar.1.flags"
></area><area
coords="7"
id="perlvar.1.uv"
></area></areaset><areaset
coords="12"
id="perlvar.2"
><area
coords="12"
id="perlvar.2.flags"
></area><area
coords="14"
id="perlvar.2.pv"
></area></areaset><areaset
coords="20"
id="perlvar.3"
><area
coords="20"
id="perlvar.3.uvflags"
></area><area
coords="21"
id="perlvar.3.iv"
></area><area
coords="22"
id="perlvar.3.pv"
></area></areaset></areaspec><programlisting
format="linespecific"
> use Devel::Peek;

 $a = 5;
 Dump $a;                        SV = IV(0x80f0b28) at 0x80f9d0c
                                   REFCNT = 1
                                   FLAGS = (IOK,pIOK,IsUV)
                                   UV = 5
 # string comparison
 print "yes" if $a eq "hello";
 Dump $a;                        SV = PVIV(0x80e5f50) at 0x80f9d0c
                                   REFCNT = 1
                                   FLAGS = (IOK,POK,pIOK,pPOK,IsUV)
                                   UV = 5
                                   PV = 0x80e9660 "5"\0
                                   CUR = 1
 # Copy in a new string            LEN = 2
 $a = "hello";
 Dump $a;                        SV = PVIV(0x80e5f50) at 0x80f9d0c
                                   REFCNT = 1
                                   FLAGS = (POK,pPOK)
                                   IV = 5
                                   PV = 0x80e9660 "hello"\0
                                   CUR = 5
                                   LEN = 6</programlisting><calloutlist
><callout
arearefs="perlvar.1"
><para
>Initially the SV simply contains a UV and a flag
	    indicating that the integer part of the SV is okay.</para></callout><callout
arearefs="perlvar.2"
><para
>The string comparison forces the SV to be
	    stringified. This results in an upgrade to a PVIV, the POK
	    flag is set to true in addition to the IOK flag and a
	    string representation of the number stored in the PV slot.</para></callout><callout
arearefs="perlvar.3"
><para
>The string part is modified so the integer part is
	    now invalid. The IOK flag is unset but the IV retains its
	    value.</para></callout></calloutlist></programlistingco></sect2><sect2
><title
>SvPVNV - floating point numbers</title><para
>For the same reason that a C variable can not contain a string and an
integer, it can not contain a floating point value either. This is
overcome simply by adding a floating point field to an <type
>SvPVIV</type>.</para><programlisting
format="linespecific"
>    ANY   =&gt; { PVX  =&gt;  ''
               CUR  =&gt;  0,
               LEN  =&gt;  0,
               IVX  =&gt;  0,
               NVX  =&gt;  54.5e20
             }
    FLAGS =&gt; NOK | pNOK       &lt;----- Number OK</programlisting><para
>As for the other types, previous settings for the string and integer
parts are retained as the variable evolves, even if they are no longer valid.</para><programlisting
format="linespecific"
> use Devel::Peek;
 $a = "hello world";
 $a = 5;
 $a += 0.5;
 Dump $a;</programlisting><para
>gives:</para><screen
format="linespecific"
><computeroutput
moreinfo="none"
> SV = PVNV(0x80e65c0) at 0x80f9c00
  REFCNT = 1
  FLAGS = (NOK,pNOK)
  IV = 5
  NV = 5.5
  PV = 0x80e9660 "hello world"\0
  CUR = 11
  LEN = 12</computeroutput></screen><para
>where the IV and PV parts retain their old values but the NV part is
the only value that is currently valid (as shown by the flags).</para></sect2><sect2
id="ook"
><title
>SvOOK - offset strings</title><para
>In order to improve the speed of character removal from the front of a
string, a special flag is provided (OOK - Offset OK) that allows the
IVX part of the SV to be used to represent an offset in the string
rather than being an integer representation of the string.</para><programlisting
format="linespecific"
>   ANY =&gt;   PVX =&gt;  ..llo world\0
            CUR =&gt;    &lt;-------&gt;
            LEN =&gt;    &lt;---------&gt;
            IVX =&gt;  &lt;&gt;
   FLAGS =&gt; POK | pPOK | OOK  &lt;---- Pointer OK and Offset OK</programlisting><para
>It is not possible for the IOK flag and the OOK flags to be set at the 
same time as the IVX can not be both an offset and a valid number.</para><para
>The use of this flag  is best demonstrated by example:</para><example
><title
>SvOOK example</title><screenco
><areaspec
><area
coords="4"
id="perlvar.ook.eg.aflags"
></area><area
coords="5"
id="perlvar.ook.eg.apv"
></area><areaset
coords=""
id="perlvar.ook.eg.acurlen"
><area
coords="6"
id="perlvar.ook.eg.acur"
></area><area
coords="7"
id="perlvar.ook.eg.alen"
></area></areaset><area
coords="10"
id="perlvar.ook.eg.flags"
></area><area
coords="11"
id="perlvar.ook.eg.iv"
></area><area
coords="12"
id="perlvar.ook.eg.pv"
></area><areaset
coords=""
id="perlvar.ook.eg.curlen"
><area
coords="13"
id="perlvar.ook.eg.cur"
></area><area
coords="14"
id="perlvar.ook.eg.len"
></area></areaset></areaspec><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -MDevel::Peek -e '$a="Hello world"; Dump($a); $a=~s/..//; Dump($a)'</userinput>
SV = PV(0x80f89ac) at 0x8109b94
  REFCNT = 1
  FLAGS = (POK,pPOK)
  PV = 0x8109f88 "Hello world"\0
  CUR = 11
  LEN = 12
SV = PVIV(0x80f8df8) at 0x8109b94
  REFCNT = 1
  FLAGS = (POK,OOK,pPOK)
  IV = 2  (OFFSET)
  PV = 0x8109f8a ( "He" . ) "llo world"\0
  CUR = 9
  LEN = 10
          </screen></screenco><calloutlist
><callout
arearefs="perlvar.ook.eg.aflags"
><para
>Standard flags for a PV</para></callout><callout
arearefs="perlvar.ook.eg.apv"
><para
>The string stored in the PV</para></callout><callout
arearefs="perlvar.ook.eg.acurlen"
><para
>The length of the string and the size of the buffer
allocated for storage.</para></callout><callout
arearefs="perlvar.ook.eg.flags"
><para
>After processing the PV now has an additional flag
(OOK) indicating that offsetting is in effect.</para></callout><callout
arearefs="perlvar.ook.eg.iv"
><para
>This indiciates the real <quote
>start</quote> of the
string. <classname
>Devel::Peek</classname> indicates that this is an offset.</para></callout><callout
arearefs="perlvar.ook.eg.pv"
><para
>This shows the string split into two parts: the
piece that is ignored at the start and the current value.</para></callout><callout
arearefs="perlvar.ook.eg.curlen"
><para
>The length information is now relative to the offset</para></callout></calloutlist></example></sect2></sect1><sect1
id="perlvar.magic"
><title
>Magic Variables - SvPVMG</title><para
>In Perl a magic variable is one in which extra functions are invoked
when the variable is accessed rather than simply retrieving the PV, IV
or NV part of the SV. Examples are tied variables where the
<function
moreinfo="none"
>FETCH</function> and <function
moreinfo="none"
>STORE</function> routines
(plus others) are supplied by the programmer, the
<varname
>%SIG</varname> hash where a signal handler is set on
assignment or the <varname
>$!</varname> variable where the C level
<varname
>errno</varname> variable is read directly. Additionally,
objects make use of magic when they are blessed into a class.</para><screen
format="linespecific"
>   ANY =&gt;  PVX
           CUR
           LEN
           IVX
           NVX
           MAGIC =&gt; { # MAGIC
                      moremagic =&gt; magic
                      virtual    =&gt; virtual table of functions
                      private
                      type
                      flags
                      obj
                      ptr
                      len 
                    }
           STASH =&gt; { Foo::Bar =&gt; {} }</screen><para
>An <type
>SvPVMG</type> magic variables is just like an
<type
>SvPVNV</type> variable except that two extra fields are present
(the structure attached to the <varname
>ANY</varname> field is of type
<type
>xpvmg</type>).  The <varname
>MAGIC</varname> field points to an
additional structure of type <type
>magic</type> and the
<varname
>STASH</varname> field points to a
namespace symbol table relating to the object (stashes are described
later in <xref
linkend="perlvar.stashes"
></xref>). When the <varname
>STASH</varname>
field is set (that is, the SV is blessed into a class) the OBJECT flag
is set.</para><programlisting
format="linespecific"
>  use Devel::Peek;
  $a="bar";
  $obj = bless( \$a, "Foo::Bar");
  Dump $obj;</programlisting><screen
format="linespecific"
> SV = RV(0x80fb704) at 0x80f9d44
   REFCNT = 1
   FLAGS = (ROK)
   RV = 0x80f9d98
   SV = PVMG(0x8102450) at 0x80f9d98
     REFCNT = 2
     FLAGS = (OBJECT,POK,pPOK)
     IV = 0
     NV = 0
     PV = 0x80e9660 "bar"\0
     CUR = 3
     LEN = 4
     STASH = 0x80f9ce4   "Foo::Bar"</screen><para
>The important entries in the magic structure (defined in
<filename
moreinfo="none"
>mg.h</filename>) are the following:</para><variablelist
><varlistentry
><term
>moremagic</term><listitem
><para
>This is simply a pointer to a linked list of additional MAGIC
structures. Multiple MAGIC can be associated with each variable.</para></listitem></varlistentry><varlistentry
><term
>virtual</term><listitem
><para
>This is a pointer to an array of functions. Functions can be present
for retrieving the value (<quote
><function
moreinfo="none"
>get</function></quote>),
setting the value (<quote
><function
moreinfo="none"
>set</function></quote>), determining
the length of the value (<quote
><function
moreinfo="none"
>len</function></quote>),
clearing the variable (<quote
><function
moreinfo="none"
>clear</function></quote>) and
freeing the memory associated with the variable
(<quote
><function
moreinfo="none"
>free</function></quote>). In perl this is equivalent to</para><programlisting
format="linespecific"
>  $virtual = {
        "get" =&gt; \&amp;get, 
        "set" =&gt; \&amp;set, 
        "len" =&gt; \&amp;len,
        "clear" =&gt; \&amp;clear, 
        "free" =&gt; \&amp;free
        };</programlisting></listitem></varlistentry><varlistentry
><term
>obj</term><listitem
><para
>This is some data that can contain a pointer to anything
that is important for the type of magic being implemented. For a tie
this will be an SV of the tied object.</para></listitem></varlistentry><varlistentry
><term
>type</term><listitem
><para
>This is a single character denoting the type of magic implemented.
A value of `P' indicates that the magic is a tied array or hash 
and `q' indicates a tied scalar or filehandle. A value of `~' or `U' 
indicates that the functions in the virtual table have been supplied
by the programmer. An extensive list of the different types can
be found in the <filename
moreinfo="none"
>perlguts</filename> documentation.</para></listitem></varlistentry></variablelist><para
>At least one of the MAGIC flags will be set. The important flags are
GMAGICAL (the SV contains a magic <methodname
>get</methodname> or
<methodname
>len</methodname> method), SMAGICAL (the SV contains a
magic <methodname
>set</methodname> method) or RMAGICAL (the SV
contains some other form of <emphasis
>random</emphasis> magic).</para><para
>We can investigate the properties of magic by seeing what
happens when we tie a class to a perl variable. The following class
can be used to tie a scalar such that the contents of the blessed
variable increments each time its value is retrieved:</para><programlistingco
><areaspec
><area
coords="1"
id="var.tie.foo"
></area><area
coords="3"
id="var.tie.tiescalar"
></area><area
coords="4"
id="var.tie.foo1"
></area><area
coords="5"
id="var.tie.bless"
></area><area
coords="7"
id="var.tie.fetch"
></area><area
coords="8"
id="var.tie.incr"
></area><area
coords="10"
id="var.tie.one"
></area></areaspec><programlisting
format="linespecific"
>package Tie::Foo;

sub TIESCALAR { 
  my $obj="foo1"; 
  return bless(\$obj,"Tie::Foo"); 
}

sub FETCH { 
  ${ $_[0] }++;
}

1;</programlisting><calloutlist
><callout
arearefs="var.tie.foo"
><para
>Declare the name of the current package.</para></callout><callout
arearefs="var.tie.tiescalar"
><para
>This is a special method name reserved by the tie
	  system. It is invoked automatically whenever someone tries
	  to tie a scalar variable to this class.</para></callout><callout
arearefs="var.tie.foo1"
><para
>Create a variable to act as the object and initialise
	  it with a value. It must be a lexical to allow other,
	  independent, variables to be tied.</para></callout><callout
arearefs="var.tie.bless"
><para
>Bless the reference to the scalar variable into the
	  <classname
>Tie::Foo</classname> class.</para></callout><callout
arearefs="var.tie.fetch"
><para
>This is a special method name reserved by the tie
	  system. Perl invokes this method on the object each time the
	  value is required.</para></callout><callout
arearefs="var.tie.incr"
><para
>Return the current value of the object and store the
	  next value in the object. This guarantees that the value
	  first stored in the object (by the constructor) is the first
	  value retrieved.</para></callout><callout
arearefs="var.tie.one"
><para
>If this is a standalone module (as opposed to being
	  some code at the end of a program) we need to return true to
	  indicate to perl that the module has been read
	  successfully.</para></callout></calloutlist></programlistingco><para
>If we now use this class we can dump the contents of the
    tied variable and see how it is organized and how it changes as
    the tie is used. This code ties a variable to class
    <classname
>Tie::Foo</classname> and dumps the results:</para><programlisting
format="linespecific"
>use Devel::Peek;
use Tie::Foo;
tie $a, 'Tie::Foo';

print "Initial state:\n";
Dump $a;

print "\nFirst value: $a\n\n";
print "State after a FETCH:\n";
Dump $a;</programlisting><para
>This is the output:</para><screenco
><areaspec
><area
coords="2"
id="var.magic.dump.pvmg"
></area><area
coords="10"
id="var.magic.dump.type"
></area><area
coords="14"
id="var.magic.dump.svrv"
></area><area
coords="18"
id="var.magic.dump.scalar"
></area><area
coords="20"
id="var.magic.dump.flags"
></area><area
coords="26"
id="var.magic.dump.stash"
></area><area
coords="28"
id="var.magic.dump.firstval"
></area><area
coords="33"
id="var.magic.dump.flags2"
></area><area
coords="36"
id="var.magic.dump.pv"
></area><area
coords="54"
id="var.magic.dump.pv2"
></area></areaspec><screen
format="linespecific"
>Initial state:
SV = PVMG(0x81171f8) at 0x8107b14
  REFCNT = 1
  FLAGS = (GMG,SMG,RMG)
  IV = 0
  NV = 0
  PV = 0
  MAGIC = 0x81000b8
    MG_VIRTUAL = &amp;PL_vtbl_packelem
    MG_TYPE = 'q'
    MG_FLAGS = 0x02
      REFCOUNTED
    MG_OBJ = 0x80f8ae0
    SV = RV(0x810f220) at 0x80f8ae0
      REFCNT = 1
      FLAGS = (ROK)
      RV = 0x81197b4
      SV = PVMG(0x81171d8) at 0x81197b4
        REFCNT = 1
        FLAGS = (PADBUSY,PADMY,OBJECT,POK,pPOK)
        IV = 0
        NV = 0
        PV = 0x8107820 "foo1"\0
        CUR = 4
        LEN = 5
        STASH = 0x811976c	"Tie::Foo"

First value: foo1

State after a FETCH:
SV = PVMG(0x81171f8) at 0x8107b14
  REFCNT = 1
  FLAGS = (GMG,SMG,RMG,pPOK)
  IV = 0
  NV = 0
  PV = 0x81000f8 "foo1"\0
  CUR = 4
  LEN = 5
  MAGIC = 0x81000b8
    MG_VIRTUAL = &amp;PL_vtbl_packelem
    MG_TYPE = 'q'
    MG_FLAGS = 0x02
      REFCOUNTED
    MG_OBJ = 0x80f8ae0
    SV = RV(0x810f220) at 0x80f8ae0
      REFCNT = 1
      FLAGS = (ROK)
      RV = 0x81197b4
      SV = PVMG(0x81171d8) at 0x81197b4
        REFCNT = 1
        FLAGS = (PADBUSY,PADMY,OBJECT,POK,pPOK)
        IV = 0
        NV = 0
        PV = 0x8107820 "foo2"\0
        CUR = 4
        LEN = 5
        STASH = 0x811976c	"Tie::Foo"</screen><calloutlist
><callout
arearefs="var.magic.dump.pvmg"
><para
>The SV is of type <type
>SVMG</type> as expected.</para></callout><callout
arearefs="var.magic.dump.type"
><para
>The magic type is <quote
><literal
moreinfo="none"
>q</literal></quote>
	  to indicate that we have a tied scalar.</para></callout><callout
arearefs="var.magic.dump.svrv"
><para
>This is the reference to the scalar that is being used
	  as the object.</para></callout><callout
arearefs="var.magic.dump.scalar"
><para
>This is the actual scalar
	  (i.e. <varname
>$obj</varname>).</para></callout><callout
arearefs="var.magic.dump.flags"
><para
>The flags indicate that this is a lexical variable
	  that is being used as an object and that contains a valid
	  string.</para></callout><callout
arearefs="var.magic.dump.stash"
><para
>The symbol table associated with this object.</para></callout><callout
arearefs="var.magic.dump.firstval"
><para
>The first value retrieved from <varname
>$a</varname>
	  is the initial value stored by the object
	  constructor.</para></callout><callout
arearefs="var.magic.dump.flags2"
><para
>In addition to the flags indicating magic, the
	  <type
>pPOK</type> flag is now set to indicate that a cached
	  value is available (even though it will be overwritten each
	  time the <methodname
>FETCH</methodname> is invoked.</para></callout><callout
arearefs="var.magic.dump.pv"
><para
>This is the current value for the tied variable.</para></callout><callout
arearefs="var.magic.dump.pv2"
><para
>This is the current value of the string stored in the
	  object itself.</para></callout></calloutlist></screenco></sect1><sect1
id="perlvar.arrays"
><title
>Array Variables</title><para
>A Perl array is an array of scalar variables and at the C level an
Array Value (AV) is fundamentally an array of SV's.  An AV is
implemented by using a structure that is the same as that used for a
<type
>SvPVMG</type> (defined in <filename
moreinfo="none"
>av.h</filename> as type
<type
>xpvav</type>) except that three additional fields are present:</para><variablelist
><varlistentry
><term
>ALLOC</term><listitem
><para
>points to an array of SV's (in fact since this is C it points to
an array of pointers to SV structures [an <type
>SV**</type>]), </para></listitem></varlistentry><varlistentry
><term
>ARYLEN</term><listitem
><para
>	  points to a magic SV that is responsible for dealing with the
	  <varname
>$#array</varname> Perl construct
        </para></listitem></varlistentry><varlistentry
><term
>Flag</term><listitem
><para
>	  an extra array flag variable controlling whether the elements should
	  have their reference counter decremented when the variable is removed
	  from the array (this is normally true but the <varname
>@_</varname>
	  array is an example where this does not happen for example).</para></listitem></varlistentry></variablelist><para
>Also, the first three fields of the structure now have different names 
with <varname
>PVX</varname> becoming <varname
>ARRAY</varname>,
<varname
>CUR</varname> becoming <varname
>FILL</varname> and
<varname
>LEN</varname> becoming <varname
>MAX</varname>.</para><screen
format="linespecific"
>  ANY =&gt; ARRAY          position of first element
         FILL           number of elements in AV - 1
         MAX            total number of elements
         IVX =&gt; not used
         NVX =&gt; not used
         MAGIC
         STASH
         ALLOC =&gt;  Array of SV*  [0,1,2,3,4,5,6,7,8]
         ARYLEN =&gt; Magic SV
         FLAGS</screen><para
>Note that the <varname
>ARRAY</varname> field points to the first valid
element of the Perl array but the <varname
>ALLOC</varname> field
points to the first element of the C array. Usually
<varname
>ARRAY</varname> and <varname
>ALLOC</varname> point to the
same thing but similar to the OOK trick described earlier (<xref
linkend="ook"
></xref>)the <varname
>ARRAY</varname> field can be used to
efficiently shift elements off the array without adjusting memory
requirements simply by incrementing the pointer. Similarly, elements
can be popped off the top of the array by decrementing
<varname
>FILL</varname>.</para><example
><title
><classname
>Devel::Peek</classname> of <varname
>@a</varname></title><programlisting
format="linespecific"
>use Devel::Peek;
@a = qw(a b);                         <co
id="perlvar.arr.dump.arr"
></co>
Dump(\@a);</programlisting><calloutlist
><callout
arearefs="perlvar.arr.dump.arr"
><para
>2 element array</para></callout></calloutlist><screen
format="linespecific"
>SV = RV(0x80fb6f8) at 0x80e5910
  REFCNT = 1
  FLAGS = (TEMP,ROK)                  <co
id="perlvar.arr.dump.flags"
></co>
  RV = 0x80f9c90
  SV = PVAV(0x80fcba0) at 0x80f9c90
    REFCNT = 2                        <co
id="perlvar.arr.dump.refcnt"
></co>
    FLAGS = ()
    IV = 0
    NV = 0
    ARRAY = 0x80ec048
    FILL = 1                          <co
id="perlvar.arr.dump.fill"
></co>
    MAX = 3                           <co
id="perlvar.arr.dump.max"
></co>
    ARYLEN = 0x0                      <co
id="perlvar.arr.dump.arylen"
></co>
    FLAGS = (REAL)
    Elt No. 0
    SV = PV(0x80e5b04) at 0x80e5838   <co
id="perlvar.arr.dump.elt0"
></co>
      REFCNT = 1
      FLAGS = (POK,pPOK)
      PV = 0x80faaa8 "a"\0
      CUR = 1
      LEN = 2
    Elt No. 1
    SV = PV(0x80e5b28) at 0x80e58c8   <co
id="perlvar.arr.dump.elt1"
></co>
      REFCNT = 1
      FLAGS = (POK,pPOK)
      PV = 0x80f4820 "b"\0
      CUR = 1
      LEN = 2</screen><calloutlist
><callout
arearefs="perlvar.arr.dump.flags"
><para
>These flags indicate that the SV passed to the
<function
moreinfo="none"
>Dump</function> function is a reference to another SV and
that it is temporary.</para></callout><callout
arearefs="perlvar.arr.dump.refcnt"
><para
>The reference count is 2 because there is one reference from
<varname
>@a</varname> itself and one from the reference passed to
<function
moreinfo="none"
>Dump</function>.</para></callout><callout
arearefs="perlvar.arr.dump.fill"
><para
>Index of highest entry.</para></callout><callout
arearefs="perlvar.arr.dump.max"
><para
>Highest index that can be stored without allocating more memory.</para></callout><callout
arearefs="perlvar.arr.dump.arylen"
><para
>This pointer is null until <varname
>$#</varname> is used for this array.</para></callout><callout
arearefs="perlvar.arr.dump.elt0"
><para
>This is the first element: an <type
>SvPV</type> containing the letter
<quote
>a</quote>.</para></callout><callout
arearefs="perlvar.arr.dump.elt1"
><para
>This is the second element: an <type
>SvPV</type> containing the letter
<quote
>b</quote>.</para></callout></calloutlist></example></sect1><sect1
id="perlvar.hashes"
><title
>Hashes</title><para
>Hashes (HV's) are the most complex data structure inside Perl and are
used by many parts of the internals. There is no equivalent to an
associative array in C so a Perl hash is implemented as an array. A
simple associative array could be arranged as an array where
alternating elements are the key and the value and indeed this is one
way of populating a hash in Perl:</para><programlisting
format="linespecific"
>%hash = ( 'key1', 'value1', 'key2', 'value2'); </programlisting><para
>The problem with this approach is that value retrieval
is very inefficient for large hashes since the entire array must
be searched in order to find the correct key:</para><programlisting
format="linespecific"
>for ($i=0; $i&lt;= $#arr; $i+=2) {
  return $arr[$i+1] if $arr[$i] eq $key;
}</programlisting><para
>A more efficient approach is to translate the key into an array index
which would result in a hash lookup that is almost as fast as an array
lookup. The number generated from the key is called a
<firstterm
>hash</firstterm> and this gives the data structure its
name. In Perl 5.6 a hash number is generated for each key using the
following algorithm (the specific algorithm is modified slightly as
perl versions change):</para><programlisting
format="linespecific"
>use integer;
$hash = 0;
foreach my $i ( 0..(length($key)-1)) {
    $hash = $hash * 33 + ord( substr($key,$i,1) );
}
$hash += ( $hash &gt;&gt; 5 );</programlisting><para
>Of course, the Perl internals version is written in C.</para><para
>In general this hash number is very large and is translated into an
index by calculating the bitwise AND of this hash number and the index
of the largest entry of the array (the size of the array minus one
since the index starts counting at zero):</para><programlisting
format="linespecific"
>$index = $hash &amp; $#array;</programlisting><para
>Since the array sizes used for hashes are always chosen to be a number
2<superscript
>N</superscript>-1 (a binary number containing all 1's)
this guarantees that the index will be between 0 and the maximum
allowed value. Unfortunately, this technique does
<emphasis
>not</emphasis> guarantee that the index will be unique for a
given hash number as only some of the bits from the hash number are
used in the comparison. This problem is overcome by chaining together
hash entries with the same index such that each hash entry with the
same index has a data field containing a reference to the next field
in the list.  When searching for a specific key the algorithm is
modified slightly so that it first determines the index from the hash
and then goes through the chain (known as a <firstterm
>linked
list</firstterm>) until the correct key is found; still much faster
than searching every entry since the search is reduced simply to those
entries with a shared index. This technique is called
<firstterm
>collisional hashing</firstterm> since a single index is not
unique.</para><screen
format="linespecific"
> [diagram of the array with hash entries]

   KEYS =&gt; Number of keys in hash (4 in this case)
   FILL =&gt; Number of slots occupied in array (2 in this case)
   MAX  =&gt; Size of array (7 in this case)
   ARRAY =&gt;   0  1  2  3  4  5  6  7
                 |        |
                 HE1      HE2
                            |
                          HE3
                            |
                          HE4</screen><para
>A hash entry (HE) has the following structure:</para><programlisting
format="linespecific"
>$HE = {
       NEXT =&gt; $HE_next,          <co
id="perlvar.hash.he.next"
></co>
       HEK  =&gt; {                  <co
id="perlvar.hash.he.hek"
></co>
                HASH =&gt; $hash,
                LEN  =&gt; length($key),
                KEY  =&gt; $key,
               }
       VAL  =&gt; $SV,               <co
id="perlvar.hash.he.val"
></co>
      };</programlisting><calloutlist
><callout
arearefs="perlvar.hash.he.next"
><para
>Pointer to the next hash entry in the list</para></callout><callout
arearefs="perlvar.hash.he.hek"
><para
>Hash Entry Key structure. This is purely a function of the hash
key and therefore does not change across hashes.</para></callout><callout
arearefs="perlvar.hash.he.val"
><para
>SV containing the actual value of the hash entry</para></callout></calloutlist><para
>In a perfect hash the number of hash entries matches the size of the
array and none of them point to other hash entries.  If the number of
elements in the list exceeds the size of the array the assumption is
that too many of the elements are in linked lists, where key searches
will take too long, rather than evenly spread throughout the array.
When this occurs the size of the array is doubled and the index of
every hash entry recalculated. This does not involve recalculating the
hash number for each element (since that simply involves the key
itself) only recalculating the index which is the bitwise AND of the
hash number and the new array size. If you are going to be inserting
large numbers of keys into a hash it is usually more efficient to
pre-allocate the array as this prevents many reorganizations as the
array increases in size. From Perl this can be done using the
<function
moreinfo="none"
>keys</function> function:</para><programlisting
format="linespecific"
>keys %h = 1000;</programlisting><para
>In the following dump, the keys have different hash numbers but
translate to the same index (when the max size of the array is 7). </para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -MDevel::Peek -e 'Dump({AF=&gt;"hello",a=&gt;52})'</userinput>
SV = RV(0x80fbab8) at 0x80e5748
  REFCNT = 1
  FLAGS = (TEMP,ROK)
  RV = 0x80e5838
  SV = PVHV(0x80fd540) at 0x80e5838
    REFCNT = 2
    FLAGS = (SHAREKEYS)                      <co
id="perlvar.hash.dump.flags"
></co>
    IV = 2
    NV = 0
    ARRAY = 0x80eba08  (0:7, 2:1)            <co
id="perlvar.hash.dump.freq"
></co>
    hash quality = 75.0%                     <co
id="perlvar.hash.dump.qual"
></co>
    KEYS = 2                                 <co
id="perlvar.hash.dump.keys"
></co>
    FILL = 1                                 <co
id="perlvar.hash.dump.fill"
></co>
    MAX = 7                                  <co
id="perlvar.hash.dump.max"
></co>
    RITER = -1
    EITER = 0x0
    Elt "a" HASH = 0x64                      <co
id="perlvar.hash.dump.elt1"
></co>
    SV = IV(0x80f0b98) at 0x80e594c
      REFCNT = 1
      FLAGS = (IOK,pIOK,IsUV)
      UV = 52
    Elt "AF" HASH = 0x8ec                    <co
id="perlvar.hash.dump.elt2"
></co>
    SV = PV(0x80e5b04) at 0x80e5904
      REFCNT = 1
      FLAGS = (POK,pPOK)
      PV = 0x80faa98 "hello"\0
      CUR = 5
      LEN = 6</screen><calloutlist
><callout
arearefs="perlvar.hash.dump.flags"
><para
>This flag indicates that the keys (the HEK structures) should be
stored in a location visible to all hashes
(<varname
>PL_strtab</varname>)</para></callout><callout
arearefs="perlvar.hash.dump.freq"
><para
>The bracketed numbers indicate how the hash is populated. In this
example there are 7 slots in the array with 0 hash entries and one
slot with 2 entries.</para></callout><callout
arearefs="perlvar.hash.dump.qual"
><para
>Measure of the hash efficiciency. This number attempts to
reflect how well filled the hash is. If many hash entries share the
same slot this number is less than 100%.</para></callout><callout
arearefs="perlvar.hash.dump.keys"
><para
>Total number of keys stored in the hash</para></callout><callout
arearefs="perlvar.hash.dump.fill"
><para
>Number of slots filled in the array.</para></callout><callout
arearefs="perlvar.hash.dump.max"
><para
>Current size of the array</para></callout><callout
arearefs="perlvar.hash.dump.elt1"
><para
>Description of SV stored using key <quote
>a</quote>. The hash value
is <literal
moreinfo="none"
>0x64</literal> in hex which translates to slot 4 when the
hash has a size of 7.</para></callout><callout
arearefs="perlvar.hash.dump.elt2"
><para
>Description of SV stored using key <quote
>AF</quote>. The hash
value is <literal
moreinfo="none"
>0x8ec</literal> in hex which translates to slot 4
when the hash has a size of 7.</para></callout></calloutlist><para
>The <varname
>RITER</varname> and <varname
>EITER</varname> fields are
used to keep track of position when looping through the hash (for
example with the <function
moreinfo="none"
>each</function> or
<function
moreinfo="none"
>keys</function> functions). <varname
>EITER</varname>
contains a pointer to the current hash entry and
<varname
>RITER</varname> contains the array index of that entry. The
next hash entry is then determined by first looking in the HE for the
next entry in the linked list and if that is not defined incrementing
<varname
>RITER</varname> and looking into the array until another hash
entry is found.</para><para
>Since a particular hash key <emphasis
>always</emphasis> translates to
the same hash number, if the <varname
>SHAREKEYS</varname> flag is set
Perl uses an internal table (called <varname
>PL_strtab</varname>) to
store every hash key (HEK structure) currently in use. The key is only
removed from the table when the last reference to it is removed. This
feature is especially useful when using object-oriented programming
since each instance of a hash object will only use a single set of
keys.</para></sect1><sect1
id="perlvar.gv"
><title
>Globs</title><para
>In Perl a <firstterm
>glob</firstterm> provides a way of accessing
package variables that share the same name. Whereas globs were
important in earlier versions of perl the design of Perl5 has meant
that they are hardly ever required by Perl programmers doing
<emphasis
>normal</emphasis> tasks. In fact, as of version 5.6.0 of
perl it is no longer even required to know that filehandles are
globs<footnote
><para
>In perl5.6.0 it is now possible to say
<userinput
moreinfo="none"
>open my $fh, $file</userinput> and treat
<varname
>$fh</varname> as a normal scalar variable.</para></footnote>
Globs are required in order to understand the internal representation
of variables and this section describes how they are implemented.</para><para
>A glob variable is based on the structure of magic variable (see <xref
linkend="perlvar.magic"
></xref>) with the addition of fields for storing the name
of the glob (<varname
>NAME</varname> and <varname
>NAMELEN</varname>),
the namespace of the glob (<varname
>GvSTASH</varname>) and the shared
glob information (<varname
>GP</varname>):</para><screenco
><areaspec
><area
coords="2"
id="perlvar.gv.dump.pvgv"
></area><area
coords="4"
id="perlvar.gv.dump.flags"
></area><area
coords="8"
id="perlvar.gv.dump.mgv"
></area><area
coords="9"
id="perlvar.gv.dump.mgt"
></area><area
coords="11"
id="perlvar.gv.dump.name"
></area><area
coords="13"
id="perlvar.gv.dump.gvstash"
></area><area
coords="14"
id="perlvar.gv.dump.gp"
></area><area
coords="15"
id="perlvar.gv.dump.gp.sv"
></area><area
coords="16"
id="perlvar.gv.dump.gp.refcnt"
></area><area
coords="17"
id="perlvar.gv.dump.gp.io"
></area><area
coords="18"
id="perlvar.gv.dump.gp.form"
></area><area
coords="19"
id="perlvar.gv.dump.gp.av"
></area><area
coords="20"
id="perlvar.gv.dump.gp.hv"
></area><area
coords="21"
id="perlvar.gv.dump.gp.cv"
></area><area
coords="24"
id="perlvar.gv.dump.gp.line"
></area><area
coords="25"
id="perlvar.gv.dump.gp.file"
></area><area
coords="27"
id="perlvar.gv.dump.gp.egv"
></area></areaspec><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -MDevel::Peek -e 'Dump(*a)'</userinput>
SV = PVGV(0x8111678) at 0x810cd34
  REFCNT = 2
  FLAGS = (GMG,SMG)
  IV = 0
  NV = 0
  MAGIC = 0x81116e8
    MG_VIRTUAL = &amp;PL_vtbl_glob
    MG_TYPE = '*'
    MG_OBJ = 0x810cd34
  NAME = "a"
  NAMELEN = 1
  GvSTASH = 0x81004f4	"main"
  GP = 0x81116b0
    SV = 0x810cce0
    REFCNT = 1
    IO = 0x0
    FORM = 0x0
    AV = 0x0
    HV = 0x0
    CV = 0x0
    CVGEN = 0x0
    GPFLAGS = 0x0
    LINE = 1
    FILE = "-e"
    FLAGS = 0x0
    EGV = 0x810cd34	"a"
</screen><calloutlist
><callout
arearefs="perlvar.gv.dump.pvgv"
><para
>A glob structure is called a PVGV.</para></callout><callout
arearefs="perlvar.gv.dump.flags"
><para
>These flags indicate that set and get magic are
	  available.</para></callout><callout
arearefs="perlvar.gv.dump.mgv"
><para
>This is the name of the table containing the glob
	  <function
moreinfo="none"
>get</function>/<function
moreinfo="none"
>set</function>
	  functions.</para></callout><callout
arearefs="perlvar.gv.dump.mgt"
><para
>The type of magic is <quote
>*</quote> indicating that
	  this is a glob.</para></callout><callout
arearefs="perlvar.gv.dump.name"
><para
>This is the name of the glob. All package variables of
	  this name will be contained in this glob.</para></callout><callout
arearefs="perlvar.gv.dump.gvstash"
><para
>This is the namespace to which this glob belongs. Each
	  namespace has its own set of globs. Package variables are
	  implemented using globs and stashes. Stashes are discussed
	  in <xref
linkend="perlvar.stashes"
></xref>.</para></callout><callout
arearefs="perlvar.gv.dump.gp"
><para
>The GP structure can be shared between one or more
	  GV's. This structure contains the variable information
	  specific to a particular glob. They are separate so that
	  multiple GV's can share a single GP in order to implement
	  variable aliasing.</para></callout><callout
arearefs="perlvar.gv.dump.gp.sv"
><para
>This contains a reference to the SV stored in
	  <varname
>$a</varname>.</para></callout><callout
arearefs="perlvar.gv.dump.gp.refcnt"
><para
>The reference count of the GP structure. This
	  increases each time a variable is aliased.</para></callout><callout
arearefs="perlvar.gv.dump.gp.io"
><para
>This contains a reference to the filehandle stored in
	  <varname
>a</varname>. This is currently set to
	  <literal
moreinfo="none"
>0x0</literal> indicating that there is no
	  filehandle of this name.</para></callout><callout
arearefs="perlvar.gv.dump.gp.form"
><para
>This contains a reference to the format stored in
	  <varname
>a</varname>. This is currently set to
	  <literal
moreinfo="none"
>0x0</literal> indicating that there is no format of
	  this name.</para></callout><callout
arearefs="perlvar.gv.dump.gp.av"
><para
>This contains a reference to the array stored in
	  <varname
>@a</varname>. This is currently set to
	  <literal
moreinfo="none"
>0x0</literal> indicating that there is no array of
	  this name.</para></callout><callout
arearefs="perlvar.gv.dump.gp.hv"
><para
>This contains a reference to the hash stored in
	  <varname
>%a</varname>. This is currently set to
	  <literal
moreinfo="none"
>0x0</literal> indicating that there is no hash of
	  this name.</para></callout><callout
arearefs="perlvar.gv.dump.gp.cv"
><para
>This contains a reference to the subroutine stored in
	  <varname
>&amp;a</varname>. This is currently set to
	  <literal
moreinfo="none"
>0x0</literal> indicating that there is no
	  subroutine of this name.</para></callout><callout
arearefs="perlvar.gv.dump.gp.line"
><para
>This is the line number of the file where the glob
	  first occurred.</para></callout><callout
arearefs="perlvar.gv.dump.gp.file"
><para
>This is the name of the file that declared the
	  glob.</para></callout><callout
arearefs="perlvar.gv.dump.gp.egv"
><para
>This is the name and reference of the glob that
	  created this GP structure. This is used to keep track of the
	  original variable name after aliasing.</para></callout></calloutlist></screenco><para
><xref
linkend="perlvar.glob"
></xref> further illustrates how globs work by showing
how aliasing affects the glob structure:</para><example
id="perlvar.glob"
><title
>Glob aliasing</title><programlistingco
><areaspec
><areaset
coords=""
id="perlvar.gv.dump2.prog.var"
><area
coords="2"
id="perlvar.gv.dump2.prog.io"
></area><area
coords="3"
id="perlvar.gv.dump2.prog.sv"
></area><area
coords="4"
id="perlvar.gv.dump2.prog.av"
></area><area
coords="5"
id="perlvar.gv.dump2.prog.cv"
></area></areaset><area
coords="6"
id="perlvar.gv.dump2.prog.alias"
></area></areaspec><programlisting
format="linespecific"
>use Devel::Peek;
open(A,"/dev/null");
$A = 5;
@A = (2,3,4);
sub A { 1; }
*b = *A;
Dump(*b);</programlisting><calloutlist
><callout
arearefs="perlvar.gv.dump2.prog.var"
><para
>Use the variable named <varname
>A</varname> to store different perl types.</para></callout><callout
arearefs="perlvar.gv.dump2.prog.alias"
><para
>Make <varname
>b</varname> an alias of <varname
>A</varname>.</para></callout></calloutlist></programlistingco><screenco
><areaspec
><area
coords="2"
id="perlvar.gv.dump2.refcnt"
></area><area
coords="3"
id="perlvar.gv.dump2.flags"
></area><area
coords="11"
id="perlvar.gv.dump2.mgp"
></area><area
coords="12"
id="perlvar.gv.dump2.name"
></area><area
coords="17"
id="perlvar.gv.dump2.gp.refcnt"
></area><areaset
coords=""
id="perlvar.gv.dump2.gp.vars"
><area
coords="18"
id="perlvar.gv.dump2.gp.io"
></area><area
coords="20"
id="perlvar.gv.dump2.gp.av"
></area><area
coords="22"
id="perlvar.gv.dump2.gp.cv"
></area></areaset><area
coords="28"
id="perlvar.gv.dump2.gp.egv"
></area></areaspec><screen
format="linespecific"
>SV = PVGV(0x81082b0) at 0x811a0d8
  REFCNT = 3
  FLAGS = (GMG,SMG,MULTI)
  IV = 0
  NV = 0
  MAGIC = 0x8108718
    MG_VIRTUAL = &amp;PL_vtbl_glob
    MG_TYPE = '*'
    MG_OBJ = 0x811a0d8
    MG_LEN = 1
    MG_PTR = 0x8108738 "b"
  NAME = "b"
  NAMELEN = 1
  GvSTASH = 0x80f8608	"main"
  GP = 0x810a350
    SV = 0x81099d0
    REFCNT = 2
    IO = 0x8104664
    FORM = 0x0  
    AV = 0x8109a30
    HV = 0x0
    CV = 0x811a0f0
    CVGEN = 0x0
    GPFLAGS = 0x0
    LINE = 2
    FILE = "glob.pl"
    FLAGS = 0x2
    EGV = 0x8104598	"A"
</screen><calloutlist
><callout
arearefs="perlvar.gv.dump2.refcnt"
><para
>This is the reference count of the GV <varname
>*b</varname> and
is distinct from GV <varname
>*A</varname>. This has 3 references to
it: one in the main program, one from the argument passed to
<function
moreinfo="none"
>Dump&gt;</function> and ...<remark
>there always seems to be at
least 2 so what is the first reference? Presumably it is from the symbol
table itself although surely *A covers that.</remark></para></callout><callout
arearefs="perlvar.gv.dump2.flags"
><para
>In addition to the flags decribed previously there is an additional
flag to indicate that more than one variable is stored in the glob.</para></callout><callout
arearefs="perlvar.gv.dump2.mgp"
><para
>This is the name of the glob associated with the magic structure.</para></callout><callout
arearefs="perlvar.gv.dump2.name"
><para
>This is the name of the GV that is being listed.</para></callout><callout
arearefs="perlvar.gv.dump2.gp.refcnt"
><para
>Reference count of this GP structure. In this case it is being used by
<varname
>*A</varname> and <varname
>*b</varname> so the reference count
is 2.</para></callout><callout
arearefs="perlvar.gv.dump2.gp.vars"
><para
>Pointers to the variables that were created using this package name.
There is a scalar, a filehandle, an array and a subroutine all
sharing a name.</para></callout><callout
arearefs="perlvar.gv.dump2.gp.egv"
><para
>The name of the first GV to use this GP. In this case <varname
>A</varname>.</para></callout></calloutlist></screenco></example></sect1><sect1
id="perlvar.stashes"
><title
>Namespaces - Stashes</title><para
>Namespaces are used by Perl to separate global variables into
groups. Each global variable used by Perl belongs to a namespace. The
default namespace is <varname
>main::</varname><footnote
><para
>In all
cases the <varname
>main::</varname> namespace can be abbreviated simply to
<varname
>::</varname></para></footnote> (compare this with the
<function
moreinfo="none"
>main</function> in C) and all globals belong to this
namespace unless the <function
moreinfo="none"
>package</function> keyword has been
used or unless a namespace is explcitly specified:</para><programlistingco
><areaspec
><area
coords="1"
id="perlvar.stash.bar"
></area><areaset
coords=""
id="perlvar.stash.foo.bar"
><area
coords="2"
id="perlvar.stash.foo.bar.main"
></area><area
coords="5"
id="perlvar.stash.foo.bar.foobar"
></area></areaset></areaspec><programlisting
format="linespecific"
>$bar = "hello";
$Foo::bar = 3;

package Foo;
$bar = 2;
      </programlisting><calloutlist
><callout
arearefs="perlvar.stash.bar"
><para
>Sets <varname
>$main::bar</varname></para></callout><callout
arearefs="perlvar.stash.foo.bar"
><para
>Sets <varname
>$Foo::bar</varname></para></callout></calloutlist></programlistingco><para
>Internally, namespaces are stored in <firstterm
>symbol table
hashes</firstterm> that are called <firstterm
>stashes</firstterm>.
They are implemented exactly as the name suggests. Each namespace (or
symbol table) is made up of a hash where the keys of the hash are the
variable names present in the namespace and the values are GVs
containing all the variables that share that name. Stashes can also
contain references to stashes in related namespaces by using the hash
entry in the GV to point to another stash; Perl assumes that any stash
key ending in <varname
>::</varname> indicates a reference to another
stash. The root symbol table is called <varname
>defstash</varname> and
contains <varname
>main::</varname>. In order to look up variable
<varname
>$a</varname> in package Foo::Bar the following occurs:</para><orderedlist
inheritnum="ignore"
continuation="restarts"
><listitem
><para
>Starting from <varname
>defstash</varname> look up
<varname
>Foo::</varname> in the <varname
>main::</varname> stash. This
points to the <varname
>Foo::</varname> glob.</para></listitem><listitem
><para
>Now look up the HV entry in the glob. This points to the
<varname
>Foo::</varname> stash.</para></listitem><listitem
><para
>Look up <varname
>Bar::</varname> in this stash to
retrieve the GV containing the hash for this stash.</para></listitem><listitem
><para
>Look up <varname
>a</varname> in the
<varname
>Bar::</varname> hash to get the glob.</para></listitem><listitem
><para
>Dereference the required SV.</para></listitem></orderedlist><para
>As you can see, finding package variables in nested namespaces has a
large overhead!  <remark
>There is an excellent diagram of this in
illguts</remark> One final thing to note about hashes is that Perl
does not hide the implementation details. The symbol table hashes can
be listed just like any other Perl hash:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -e '$Foo::bar = 2; print $Foo::{bar},"\n"'</userinput>
*Foo::bar</screen><para
>Here the <varname
>bar</varname> entry in the hash
<varname
>%Foo::</varname> is a glob named <varname
>Foo::bar</varname>
that contains the scalar variable that has a value of
<literal
moreinfo="none"
>2</literal>.  This can be proven by aliasing this hash to
another glob: </para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -e '$Foo::bar = 2; *x = $Foo::{bar}; print "$x\n"'</userinput>
2</screen><remark
>Do we mention how locals work? This probably comes under
discussion of stacks and ops</remark></sect1><sect1
id="perlvar.my"
><title
>Lexical <quote
>my</quote> variables</title><para
>Lexical variables are associated with code blocks rather than
namespaces so they are implemented in a very different way to globals.
Each code block (a CV, see <xref
linkend="perlvar.cv"
></xref>) contains a
reference to an array (an AV) of scratch pads. This array is called a
<firstterm
>padlist</firstterm>. The first entry in this padlist is a
scratch pad (also an AV) that lists all the lexical variables used by
the block (not just those that were declared in the block). The names
contain the full variable type (i.e. $, %, @) so that
<varname
>$a</varname> and <varname
>@a</varname> have different
entries. The second scratch pad is an array that contains the values
for each of these variables. The main complication occurs with
recursion. Each time a block of code calls itself recursively you need
to make sure that the variables available to the block can not affect
variables in the block that called this one. In order that each
recursive call does not trash the previous contents of the variables
in the scratch pads for that block a new entry in the padlist is
created for each level of recursion.</para><screen
format="linespecific"
>
  CV ----&gt; padlist ----&gt;   [  $a , %a,  $z,  @z ... ]  Lex var names
                    |
                    |--&gt;   [   5 ...                ] scratch pad 1
                    |
                    |--&gt;   [                        ] scratch pad 2
</screen><remark
>This should be a diagram</remark><para
>This layout means that at least 3 <type
>AV</type>'s are required to
implement lexical variables in each code block: one to hold the
variable names, one to hold the values the first set of values, and
one to hold both these arrays and subsequent ones (the padlist and two
scratch pads). Lexical variables are faster than local variables
because the scratch pads are created at compile time (since Perl knows
which variables are to be associated with each block at that point)
and can be accessed directly.</para><remark
>Simon: Robin from London.PM said this, which may
be helpful: It still took me most of a day to *actually* figure
scratchpads out, because APP neglected to mention that the scope of a
lexical was indicated by cop_seq numbers stored in the NV and IV slots
of the name SV.</remark><remark
>Tim: But do we want to talk about cop_seq in here since this is
just explaining organization? Usage comes later</remark></sect1><sect1
id="perlvar.cv"
><title
>Code blocks</title><para
>Subroutines or code blocks in perl are thought of in the same way as
other Perl variables. A Code Value (CV) contains information on Perl
subroutines and the layout is similar to the structure of other
variables with additional fields dealing with issues such as namespace
(<xref
linkend="perlvar.gv"
></xref>), pad lists (<xref
linkend="perlvar.my"
></xref>) and
opcodes (<xref
linkend="internals.optree"
></xref>):</para><screenco
><areaspec
><area
coords="6"
id="perlvar.cv.pvcv"
></area><area
coords="11"
id="perlvar.cv.compstash"
></area><areaset
coords=""
id="perlvar.cv.ops"
><area
coords="12"
id="perlvar.cv.ops.start"
></area><area
coords="13"
id="perlvar.cv.ops.root"
></area></areaset><areaset
coords=""
id="perlvar.cv.xsub"
><area
coords="14"
id="perlvar.cv.xsub.xsub"
></area><area
coords="15"
id="perlvar.cv.xsub.any"
></area></areaset><area
coords="16"
id="perlvar.cv.gv"
></area><area
coords="17"
id="perlvar.cv.gv.file"
></area><area
coords="18"
id="perlvar.cv.depth"
></area><area
coords="19"
id="perlvar.cv.flags"
></area><area
coords="20"
id="perlvar.cv.padlist"
></area></areaspec><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -MDevel::Peek -e 'sub foo {}; Dump(\&amp;foo)'</userinput>
SV = RV(0x8111408) at 0x80f86e0
  REFCNT = 1
  FLAGS = (TEMP,ROK)
  RV = 0x8109b7c
  SV = PVCV(0x811b524) at 0x8109b7c
    REFCNT = 2
    FLAGS = ()
    IV = 0
    NV = 0
    COMP_STASH = 0x80f8608	"main"
    START = 0x8108aa0 ===&gt; 655
    ROOT = 0x810b020
    XSUB = 0x0
    XSUBANY = 0
    GVGV::GV = 0x8109ae0	"main" :: "foo"
    FILE = "-e"
    DEPTH = 0
    FLAGS = 0x0
    PADLIST = 0x8109b28
    OUTSIDE = 0x80f8818 (MAIN)
</screen><calloutlist
><callout
arearefs="perlvar.cv.pvcv"
><para
>The structure is of type <type
>PVCV</type></para></callout><callout
arearefs="perlvar.cv.compstash"
><para
>This is the location and name of the symbol table hash that is
in effect when this subroutine executes. In this example there are no
packages declared and the <varname
>main::</varname> stash is in scope.</para></callout><callout
arearefs="perlvar.cv.ops"
><para
>These items refer to the actual opcodes that are used to
implement the subroutine. These are explained in <xref
linkend="internals.optree"
></xref></para></callout><callout
arearefs="perlvar.cv.xsub"
><para
>When this subroutine represents an external C function
	  these fields contains a pointer to that function and other
	  related information. See <xref
linkend="xsintro"
></xref> for more
	  information on this topic</para></callout><callout
arearefs="perlvar.cv.gv"
><para
>This is a pointer to the GV that contains this
	  subroutine. Recall that a glob can contain references to all
	  the Perl variable types, in this case the GV is named
	  <varname
>*main::foo</varname>.</para></callout><callout
arearefs="perlvar.cv.gv.file"
><para
>The name of the file that defined the subroutine. This
subroutine was created on the command line.</para></callout><callout
arearefs="perlvar.cv.depth"
><para
>This contains the recursion depth of the
subroutine. For each level of recursion this number increments and
this allows the correct entries in the padlist to be retrieved.</para></callout><callout
arearefs="perlvar.cv.flags"
><para
>This is the actual value of the flags field that is
expanded in words at the top of the dump</para></callout><callout
arearefs="perlvar.cv.padlist"
><para
>This is a reference to the padlist containing all the
lexical variables required by this subroutine.</para></callout></calloutlist></screenco><para
>The following flags are of particular interest when examining CVs:</para><variablelist
><varlistentry
><term
>ANON</term><listitem
><para
>Indicates that the subroutine is anonymous
(e.g. <userinput
moreinfo="none"
>$x = sub { 1; };</userinput>). When this flag is set
the GV associated with the CV is meaningless since the subroutine is
not present in any stash.</para></listitem></varlistentry><varlistentry
><term
>LVALUE</term><listitem
><para
>Indicates that the subroutine can be used as an lvalue.</para><programlisting
format="linespecific"
>use Devel::Peek;
$x = 1;
sub foo :lvalue {
  $x;
}
print foo,"\n";
foo = 5;
print foo,"\n";

Dump(\&amp;foo);</programlisting><para
>would show:</para><screenco
><areaspec
><area
coords="1"
id="perlvar.cveg.l1"
></area><area
coords="2"
id="perlvar.cveg.l2"
></area><area
coords="9"
id="perlvar.cveg.flags"
></area><area
coords="18"
id="perlvar.cveg.file"
></area></areaspec><screen
format="linespecific"
>1
5
SV = RV(0x8109998) at 0x8100dec
  REFCNT = 1
  FLAGS = (TEMP,ROK)
  RV = 0x810d4f8
  SV = PVCV(0x8109044) at 0x810d4f8
    REFCNT = 2
    FLAGS = (LVALUE)
    IV = 0
    NV = 0
    COMP_STASH = 0x8100d14	"main"
    START = 0x8113490 ===&gt; 1178
    ROOT = 0x8130d48
    XSUB = 0x0
    XSUBANY = 0
    GVGV::GV = 0x810d4d4	"main" :: "foo"
    FILE = "lvexample.pl"
    DEPTH = 0
    FLAGS = 0x100
    PADLIST = 0x810d528
    OUTSIDE = 0x8109e34 (MAIN)
</screen><calloutlist
><callout
arearefs="perlvar.cveg.l1"
><para
>This shows the initial state of <varname
>$x</varname>.</para></callout><callout
arearefs="perlvar.cveg.l2"
><para
><varname
>$x</varname> now has a value of 5.</para></callout><callout
arearefs="perlvar.cveg.flags"
><para
>The <varname
>LVALUE</varname> flag is now set confirming that
the subroutine can be used as an lvalue.</para></callout><callout
arearefs="perlvar.cveg.file"
><para
>The example was stored in a file so now the
<varname
>FILE</varname> file field contains a proper filename.</para></callout></calloutlist></screenco></listitem></varlistentry></variablelist><remark
>Not sure there is any value in discussing esoteric flags such
as CLONE, CLONED, UNIQUE, METHOD, LOCKED and CONST</remark></sect1><sect1
><title
>Further Reading</title><para
>More detailed information on the structure of perl's internal
data structures can be found at the following locations:</para><variablelist
><varlistentry
><term
>perlguts</term><term
>perlapi</term><listitem
><para
>The main source of Perl internals documentation are the
<filename
moreinfo="none"
>perlguts</filename> and <filename
moreinfo="none"
>perlapi</filename> man
pages that comes with the Perl distribution</para></listitem></varlistentry><varlistentry
><term
>illguts</term><listitem
><para
><ulink
url="http://gisle.aas.no/perl/illguts/"
>Perl Guts Illustrated</ulink>
by Gisle Aas provides an alternative illustrated explanation of the
internal implementation of perl variable types.</para></listitem></varlistentry><varlistentry
><term
><filename
moreinfo="none"
>sv.h</filename></term><term
><filename
moreinfo="none"
>av.h</filename></term><term
><filename
moreinfo="none"
>hv.h</filename></term><term
><filename
moreinfo="none"
>mg.h</filename></term><term
><filename
moreinfo="none"
>cv.h</filename></term><listitem
><para
>This is where all the structures and flags are defined. If you really
want to know the details of what is happening read these C include files
that come with the Perl source.</para></listitem></varlistentry></variablelist></sect1></chapter><chapter
id="api"
><title
>The Perl 5 API</title><para
>    The Perl 5 API is the interface by which your C code is allowed to talk
    to Perl; it provides functions for manipulating variables, for executing
    Perl code and regular expressions, for file handling, memory management
    and so on.
  </para><para
>    The API is also used inside the Perl core as a set of utility functions to
    manipulate the environment which the Perl interpreter provides. It's
    also the building blocks out of which you will create extensions and by
    which you will drive an embedded Perl interpreter from C - hence, the
    functions and macros you learn about here will form the basis of the
    rest of the book.
  </para><para
>    This chapter is a reference to the Perl 5 API, so the example code for
    each function will probably contain uses of other functions not yet
    explained. You are encouraged to jump around the chapter, following
    references to later functions and jumping back to see how they're used
    in real code. 
  </para><para
>    As much as possible, we've tried to make the example code real, rather
    than contrived, taking the code from XS modules and, where possible,
    from the Perl sources or extension modules inside the Perl core.
  </para><sect1
><title
>Sample Entry</title><para
>      Here is the format we will use when introducing functions:
    </para><formalpara
><title
>something <emphasis
>(the name of the function)</emphasis></title><para
>    <funcsynopsis
><funcprototype
><funcdef
>char * <function
moreinfo="none"
>something</function></funcdef><paramdef
>int <parameter
moreinfo="none"
>parameter</parameter></paramdef></funcprototype></funcsynopsis>

A brief explanation of what the function does.

<example
><title
>Using <function
moreinfo="none"
>something</function></title><programlistingco
><areaspec
><area
coords="2"
id="api.test"
></area></areaspec><programlisting
format="linespecific"
>if (testing)
    result = something(whatsit);</programlisting><calloutlist
><callout
arearefs="api.test"
><para
>An explanation of how the function is used here.</para></callout></calloutlist></programlistingco></example></para></formalpara></sect1><sect1
><title
><type
>SV</type> Functions</title><para
>      Before we look at the functions for manipulating <type
>SV</type>s,
      there are certain special values that Perl defines for us.
    </para><sect2
><title
>Special <type
>SV</type>s</title></sect2><sect2
><title
>Creation and Destruction</title></sect2><sect2
id="data"
><title
>Accessing Data</title><remark
>As well as SvIV, Also need sv_setiv et al in here - TJ</remark><remark
>SvTYPE</remark><para
></para></sect2><sect2
><title
>String Functions</title><para
></para></sect2><sect2
><title
>References</title><para
>	Finally, we can also take a reference to a Perl value, with
	the <function
moreinfo="none"
>newRV</function> functions, and dereference them again.
      </para></sect2></sect1><sect1
><title
><type
>AV</type> Functions</title><para
>As we know, <type
>AV</type>s are Perl arrays; this section contains
the functions which we can perform on those arrays.</para><sect2
><title
>Creation and Destruction</title></sect2><sect2
><title
>Manipulating Elements</title><sect3
><title
><function
moreinfo="none"
>av_delete </function></title><funcsynopsis
><funcprototype
><funcdef
>??? <function
moreinfo="none"
>av_delete</function></funcdef><paramdef
>??? <parameter
moreinfo="none"
>??</parameter></paramdef></funcprototype></funcsynopsis><para
></para><example
><title
> ??? </title><para
></para><programlistingco
><areaspec
><area
coords="1"
id="api.av_delete.1"
></area><area
coords="2"
id="api.av_delete.2"
></area><area
coords="3"
id="api.av_delete.3"
></area></areaspec><programlisting
format="linespecific"
></programlisting><calloutlist
><callout
arearefs="api.av_delete.1"
><para
>        </para></callout><callout
arearefs="api.av_delete.2"
><para
>        </para></callout></calloutlist></programlistingco></example><para
>See also: <xref
linkend="api.???"
></xref>,</para></sect3><sect3
><title
><function
moreinfo="none"
>av_exists </function></title><funcsynopsis
><funcprototype
><funcdef
>??? <function
moreinfo="none"
>av_exists</function></funcdef><paramdef
>??? <parameter
moreinfo="none"
>??</parameter></paramdef></funcprototype></funcsynopsis><para
>
<example
><title
> ??? </title><para
></para><programlistingco
><areaspec
><area
coords="1"
id="api.av_exists.1"
></area><area
coords="2"
id="api.av_exists.2"
></area><area
coords="3"
id="api.av_exists.3"
></area></areaspec><programlisting
format="linespecific"
>
          <footnote
><calloutlist
><callout
arearefs="api.av_exists.1"
><para
>        </para></callout><callout
arearefs="api.av_exists.2"
><para
>        </para></callout></calloutlist></footnote></programlisting></programlistingco></example></para><para
>See also: <xref
linkend="api.???"
></xref>,</para></sect3></sect2><sect2
><title
>Testing and Changing Size</title><sect3
><title
><function
moreinfo="none"
>av_fill</function></title><funcsynopsis
><funcprototype
><funcdef
> <function
moreinfo="none"
>av_fill</function></funcdef><paramdef
>AV* <parameter
moreinfo="none"
>av</parameter></paramdef><paramdef
>I32 <parameter
moreinfo="none"
>fill</parameter></paramdef></funcprototype></funcsynopsis><para
></para><example
><title
> ??? </title><para
></para><programlistingco
><areaspec
><area
coords="1"
id="api.av_fill.1"
></area><area
coords="2"
id="api.av_fill.2"
></area><area
coords="3"
id="api.av_fill.3"
></area></areaspec><programlisting
format="linespecific"
></programlisting><calloutlist
><callout
arearefs="api.av_fill.1"
><para
>        </para></callout><callout
arearefs="api.av_fill.2"
><para
>        </para></callout></calloutlist></programlistingco></example><para
>See also: <xref
linkend="api.???"
></xref>,</para></sect3></sect2></sect1><sect1
><title
>HV Functions</title><sect2
><title
>Creation and Destruction</title></sect2><sect2
><title
>Manipulating Elements</title></sect2></sect1><sect1
><title
>Miscellaneous Functions</title><sect2
><title
>Memory Management</title><para
></para><sect3
><title
>StructCopy</title><para
></para></sect3></sect2><sect2
><title
>File Handling</title><para
></para></sect2><sect2
><title
>Unicode Data Handling</title><para
></para></sect2><sect2
><title
>Everything Else</title><para
></para><remark
>The ExtUtils typemap file uses INT2PTR so we have to make sure that is covered somewhere soonish. Not sure what the plan is for this - TJ</remark><sect3
><title
>croak</title><para
></para></sect3></sect2></sect1></chapter><chapter
id="advxs"
><title
>Advanced XS Programming</title><para
>Gluing simple C functions to Perl is fairly straightforward and
requires no special knowledge of the Perl internals. <xref
linkend="xsintro"
></xref>
covers the basics of XS and how to pass in and return values
associated with simple C scalar types. Unfortunately, many functions
and libraries have much more complicated signatures and require more work to
implement a Perl interface.</para><para
>This chapter covers a more advanced use of XS, dealing with
topics such as structures, arrays, and callbacks. This chapter builds
on <xref
linkend="xsintro"
></xref> and will also refer to functions used in
the Perl internals and described in <xref
linkend="api"
></xref>.</para><sect1
id="advxs.pointers"
><title
>Pointers and things</title><para
>Now that we know about pointers and dynamic memory
    allocation we can start doing more interesting things with XS. To
    demonstrate some of these issues we can use the following function
    which concatenates two strings to a third and returns the total
    length of the final string <footnote
><para
>Although why you would
    want to use this function rather than the standard
    <function
moreinfo="none"
>strcat</function> function or
    <function
moreinfo="none"
>sv_catpv</function> from the Perl API is a
    mystery!</para></footnote>.</para><programlisting
format="linespecific"
>#include &lt;string.h&gt;

STRLEN strconcat (char* str1, char* str2, char* outstr) {
   strcpy( outstr, (const char*)str1 );
   strcat( outstr, (const char*)str2 );
   return strlen( outstr );
}</programlisting><para
>We will now write an XS interface to mirror the C calling
    interface. The C signature of:</para><funcsynopsis
><funcprototype
><funcdef
>STRLEN <function
moreinfo="none"
>strconcat</function></funcdef><paramdef
>char  *<parameter
moreinfo="none"
>str1</parameter></paramdef><paramdef
>char  *<parameter
moreinfo="none"
>str2</parameter></paramdef><paramdef
>char  *<parameter
moreinfo="none"
>outstr</parameter></paramdef></funcprototype></funcsynopsis><para
>will then translate to a Perl signature of:</para><funcsynopsis
><funcprototype
><funcdef
>$len = <function
moreinfo="none"
>strconcat</function></funcdef><paramdef
>$str1</paramdef><paramdef
>$str2</paramdef><paramdef
>$outstr</paramdef></funcprototype></funcsynopsis><para
>In this case we could write the XS interface as follows:</para><programlisting
format="linespecific"
>STRLEN
strconcat( str1, str2, outstr )
  char* str1
  char* str2
  char* outstr = NO_INIT
 OUTPUT:
  outstr
  RETVAL</programlisting><para
>Here the <varname
>NO_INIT</varname> keyword is used to tell
    the compiler not to care about the input value of
    <varname
>outstr</varname>.  Remember that we have to tell
    <command
moreinfo="none"
>xsubpp</command> that we want to use the return value
    even though we have specified a return type.</para><para
>Unfortunately, the above code will not work because our
    simple <function
moreinfo="none"
>strconcat</function> function assumes that the
    output string has enough space to hold the concatenated string. In
    the above XS segment <varname
>outstr</varname> is typed as a
    pointer to a string but is not actually pointing to anything! We
    have to fix this by using a <varname
>CODE</varname> block that
    allocates the memory for a string of the required
    size<footnote
><para
>The alternative is to pre-allocate the memory
    inside Perl by passing a string in as the third argument (and
    removing the NO_INIT declaration). The contents of the string will
    then be overwritten by <function
moreinfo="none"
>strconcat</function>. This will
    work but can generate core dumps if the string is not large enough
    to receive the result string. Not
    recommended!</para></footnote></para><programlistingco
><areaspec
><area
coords="6"
id="xsi.preinit"
></area><area
coords="9"
id="xsi.size"
></area><area
coords="10"
id="xsi.new"
></area></areaspec><programlisting
format="linespecific"
>STRLEN
strconcat( str1, str2, outstr )
  char* str1
  char* str2
  char* outstr = NO_INIT
 PREINIT:
  STRLEN length;
 CODE:
  length = strlen( str1 ) + strlen( str2 ) + 1;
  New(0, outstr, length, char );
  RETVAL = strconcat( str1, str2, outstr );
 OUTPUT:
  outstr
  RETVAL</programlisting><calloutlist
><callout
arearefs="xsi.preinit"
><para
>PREINIT is used to declare additional variables</para></callout><callout
arearefs="xsi.size"
><para
>Calculate the size of the required string. Don't forget the extra space for the the null character!</para></callout><callout
arearefs="xsi.new"
><para
>We use <function
moreinfo="none"
>New</function> to allocate the
	    memory rather than <function
moreinfo="none"
>malloc</function> since we
	    have access to the Perl macros. See <xref
linkend="cadv"
></xref>
	    for more details on this function.</para></callout></calloutlist></programlistingco><para
>Now this routine is becoming complicated! The
    <varname
>PREINIT</varname> block is there to initialise additional
    variables that are required for the <varname
>CODE</varname>
    section. <varname
>PREINIT</varname> guarantees that the variable
    declaration will occur as soon as possible after entering the
    function as some compilers do not like declarations after code
    sections have started. It provides a nice way to separate variable
    declarations from code. Even worse, whilst our XS interface will
    now work there is still a problem since each time the routine is
    entered memory is allocated to <varname
>outstr</varname> but it is
    never freed. XS provides a means to tidy up after ourselves by
    using the <varname
>CLEANUP</varname> keyword. The cleanup code is
    guaranteed to run just before the C code returns control to
    Perl. Our XS function should now work without memory
    leaks:</para><programlisting
format="linespecific"
>STRLEN
strconcat( str1, str2, outstr )
  char* str1
  char* str2
  char* outstr = NO_INIT
 PREINIT:
  STRLEN length;
 CODE:
  length = strlen( str1 ) + strlen( str2 ) + 1;
  New(0, outstr, length, char );
  RETVAL = strconcat( str1, str2, outstr );
 OUTPUT:
  outstr
  RETVAL
 CLEANUP:
  Safefree( outstr );</programlisting><para
>This example shows us how to deal with pointer types (in
    this case a simple string) and how to allocate and free memory
    using XS. It also demonstrates the wrong way to approach interface
    design - in a real application the string would be a return value
    (without the length) and would not be returned via the argument
    list. Something like this:</para><programlisting
format="linespecific"
>char *
strconcat( str1, str2 )
  char* str1
  char* str2
 PREINIT:
  STRLEN length;
 CODE:
  length = strlen( str1 ) + strlen( str2 ) + 1;
  New(0, RETVAL, length, char );
  length = strconcat( str1, str2, RETVAL );
 OUTPUT:
  RETVAL
 CLEANUP:
  Safefree( outstr );</programlisting></sect1><sect1
id="advxs.io"
><title
>Filehandles</title><para
>Sometimes an external library needs to print to a
    user-supplied filehandle or, occasionally, opens a file and
    returns a filehandle to the user. If the library uses C
    input/output streams then it is easy to pass the C stream to and
    from perl with XS since by default XS knows how to deal with a
    <type
>FILE*</type>, converting it to and from a perl filehandle.
    The following example could be used to provide an XS interface to
    one of the Gnu readline functions<footnote
><para
>The
    <classname
>Term::ReadLine::Gnu</classname> module has a full
    implementation</para></footnote>:</para><programlisting
format="linespecific"
>int
rl_getc( file )
  FILE * file</programlisting><para
>This example shows that a <type
>FILE*</type> can be treated
    like any other simple type, in this case the filehandle is an
    input argument:</para><programlisting
format="linespecific"
>$retval = rl_getc(FH);</programlisting><para
>but it is just as easy to import a stream into
    perl.</para><remark
>Care must be taken if the external library
    closes an imported file handle without perl knowning - on linux
    this causes a core dump (cf. XS::Typemap)</remark><para
> If your external library requires a file descriptor (see
    <xref
linkend="cadv.fileio"
></xref>) then you will have to use the
    <function
moreinfo="none"
>fileno</function> to extract the file descriptor from
    the file handle or stream (either by using the perl or the C
    <function
moreinfo="none"
>fileno</function> functions).  Similarly, if you are
    importing a file descriptor into Perl you need to convert it to a
    filehandle either by using the <function
moreinfo="none"
>fdopen</function> C
    function (if you are comfortable with XS and C) or by importing
    the descriptor into perl as an integer and then using Perl's
    <function
moreinfo="none"
>open</function> command<footnote
><para
>or even
    <userinput
moreinfo="none"
>IO::Handle-&gt;new_from_fd()</userinput></para></footnote>
    to translate it. </para><programlisting
format="linespecific"
>$fd = some_xs_function();
open(FH, "&lt;&amp;=$fd");</programlisting><para
>From version 5.7.1 of Perl the I/O subsystem is completely
    self-contained and no longer relies on the underlying operating
    system for implementation. Perl itself uses a <type
>PerlIO*</type>
    rather than a <type
>FILE*</type> for all I/O operations (although
    in some cases a <type
>PerlIO*</type> can be the same as a
    <type
>FILE*</type> you can't rely on it). If you are using I/O in
    your XS code but you are not using an external library then you
    should be using <type
>PerlIO*</type> in preference to a
    <type
>FILE*</type>. Of course, a <type
>PerlIO*</type> is
    recognised automatically by XS.</para></sect1><sect1
id="advxs.typemaps"
><title
>Typemaps</title><para
>When a variable is passed from Perl to C (or from C to Perl)
    it must be translated from a Perl scalar variable (<xref
linkend="perlvar"
></xref>) to the correct type expected by the C
    function. So far this translation has been implicitly assumed to
    be something that <quote
>just happens</quote> but before we can
    move further into XS we have to explain <emphasis
>how</emphasis>
    it happens.</para><para
>The XS compiler (<command
moreinfo="none"
>xsubpp</command>) uses a lookup
    table, called a <firstterm
>typemap</firstterm>, to work out what
    to do with each variable type it encounters. Perl comes with a
    <filename
moreinfo="none"
>typemap</filename> file that contains the common
    variable types and it is installed as part of Perl. On many Unix
    systems it can be found in
    <filename
moreinfo="none"
>/usr/lib/perl5/5.6.0/ExtUtils/typemap</filename><footnote
><para
>The
    location of the file on your system can be determined using Perl's
    <classname
>Config</classname> module:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -MConfig -MFile::Spec -e 'print File::Spec-&gt;catfile($Config{installprivlib},"ExtUtils","typemap")'</userinput>
/usr/lib/perl5/5.6.0/ExtUtils/typemap</screen></footnote>. Here is a subset of that file:</para><remark
>Suggestion is that the typemap listing focuses on types
    that we actually use and on types that include the special xsubpp
    variables described in this section.</remark><programlisting
format="linespecific"
># basic C types
int			T_IV
unsigned int		T_UV
long			T_IV
unsigned long		T_UV
char			T_CHAR
unsigned char		T_U_CHAR
char *			T_PV
unsigned char *		T_PV
size_t			T_IV
STRLEN                  T_IV
time_t			T_NV
double                  T_DOUBLE

############################################
INPUT
T_UV
	$var = ($type)SvUV($arg)
T_IV
	$var = ($type)SvIV($arg)
T_CHAR
	$var = (char)*SvPV($arg,PL_na)
T_U_CHAR
	$var = (unsigned char)SvUV($arg)
T_NV
	$var = ($type)SvNV($arg)
T_DOUBLE
	$var = (double)SvNV($arg)
T_PV
	$var = ($type)SvPV($arg,PL_na)
############################################
OUTPUT
T_IV
	sv_setiv($arg, (IV)$var);
T_UV
	sv_setuv($arg, (UV)$var);
T_CHAR
	sv_setpvn($arg, (char *)&amp;$var, 1);
T_U_CHAR
	sv_setuv($arg, (UV)$var);
T_NV
	sv_setnv($arg, (double)$var);
T_DOUBLE
	sv_setnv($arg, (double)$var);
T_PV
	sv_setpv((SV*)$arg, $var);</programlisting><para
>The first section contains a list of all the C types of
    interest (there are many more in the actual file) along with a
    string describing the type of variable. As can be seen from the
    list this provides a many-to-one translation since many different
    C variable types can have the same fundamental representation via
    the use of typedefs (see <xref
linkend="cintro.typedef"
></xref>). For
    example, both <type
>size_t</type> and <type
>STRLEN</type> are
    fundamentally integer types and can be represented by a
    <type
>T_IV</type> in the typemap.</para><para
>The second section is called <quote
>INPUT</quote> and provides
    the code required to translate a Perl variable to the
    corresponding C type. The third section is called
    <quote
>OUTPUT</quote> and does the reverse: providing code to
    translate C variables to Perl variables. The identifier matches
    the value defined in the first section and the functions are
    simply those described in <xref
linkend="api.getsv"
></xref>.  For
    example, the typemap entry to translate an SV to an integer (T_IV)
    uses <function
moreinfo="none"
>SvIV</function> to retrieve the integer from the
    <type
>SV</type> and <function
moreinfo="none"
>sv_setiv</function> to set the
    integer part of an <type
>SV</type>.</para><para
>The <filename
moreinfo="none"
>typemap</filename> file may look strange
    because it includes Perl-style variables in C-type code. The
    variables <varname
>$arg</varname>, <varname
>$var</varname> and
    <varname
>$type</varname> (and for more complex entries
    <varname
>$ntype</varname>) have a special meaning in
    typemaps.</para><variablelist
><varlistentry
><term
>$arg</term><listitem
><para
>This is the name of the Perl SV in the Perl argument
	  list.</para></listitem></varlistentry><varlistentry
><term
>$var</term><listitem
><para
>This is the name of the C variable that is either
	  receiving the value from the SV or setting the value in the
	  SV.</para></listitem></varlistentry><varlistentry
><term
>$type</term><listitem
><para
>This is the type of the C variable. This will be one
	  of the types listed at the top of the typemap file.</para></listitem></varlistentry><varlistentry
><term
>$ntype</term><listitem
><para
>The type of the C variable with all asterisks replaced
	  with the string <quote
>Ptr</quote>. A <type
>char *</type> would
	  therefore set <varname
>$ntype</varname> to
	  <quote
>charPtr</quote>. This variable is sometimes used for
	  setting classnames or for referencing helper functions.
 </para></listitem></varlistentry><varlistentry
><term
>$Package</term><listitem
><para
>The Perl package associated with this variable. This
	  is the same as the value assigned to the
	  <function
moreinfo="none"
>PACKAGE</function> directive in the XS
	  file.</para></listitem></varlistentry><varlistentry
><term
>$func_name</term><listitem
><para
>This is the name of the XS function.</para></listitem></varlistentry><varlistentry
><term
>$argoff</term><listitem
><para
>The position of the argument in the argument
	  list. Starts counting at 0.</para></listitem></varlistentry></variablelist><para
>You will find that in many cases you will need to add extra
    typemap entries when creating XS interfaces. Rather than add to
    the standard typemap all that is required is to create a file
    called <filename
moreinfo="none"
>typemap</filename> in your module directory and
    add entries in the same format as that used in the default typemap
    above. The <filename
moreinfo="none"
>makefile</filename> that is generated from
    <filename
moreinfo="none"
>Makefile.PL</filename> will automatically include this
    typemap file in the XS processing.</para></sect1><sect1
id="advxs.argstack"
><title
>The Argument Stack</title><para
>In Perl arguments are passed into and out of subroutines as
    lists. The list is called an <firstterm
>argument
    stack</firstterm>: arguments are pushed onto the stack by the
    caller and shifted off the stack by the subroutine. Any Perl
    program will demonstrate this behaviour:</para><programlisting
format="linespecific"
>my ($sum, $diff) = sumdiff( 5, 3 );

sub sumdiff {
  my $arg1 = shift; # implicitly shifts of @_
  my $arg2 = shift;

  return ( $arg1 + $arg2, $arg1 - $arg2 );
}</programlisting><para
>Perl keeps track of the number of arguments on the stack
    that are meant for the current subroutine (i.e. the size of
    <varname
>@_</varname>) <remark
>Do we want to explain how or is
    that too detailed for this section?</remark></para><para
>XS routines use the exact same technique when passing
    arguments from Perl to the XS layer. In our discussion so far this
    has happened automatically and the arguments from the stack have
    been processed using the provided typemap. Perl provides the
    <function
moreinfo="none"
>ST</function> macro to retrieve the <type
>SV</type> on
    the stack. <function
moreinfo="none"
>ST(0)</function> is equivalent to
    <varname
>$_[0]</varname>, <function
moreinfo="none"
>ST(1)</function> is equivalent
    to <varname
>$_[1]</varname> etc. Indeed in the typemap definitions
    described in the previous section <varname
>$arg</varname> is
    actually replaced by <function
moreinfo="none"
>ST()</function> macros
    corresponding to the required stack position. More details on this
    replacement can be found in <xref
linkend="advxs.inside"
></xref></para><para
>So far we have just looked at XS functions that either
    modify input arguments (ultimately using the
    <function
moreinfo="none"
>ST</function> macros) and/or return a single value. It
    is also possible to write XS functions that take full control of
    the argument stack and this chapter contains examples on how to
    achieve this using PPCODE (see <xref
linkend="advxs.cstruct.retlist"
></xref>).</para></sect1><sect1
id="advxs.cstruct"
><title
>C Structures</title><para
>C structures (<xref
linkend="cadv.struct"
></xref>) are used in many libraries
to pass related blocks of data around. This section shows how you can
handle them in XS. The choice you make depends entirely on the way in
which the structure is to be used.</para><sect2
id="advxs.cstruct.black"
><title
>...as black boxes</title><para
>If you don't want to look inside the structure (or are not allowed to)
then one approach to structures is simply to return the pointer to the
structure and store it in Perl scalar. Usually, the pointer is then
used as an argument for other library routines. As a simple example of
this we will provide an XS interface to some of the 
POSIX functions that deal with time. They are:</para><variablelist
><varlistentry
><term
><funcsynopsis
><funcprototype
><funcdef
>struct tm *
		<function
moreinfo="none"
>gmtime</function></funcdef><paramdef
>const
		time_t *<parameter
moreinfo="none"
>clock</parameter></paramdef></funcprototype></funcsynopsis>
          </term><listitem
><para
>Returns a <varname
>tm</varname> structure (using
	    Universal Time) for a given Unix time (e.g. the output
	    from the Perl <function
moreinfo="none"
>time</function> function). This is
	    the routine used for the Perl <function
moreinfo="none"
>gmtime</function>
	    builtin.</para></listitem></varlistentry><varlistentry
><term
><funcsynopsis
><funcprototype
><funcdef
>time_t <function
moreinfo="none"
>timegm</function></funcdef><paramdef
>struct tm * <parameter
moreinfo="none"
>tm</parameter></paramdef></funcprototype></funcsynopsis>
          </term><listitem
><para
>Convert a <varname
>tm</varname> structure to a Unix
	    time.</para></listitem></varlistentry><varlistentry
><term
><funcsynopsis
><funcprototype
><funcdef
>size_t <function
moreinfo="none"
>strftime</function></funcdef><paramdef
>char * <parameter
moreinfo="none"
>s</parameter></paramdef><paramdef
>size_t <parameter
moreinfo="none"
>maxsize</parameter></paramdef><paramdef
>char * <parameter
moreinfo="none"
>format</parameter></paramdef><paramdef
>struct tm * <parameter
moreinfo="none"
>tm</parameter></paramdef></funcprototype></funcsynopsis>
          </term><listitem
><para
>Convert a <varname
>tm</varname> structure to a
formatted string.</para></listitem></varlistentry></variablelist><para
>In other words, to use the above functions we don't need to know the
contents of the <varname
>tm</varname> structure.
For the purposes of this example we will place the XS routines into a
Perl module called <classname
>Time</classname>. The first step is to
create the module infrastructure:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>h2xs -A -n Time</userinput>
Writing Time/Time.pm
Writing Time/Time.xs
Writing Time/Makefile.PL
Writing Time/test.pl
Writing Time/Changes
Writing Time/MANIFEST</screen><para
>The first function to implement is <function
moreinfo="none"
>gmtime</function> since
that returns the base structure. Here is a first attempt at the XS
code:</para><programlistingco
><areaspec
><area
coords="3"
id="advxs.gmtime.clock"
></area></areaspec><programlisting
format="linespecific"
>struct tm *
gmtime( clock )
  time_t &amp;clock
</programlisting><calloutlist
><callout
arearefs="advxs.gmtime.clock"
><para
>The ampersand here indicates that we wish to pass a
	    pointer to the <function
moreinfo="none"
>gmtime</function> function. Perl
	    first copies the argument into the variable
	    <varname
>clock</varname> and then passes the pointer to
	    the function. Without the ampersand the default behaviour
	    would be to pass the value to the function.</para></callout></calloutlist></programlistingco><para
>If we attempt to build this (after running <userinput
moreinfo="none"
>perl
Makefile.PL</userinput>) we get the following error:</para><screen
format="linespecific"
>Error: 'struct tm *' not in typemap in Time.xs, line 11
Please specify prototyping behavior for Time.xs (see perlxs manual)
make: *** [Time.c] Error 1</screen><para
>The problem is that Perl does not now how to deal with a pointer to a
<varname
>tm</varname> structure since it is not present in the default
typemap file. To fix this we have to create a typemap file (called
<filename
moreinfo="none"
>typemap</filename>) and place it in the build directory.
Since we are just interested in the pointer (and not the contents) the
<filename
moreinfo="none"
>typemap</filename> just needs to contain the following:</para><programlisting
format="linespecific"
>struct tm *            T_PTR</programlisting><remark
>perlxs indicates that a tab is required between the "*" and
T_PTR but <command
moreinfo="none"
>xsubpp</command> runs fine with just spaces and,
looking at the code, does not even have a \t in there</remark><para
><varname
>T_PTR</varname> tells Perl to store the pointer address
directly into a scalar variable. After saving this file the module
should build successfully.  We can test this with the following:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> perl -Mblib -MTime -e 'print Time::gmtime(time)'
1075295360</screen><para
>Your actual result will vary since this is a memory
address. Now that we have a pointer we can pass it to a
function. <function
moreinfo="none"
>timegm</function> would look like this:</para><programlisting
format="linespecific"
>time_t
timegm( tm )
  struct tm * tm</programlisting><para
>and could be used as follows:</para><programlisting
format="linespecific"
>use Time;
$tm = Time::gmtime( time() );
$time = Time::timegm( $tm );</programlisting><para
>The default implementation of <function
moreinfo="none"
>strftime</function> looks like this:</para><programlisting
format="linespecific"
>size_t
strftime( s, maxsize, format, tm )
  char * s
  size_t maxsize
  char * format
  struct tm * tm
 OUTPUT:
  s</programlisting><para
>Unfortunately, although this does work okay there are serious problems
with the interface to <function
moreinfo="none"
>strftime</function> as implemented
above. To use it you would have to presize the output string and
provide the length of the output buffer (including the C-specific
terminating null character) two things that people are used to in C
but which are completely unacceptable in a perl interface:</para><programlisting
format="linespecific"
>use Time;
$tm = Time::gmtime( time() );
$s = "         ";  # presize output buffer
$maxsize = length($s)+1; # length must account for the null
$format = "%D";
$len = Time::strftime($s, $maxsize, $format, $tm);
print "length=$len output=$s\n";</programlisting><para
>A much better Perl interface would be something like:</para><funcsynopsis
><funcprototype
><funcdef
>$s = <function
moreinfo="none"
>strftime</function></funcdef><paramdef
><parameter
moreinfo="none"
>$tm</parameter></paramdef><paramdef
><parameter
moreinfo="none"
>$format</parameter></paramdef></funcprototype></funcsynopsis><para
>where we have removed the input buffer requirement completely
and rearranged the argument order to place the <varname
>tm</varname>
structure at the start of the list.  One way of implementing this
interface is to write a pure perl wrapper (placed in the .pm file)
that deals with the presized buffer and then calls the XS code. Whilst
this is sometimes easier to implement (especially if you are making
use of Perl functionality), often it is more efficient to rewrite the
XS layer using <type
>CODE:</type> blocks:</para><programlisting
format="linespecific"
>char *
strftime( tm, format )
  struct tm * tm
  char * format
 PREINIT:
  char tmpbuf[128];
  size_t len;
 CODE:
  len = strftime( tmpbuf, sizeof(tmpbuf), format, tm);
  if (len &gt; 0 &amp;&amp; len &lt; sizeof(tmpbuf)) {
     RETVAL = tmpbuf;
  } else {
     XSRETURN_UNDEF;
  }
 OUTPUT:
  RETVAL</programlisting><para
>This is much better but still not perfect. The problem now
      is that we don't know the required size of the output buffer
      before calling <function
moreinfo="none"
>strftime</function>. In the above
      example we simply allocate 128 characters and hope that that is
      enough. For most cases it will be but if a large format is
      supplied this function will currently just return
      <function
moreinfo="none"
>undef</function>. One way to overcome this is to check
      the return value of <function
moreinfo="none"
>strftime</function> and increase
      the buffer size until it is large enough and this is exactly the
      way that <function
moreinfo="none"
>POSIX::strftime</function> is implemented in
      standard Perl.<footnote
><para
>see
      <filename
moreinfo="none"
>ext/POSIX/POSIX.xs</filename> in the Perl source tree
      for details of the implementation of
      <function
moreinfo="none"
>POSIX::strftime</function>.</para></footnote></para><para
>The example so far has demonstrated how to pass a
      structure pointer from and to a C library but the interface
      implemented above has some remaining issues. In the following
sections we address some of these problems.</para><sect3
id="advxs.cstruct.tptr"
><title
>T_PTR versus T_PTRREF</title><para
>Using a scalar to store a memory address is dangerous
	since it is possible that, inadvertently, the Perl program may
	change the value of an existing pointer (maybe by treating it
	as a normal number) or may pass an undefined value (0) into
	the <function
moreinfo="none"
>timegm</function> or
	<function
moreinfo="none"
>strftime</function> functions. If any of these
	things occur the program will crash with a memory error since
	the value will no longer point to a valid memory location. The
	best way of dealing with this problem is to use an object
	interface (see <xref
linkend="advxs.struct.oo"
></xref>) but failing that
	another option is to return a reference to a scalar containing
	the pointer value rather than the scalar itself. The
	<varname
>T_PTRREF</varname> typemap designation does exactly
	that:</para><programlisting
format="linespecific"
>T_PTR
        sv_setiv($arg, (IV)$var);
T_PTRREF
        sv_setref_pv($arg, Nullch, (void*)$var);</programlisting><para
>This has the advantage that the function will not run
	unless a scalar reference is passed in (much harder to do by
	mistake).</para></sect3><sect3
id="advxs.cstruct.default"
><title
>Default arguments</title><para
>Rather than always forcing the time to be supplied a
	cleaner approach is to allow for the current time to be
	assumed if no arguments are present. This matches the
	behaviour of the <function
moreinfo="none"
>gmtime</function>
	builtin.<footnote
><para
><function
moreinfo="none"
>gmtime</function> is
	implemented in Perl in the file
	<filename
moreinfo="none"
>pp_sys.c</filename>.</para></footnote></para><programlistingco
><areaspec
><area
coords="2"
id="advxs.struct.def.ellipsis"
></area><area
coords="3"
id="advxs.struct.def.preinit"
></area><area
coords="6"
id="advxs.struct.def.items"
></area><area
coords="7"
id="advxs.struct.def.croak"
></area><area
coords="9"
id="advxs.struct.def.svnv"
></area><area
coords="11"
id="advxs.struct.def.time"
></area><area
coords="13"
id="advxs.struct.def.gmtime"
></area></areaspec><programlisting
format="linespecific"
>struct tm *
gmtime( ... )
 PREINIT:
  time_t clock;
 CODE:
  if (items &gt; 1)
     Perl_croak(aTHX_ "Usage: Time::gmtime( [time] )");
  else if (items == 1)
     clock = (time_t)SvNV(ST(0));
  else
     clock = time( NULL );

  RETVAL = gmtime( &amp;clock );
 OUTPUT:
  RETVAL</programlisting><calloutlist
><callout
arearefs="advxs.struct.def.ellipsis"
><para
>The ellipsis (<userinput
moreinfo="none"
>...</userinput>)
	      indicates to the XS compiler that the number of input
	      arguments is not known. In this example there are no
	      required arguments whereas a signature of
	      <userinput
moreinfo="none"
>gmtime( clock, ...)</userinput> could be used
	      to indicate that there will be at least one
	      argument.</para></callout><callout
arearefs="advxs.struct.def.preinit"
><para
>There are no required arguments so we have to
	      explicitly declare the <varname
>clock</varname> variable
	      since <command
moreinfo="none"
>xsubpp</command> can no longer determine
	      this from the argument list.</para></callout><callout
arearefs="advxs.struct.def.items"
><para
>The <varname
>items</varname> variable is supplied
	      by the XS system and contains the number of input
	      arguments waiting on the stack. Here we are checking to
	      see if more than one argument has been supplied.</para></callout><callout
arearefs="advxs.struct.def.croak"
><para
>If more than one argument has been supplied we
	      stop the program with a
	      <function
moreinfo="none"
>Perl_croak</function>. This provides similar
	      functionalty to the <function
moreinfo="none"
>croak</function> provided
	      by the <classname
>Carp</classname> module.</para></callout><callout
arearefs="advxs.struct.def.svnv"
><para
>The ellipsis implies that we have to do our own
	      argument processing. If there is a single argument the
	      numeric value is retrieved from the first argument on
	      the stack (<function
moreinfo="none"
>ST(0)</function>). This code is
	      identical to that found in the standard typemap file
	      (see <xref
linkend="advxs.typemaps"
></xref>).</para></callout><callout
arearefs="advxs.struct.def.time"
><para
>If there are no arguments the current time is
	      obtained using the system <function
moreinfo="none"
>time</function>
	      function. The <function
moreinfo="none"
>NULL</function> macro is used to
	      indicate that we are only interested in a return
	      value.</para></callout><callout
arearefs="advxs.struct.def.gmtime"
><para
>Run the <function
moreinfo="none"
>gmtime</function> using the
	      value stored in <varname
>clock</varname> and store the
	      pointer in <varname
>RETVAL</varname>.</para></callout></calloutlist></programlistingco></sect3><sect3
id="advxs.cstruct.static"
><title
>Static memory</title><para
>A more worrying problem is associated with the
	<function
moreinfo="none"
>gmtime</function> itself. This always uses the same
	structure (and therefore returns the same memory address) so
	each time it is called it overwrites the answer from a
	previous call. This is evident in the following
	example:</para><programlisting
format="linespecific"
>use Time;
$tm1 = Time::gmtime( time() );
print "First time: ",Time::timegm( $tm1 ), "\n";
$tm2 = Time::gmtime( time() + 100 );

print "First time (again): ",Time::timegm( $tm1 ), "\n";
print "Second time: ",Time::timegm( $tm2 ), "\n";</programlisting><para
>which prints</para><screen
format="linespecific"
>First time: 983692014
First time (again): 983692114
Second time: 983692114</screen><para
>This may cause confusion unless very carefully
	documented (not everyone is an expert C programmer used to
	these oddities). On systems where it is available one solution
	is to use <function
moreinfo="none"
>gmtime_r</function>, the reentrant
	(thread-safe) version of this function, since that takes the
	address of the structure as an argument:</para><programlisting
format="linespecific"
>struct tm *
gmtime( clock );
  time_t clock;
 PREINIT:
  struct tm * tmbuf;
 CODE:
  New( 0, tmbuf, 1, struct tm );
  RETVAL = gmtime_r( &amp;clock, tmbuf );
 OUTPUT:
  RETVAL</programlisting><para
> A more general solution (but not thread-safe) is to
	copy the result from <function
moreinfo="none"
>gmtime</function> into a new
	structure each time:</para><programlisting
format="linespecific"
>struct tm *
gmtime_cp( clock );
  time_t clock;
 PREINIT:
  struct tm * tmbuf;
  struct tm * result;
 CODE:
  result = gmtime( &amp;clock );
  New( 0, tmbuf, 1, struct tm );
  StructCopy( result, tmbuf, struct tm);
  RETVAL = tmbuf;
 OUTPUT:
  RETVAL</programlisting><para
>Both these techniques overcome the problem with
	<function
moreinfo="none"
>gmtime</function> but they both introduce a memory
	leak. The reason for this is that the memory allocated for the
	new structure (using the <function
moreinfo="none"
>New</function> function) is
	never given back to the system. The Perl scalar containing the
	memory address attaches no special meaning to it; if the
	variable goes out of scope the SV is freed without freeing the
	memory. The C way to deal with this is to provide a function
	that can be called when the structure is no longer needed (an
	XS function that simply calls
	<function
moreinfo="none"
>Safefree</function>).</para><para
>The more Perl-like way to handle this problem is to turn
	the structure into an object such that Perl automatically
	frees the memory when the variable goes out of scope. This
	approach is discussed in <xref
linkend="advxs.struct.oo"
></xref>. Alternatively, if the structure is
	fairly simple (and does not contain pointers to other
	variables) it is possible to either copy the memory contents
	directly into a perl variable by using the T_OPAQUEPTR typemap
	entry or to copy the contents into a perl hash. These both
	have the advantage of allowing perl to keep track of memory
	management rather than the programmer. The hash approach is
	partially discussed in <xref
linkend="advxs.struct.hash"
></xref>. Both approaches allow the caller
	to modify the contents of the hash between calls, it is no
	longer a black box, and the hash approach does required more
	work from the XS programmer.</para></sect3></sect2><sect2
id="advxs.struct.oo"
><title
>...as objects</title><para
>An object can be thought of as some data associated with a
      set of subroutines (methods). In many libraries, C structures
      take on the same role as objects and Perl can treat them as
      such. An OO interface to the time functions described earlier
      may look something like (the use of <function
moreinfo="none"
>new</function> as
      a constructor is purely convention):</para><programlisting
format="linespecific"
>use Time;

$tm = new Time( time() );
$time = $tm-&gt;timegm;
$s = $tm-&gt;strftime( $format );</programlisting><para
>The changes required to the existing <classname
>Time</classname>
module to get this behaviour are not very extensive. In this section
we will modify the <classname
>Time</classname> module so that it
matches the above interface.</para><para
>The single most important change is to modify the typemap entry to the
following to use <type
>T_PTROBJ</type>.  <type
>T_PTROBJ</type> is
similar to <type
>T_PTTREF</type> except that the reference is blessed
into a class. Here is the OUTPUT entry in the typemap file:</para><programlisting
format="linespecific"
>T_PTROBJ
        sv_setref_pv($arg, \"${ntype}\", (void*)$var);</programlisting><para
>By default the reference will be blessed into class
<varname
>$ntype</varname> which translates to <classname
>struct
tmPtr</classname>! A class containing a space is not very helpful
since the XS compiler does not know how to handle them. We can get
around this problem in two ways. We can either create a new OUTPUT
entry (and corresponding INPUT entry) that uses a hard-wired package
name:</para><programlisting
format="linespecific"
>struct tm *     T_TMPTROBJ

INPUT:
T_TMPTROBJ
        if (sv_derived_from($arg, \"TimePtr\")) {
            IV tmp = SvIV((SV*)SvRV($arg));
            $var = INT2PTR($type,tmp);
        }
        else
            Perl_croak(aTHX_ \"$var is not of type TimePtr\")

OUTPUT:
T_TMPTROBJ
        sv_setref_pv($arg, \"TimePtr\", (void*)$var);</programlisting><para
>or we can create a new variable type and associate that with
<type
>T_PTROBJ</type>. We will adopt the latter technique since it is
more robust against changes to the behaviour of typemap entries. This
requires the following line to be added before the MODULE line in the
XS file to generate a new type <type
>Time</type> as an alias for
<type
>struct tm</type>:</para><programlisting
format="linespecific"
>typedef struct tm Time;</programlisting><para
>and the typemap file modified to include:</para><programlisting
format="linespecific"
>Time *     T_PTROBJ</programlisting><para
>Now wherever we used <type
>struct tm</type> we now use
<type
>Time</type>. Here is the new constructor (including all the
changes suggested earlier):</para><programlistingco
><areaspec
><area
coords="1"
id="advxs.struct.oo.time"
></area><area
coords="2"
id="advxs.struct.oo.new"
></area><area
coords="12"
id="advxs.struct.oo.svnv"
></area></areaspec><programlisting
format="linespecific"
>Time *
new( class, ... );
  char * class
 PREINIT:
  time_t clock;
  Time * tmbuf;
  Time * result;
 CODE:
  if (items &gt; 2)
     Perl_croak(aTHX_ "Usage: new Time( [time] )");
  else if (items == 2)
     clock = (time_t)SvNV(ST(1));
  else
     clock = time( NULL );

  result = gmtime( &amp;clock );
  New( 0, tmbuf, 1, Time );
  StructCopy( result, tmbuf, Time);
  RETVAL = tmbuf;
 OUTPUT:
  RETVAL</programlisting><calloutlist
><callout
arearefs="advxs.struct.oo.time"
><para
>The return value is now a pointer to
	    <type
>Time</type> rather than a pointer to a <type
>struct
	    tm</type>.</para></callout><callout
arearefs="advxs.struct.oo.new"
><para
>The function name has changed to
	    <function
moreinfo="none"
>new</function> and now there is one required
	    argument (the class name) as well as the optional second
	    argument. This is no different to any other perl method.</para></callout><callout
arearefs="advxs.struct.oo.svnv"
><para
>The Unix time is now the second argument
	    (<function
moreinfo="none"
>ST(1)</function>) rather than the first.</para></callout></calloutlist></programlistingco><para
>The changes are minor compared to the previous non-OO version and
caused entirely by the extra argument.

<footnote
><para
>If you are happy to have a non-OO style constructor, simply
changing the typemap entry would be enough. The calling style would
then remain</para><programlisting
format="linespecific"
>$object = Time::gmtime(); </programlisting><para
>except that this would return an object.  </para></footnote>
If you build this module we can check the result of the constructor:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MTime -e 'print new Time()'</userinput>
TimePtr=SCALAR(0x80f87b8)</screen><para
>As expected it returns an object blessed into class
<classname
>TimePtr</classname>. The complication now is that the
<methodname
>timegm</methodname> and <methodname
>strftime</methodname>
methods must be put into the <classname
>TimePtr</classname> package
and not the default <classname
>Time</classname> namespace. We do this
by adding an addditional MODULE directive after the constructor and
then adding the methods:</para><programlisting
format="linespecific"
>MODULE = Time		PACKAGE = TimePtr

time_t
timegm( tm )
  Time * tm

char *
strftime( tm, format )
  Time * tm
  char * format
 PREINIT:
  char tmpbuf[128];
  size_t len;
 CODE:
  len = strftime( tmpbuf, sizeof(tmpbuf), format, tm);
  if (len &gt; 0 &amp;&amp; len &lt; sizeof(tmpbuf)) {
     RETVAL = tmpbuf;
  } else {
     XSRETURN_UNDEF;
  }
 OUTPUT:
  RETVAL</programlisting><para
>Other than the extra package declaration these definitions are
<emphasis
>exactly</emphasis> the same as those used previously. Perl
automatically finds these functions and passes the structure pointer
(the object) as the first argument.</para><para
>There are at least two reasons to prefer the OO interface over
storing the plain pointer <footnote
><para
>Ignoring any preference in syntax of
<userinput
moreinfo="none"
>Time::timegm($tm)</userinput> versus
<userinput
moreinfo="none"
>$tm-&gt;timegm</userinput></para></footnote>:</para><variablelist
><varlistentry
><term
>Type safety</term><listitem
><para
>The INPUT typemap entry for <type
>T_PTROBJ</type>
	    includes a check for the class of the input variable. This
	    guarantees that the object is of the correct type. Unless
	    a programmer really tries hard this will prevent strange
	    values (with even stranger memory addresses) being passed
	    to the C layer and causing segmentation faults.</para></listitem></varlistentry><varlistentry
><term
>Destructors</term><listitem
><para
>As in any Perl class when the object goes out of
	    scope and is freed Perl will call a
	    <methodname
>DESTROY</methodname>. XS implementations of
	    perl classes behave in exactly the same way. Recall that
in the previous implementation the <function
moreinfo="none"
>gmtime</function>
generated a memory leak because it was not possible to automatically
free the allocated to the structure. As written the current object
implementation also has the problem but it can be fixed simply by
adding a <methodname
>DESTROY</methodname> function to the
<classname
>TimePtr</classname> class: </para><programlisting
format="linespecific"
>void
DESTROY( tm )
  Time * tm
 CODE:
  printf("Calling TimePtr destructor\n");
  Safefree( tm );</programlisting><para
>Now whenever a <classname
>TimePtr</classname> object
	    is freed the destructor will be called and the memory will
	    be freed.</para></listitem></varlistentry></variablelist></sect2><sect2
id="advxs.struct.hash"
><title
>...as hashes</title><para
>If the main reason for the structure is to group return values that
are of interest then you should consider unpacking
the structure into either a Perl hash or a list that can be converted
into a hash. We will demonstrate both these techniques by extending
our <classname
>Time</classname> module so that it uses a Perl hash
rather than a structure pointer. For clarity, the examples will not
include support for defaulting of the time.</para><sect3
id="advxs.cstruct.rethash"
><title
>Returning a hash reference</title><para
>One way of returning a hash is to return the reference to a hash:</para><programlisting
format="linespecific"
>$hash = Time::gmtime_as_href( time );
print "Day is ", $hash-&gt;{"mday"}, "\n";</programlisting><para
>The XS code required for this is:</para><programlistingco
><areaspec
><area
coords="1"
id="advxs.struct.hash.hv"
></area><area
coords="2"
id="advxs.struct.hash.name"
></area><area
coords="3"
id="advxs.struct.hash.arg"
></area><area
coords="4"
id="advxs.struct.hash.preinit"
></area><area
coords="9"
id="advxs.struct.hash.gmtime"
></area><area
coords="11"
id="advxs.struct.hash.newhv"
></area><area
coords="14"
id="advxs.struct.hash.hvstore"
></area><area
coords="23"
id="advxs.struct.hash.retval"
></area></areaspec><programlisting
format="linespecific"
>HV *
gmtime_as_href( clock )
  time_t clock
 PREINIT:
  HV * hash;
  struct tm * tmbuf;
 CODE:
  /* Run gmtime */
  tmbuf = gmtime( &amp;clock );

  hash = newHV();

  /* Copy struct contents into hash */
  hv_store(hash, "sec",  3, newSViv(tmbuf-&gt;tm_sec), 0);
  hv_store(hash, "min",  3, newSViv(tmbuf-&gt;tm_min), 0);
  hv_store(hash, "hour", 4, newSViv(tmbuf-&gt;tm_hour), 0);
  hv_store(hash, "mday", 4, newSViv(tmbuf-&gt;tm_mday), 0);
  hv_store(hash, "mon",  3, newSViv(tmbuf-&gt;tm_mon), 0);
  hv_store(hash, "year", 4, newSViv(tmbuf-&gt;tm_year), 0);
  hv_store(hash, "wday", 4, newSViv(tmbuf-&gt;tm_wday), 0);
  hv_store(hash, "yday", 4, newSViv(tmbuf-&gt;tm_yday), 0);

  RETVAL = hash;
 OUTPUT:
  RETVAL</programlisting><calloutlist
><callout
arearefs="advxs.struct.hash.hv"
><para
>Here we set the return value of our function to be a
pointer to a hash. Remember that the argument stack can only contain
scalar types so the typemap will automatically convert this to a
hash reference when it is placed on the stack.</para></callout><callout
arearefs="advxs.struct.hash.name"
><para
>We call this <function
moreinfo="none"
>gmtime_as_href</function> to
distinguish it from the normal <function
moreinfo="none"
>gmtime</function> function.</para></callout><callout
arearefs="advxs.struct.hash.arg"
><para
>Here we just pass in the time in seconds rather
	      than providing a means for defaulting to the current
	      time.</para></callout><callout
arearefs="advxs.struct.hash.preinit"
><para
>This block declares the additional variables that
	      will be required. <varname
>hash</varname> is a pointer
	      to an HV, <varname
>tmbuf</varname> is declared as a
	      pointer to the struct that will contain the result from
	      the <function
moreinfo="none"
>gmtime</function> call. Since the hash
	      will also be returned we could have used
	      <varname
>RETVAL</varname> throughout rather than
	      creating an extra variable but the explicit use of a
	      variable name is sometimes clearer.</para></callout><callout
arearefs="advxs.struct.hash.gmtime"
><para
>Call <function
moreinfo="none"
>gmtime</function> with the pointer
	      to the current time.</para></callout><callout
arearefs="advxs.struct.hash.newhv"
><para
>Create a new hash and store the pointer in <varname
>hash</varname>.</para></callout><callout
arearefs="advxs.struct.hash.hvstore"
><para
>This line and those following store the contents
of the structure into the hash. The first argument is a pointer to the
HV, the second argument is the key and the third is the length of the
key. The fourth argument must be an SV therefore an SV is created
using the integer from each struct entry. The final argument is the
hash number itself; since we don't know the value we pass in a
<literal
moreinfo="none"
>0</literal> and ask Perl to calculate it for us. One final
thing to note is that <function
moreinfo="none"
>hv_store</function> does not affect
the reference count of the SV that is being stored. This means that
each of the SV's stored in the hash will automatically have a refcount
of <literal
moreinfo="none"
>1</literal>.</para></callout><callout
arearefs="advxs.struct.hash.retval"
><para
>The hash has been populated so we can copy the
pointer to the RETVAL variable.</para></callout></calloutlist></programlistingco><para
>Whilst the above XS code does work, returning a reference to a hash
containing the <function
moreinfo="none"
>gmtime</function> results, there is a subtle
bug in the above code as can be illustrated by the following output:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MTime -MDevel::Peek -e '$h=Time::gmtime_as_href(time);Dump($h)'</userinput>
SV = RV(0x81109b4) at 0x815bd54
  REFCNT = 1
  FLAGS = (ROK)
  RV = 0x80f86e0
  SV = PVHV(0x81429a8) at 0x80f86e0
    REFCNT = 2
    FLAGS = (SHAREKEYS)
    IV = 8
    NV = 0
    ARRAY = 0x81003d8  (0:2, 1:5, 3:1)
    hash quality = 85.7%
    KEYS = 8
    FILL = 6
    MAX = 7
    RITER = -1
    EITER = 0x0
    ...</screen><para
>This shows that the reference count to the HV is 2. The variable
<varname
>$h</varname> has one of the references but there are no other
variables that know about the reference.  This constitutes a memory
leak. If <varname
>$h</varname> is later undefined or goes out of
scope, the reference count on the HV will drop to <literal
moreinfo="none"
>1</literal>
but it can't go any lower. Since it never goes to zero the HV will not
be freed until the program exits.  The reason for this is that when
the HV is created using <function
moreinfo="none"
>newHV</function> its reference count
is set to one as expected. The output typemap entry for an HV is</para><programlisting
format="linespecific"
>T_HVREF
   $arg = newRV_inc((SV*)$var);</programlisting><para
>which increments the reference count when the reference is
taken. At this point there is an SV containing a reference to the hash
on the stack and the <varname
>hash</varname> variable containing the
HV and the reference count is now, correctly,
<literal
moreinfo="none"
>2</literal>. Unfortunately when the XS function exits the
<varname
>hash</varname> variable simply disappears without decrementing the
reference count. Perl overcomes problems such as this by introducing
the concept of <firstterm
>mortality</firstterm>. If an SV is marked as
mortal the reference count will automatically be decremented at some
point later in time. For XS functions, mortal variables have their
reference count decremented on exit from the function. The above code
can be fixed to avoid the memory leak simply by marking
<varname
>hash</varname> as mortal with:</para><programlisting
format="linespecific"
>hash = (HV*)sv_2mortal((SV*)newHV());</programlisting><para
>The new sequence now becomes:</para><orderedlist
inheritnum="ignore"
continuation="restarts"
><listitem
><para
>Create new HV and increment reference
	    count. Reference count = <literal
moreinfo="none"
>1</literal></para></listitem><listitem
><para
>Mark HV as mortal. Reference count =
	    <literal
moreinfo="none"
>1</literal></para></listitem><listitem
><para
>Take reference to HV and store it on the argument
	    stack. Reference count = <literal
moreinfo="none"
>2</literal></para></listitem><listitem
><para
>Exit XS function and automatically decrement the
	    reference count. Reference count =
	    <literal
moreinfo="none"
>1</literal></para></listitem></orderedlist><para
>If this change is made the test program now reports the correct
reference count for <varname
>$h</varname>:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MTime -MDevel::Peek -e '$h=Time::gmtime_as_href(time);Dump($h)'</userinput>
SV = RV(0x81109b4) at 0x815bd54
  REFCNT = 1
  FLAGS = (ROK)
  RV = 0x80f86e0
  SV = PVHV(0x81429a8) at 0x80f86e0
    REFCNT = 1
    FLAGS = (SHAREKEYS)
    IV = 8
    NV = 0
    ARRAY = 0x81003d8  (0:2, 1:5, 3:1)
    hash quality = 85.7%
    KEYS = 8
    FILL = 6
    MAX = 7
    RITER = -1
    EITER = 0x0
    Elt "yday" HASH = 0x4630b8
    SV = IV(0x81073b8) at 0x815bcdc
      REFCNT = 1
      FLAGS = (IOK,pIOK)
      IV = 77
    Elt "wday" HASH = 0x450f30
    SV = IV(0x81073b4) at 0x815bce8
      REFCNT = 1
      FLAGS = (IOK,pIOK)
      IV = 1
    Elt "mday" HASH = 0x3f6788
    SV = IV(0x81071cc) at 0x8104354
      REFCNT = 1
      FLAGS = (IOK,pIOK)
      IV = 19</screen></sect3><sect3
id="advxs.cstruct.retlist"
><title
>Returning a list</title><para
>An alternative way of returning a hash is to return a list with
alternating keys and values:</para><programlisting
format="linespecific"
>%hash = Time::gmtime_as_list( time );
print "Day is ", $hash{"mday"}, "\n";</programlisting><para
>The XS code for this must push the keys and the values on to the argument
stack just as if this was a normal Perl routine:</para><programlistingco
><areaspec
><area
coords="1"
id="advxs.struct.list.void"
></area><area
coords="6"
id="advxs.struct.list.ppcode"
></area><area
coords="9"
id="advxs.struct.list.extend"
></area><area
coords="11"
id="advxs.struct.list.push"
></area></areaspec><programlisting
format="linespecific"
>void
gmtime_as_list( clock )
  time_t clock
 PREINIT:
  struct tm * tmbuf;
 PPCODE:
  tmbuf = gmtime( &amp;clock );

  EXTEND(SP, 16);

  PUSHs( sv_2mortal( newSVpv("sec", 3) ));
  PUSHs( sv_2mortal( newSViv(tmbuf-&gt;tm_sec) ));
  PUSHs( sv_2mortal( newSVpv("min", 3) ));
  PUSHs( sv_2mortal( newSViv(tmbuf-&gt;tm_min) ));
  PUSHs( sv_2mortal( newSVpv("hour", 4) ));
  PUSHs( sv_2mortal( newSViv(tmbuf-&gt;tm_hour) ));
  PUSHs( sv_2mortal( newSVpv("mday", 4) ));
  PUSHs( sv_2mortal( newSViv(tmbuf-&gt;tm_mday) ));
  PUSHs( sv_2mortal( newSVpv("mon", 3) ));
  PUSHs( sv_2mortal( newSViv(tmbuf-&gt;tm_mon) ));
  PUSHs( sv_2mortal( newSVpv("year", 4) ));
  PUSHs( sv_2mortal( newSViv(tmbuf-&gt;tm_year) ));
  PUSHs( sv_2mortal( newSVpv("wday", 4) ));
  PUSHs( sv_2mortal( newSViv(tmbuf-&gt;tm_wday) ));
  PUSHs( sv_2mortal( newSVpv("yday", 4) ));
  PUSHs( sv_2mortal( newSViv(tmbuf-&gt;tm_yday) ));</programlisting><calloutlist
><callout
arearefs="advxs.struct.list.void"
><para
>Here we use <type
>void</type> as a return value for
	      the function since the return values will be handled
	      directly by the routine rather than by the XS
	      compiler.</para></callout><callout
arearefs="advxs.struct.list.ppcode"
><para
>We use PPCODE rather than CODE to indicate to the
	      XS compiler that we are handling the return values
	      ourselves. This does not affect the processing of input
	      arguments but does imply that OUTPUT can not be used.</para></callout><callout
arearefs="advxs.struct.list.extend"
><para
>The <function
moreinfo="none"
>EXTEND</function> macro makes sure
	      that the argument stack is large enough to contain the
	      requested number of arguments. Since we know that we
	      will need to hold 16 items (8 keys and 8 values) we
	      presize the stack for efficiency. This is similar to
	      using <userinput
moreinfo="none"
>$#array = 15;</userinput> in
	      perl. <varname
>SP</varname> is the Stack Pointer
	      (pointing to the current position in the stack) and is
	      initialised for you automatically on entry to the routine.</para></callout><callout
arearefs="advxs.struct.list.push"
><para
>Here we need to start pushing arguments onto the
	      stack. For XS programmers the only approved ways of
	      pushing arguments onto the stack are the
	      <function
moreinfo="none"
>PUSHs</function> and
	      <function
moreinfo="none"
>XPUSHs</function> macros. These push an SV
	      onto the argument stack. The difference is that
	      <function
moreinfo="none"
>XPUSHs</function> extends the size of the
	      stack by one so that it is guaranteed to have room for
	      the incoming SV. In this example we could have used
	      <function
moreinfo="none"
>XPUSHs</function> instead of
	      <function
moreinfo="none"
>PUSHs</function> and removed the
	      <function
moreinfo="none"
>EXTEND</function> call. Since we can only push
	      SVs onto the stack each argument (string key or integer
	      value) is first converted to an SV and then marked as a
	      mortal. All SVs pushed on to the stack must be marked as
	      mortal so that they can be freed after assignment. The
	      reason for this is that a copy of the SV is assigned to
	      a perl variable and not the original SV. If this was not
	      the case <userinput
moreinfo="none"
>$a = $b</userinput> would alias
	      <varname
>$a</varname> to <varname
>$b</varname>!</para></callout></calloutlist></programlistingco><sidebar
><para
>Whilst it may be tempting to make use of the
<function
moreinfo="none"
>PUSHi</function>, <function
moreinfo="none"
>PUSHp</function> and
<function
moreinfo="none"
>PUSHn</function> functions (and the related
<function
moreinfo="none"
>XPUSH</function>) to push plain integers, strings and floats
onto the stack in XS routines they do not form part of the XS
API. These routines are intended for use by the internals and can only
be used to return a single value onto the stack. This is because they
use a single SV (that must be declared using the
<function
moreinfo="none"
>dTARG</function> macro) and if 5 values are pushed onto the
stack with these functions they will all receive the value of the last
thing that was pushed on because it is the pointer to the same SV that
is stored on the stack.</para></sidebar></sect3><sect3
id="advxs.cstruct.backc"
><title
>Passing it back into C</title><para
>Both these techniques (returning a list or returning a
	hash reference) overcome the memory leak problem described
	earlier. The reason for this is that the information is copied
	to a perl data structure and not kept inside a C
	structure. Perl knows nothing about the C structure so can
	only free its memory via an object destructor. When using
	hashes to store the information Perl can free the memory
	directly. Unfortunately this behaviour comes at a price when
	it is time to pass the information back to C. If the
	information is only required for information (e.g. the data
	returned from a call to <function
moreinfo="none"
>stat</function>) then this
	is not a problem, but if the data is to be passed back into C
	(e.g. to the <function
moreinfo="none"
>timegm</function> function) then more
	work is required because the data must be converted from the
	hash to a C structure. Even worse, you can no longer rely on
	the integrity of the data structure since the contents of the
	hash can be changed arbitrarily before they are passed back
	to C. If structure integrity is a problem then you should
	probably be using objects.</para></sect3></sect2></sect1><sect1
id="advxs.arrays"
><title
>Arrays</title><para
>In some cases a C routine might want to receive an array of
    numbers or strings. To handle this you will have to convert the
    perl array or list into a C array before calling the C
    function. This usually involves the following steps:</para><orderedlist
inheritnum="ignore"
continuation="restarts"
><listitem
><para
>Allocating some memory to hold the array.</para></listitem><listitem
><para
>Copying each element from the list/array to the C array.</para></listitem><listitem
><para
>After the C function has run, free the memory.</para></listitem></orderedlist><sect2
id="advxs.numarr"
><title
>Numeric arrays</title><para
>It is quite a common requirement, especially in the
      scientific community, to be able to pass arrays of numbers to
      and from C. This section will first describe how to deal with
      1-dimensional arrays and then move on to discuss
      multi-dimensional arrays. It will finish with some benchmarking
      examples to provide a guide for the most efficient handling of
      arrays and lists.</para><para
>One additional point is that this section deals with
      converting the lists and arrays to C arrays and not simply
      manipulating a Perl array <quote
>as-is</quote>. The easiest way to
      handle a Perl array in C as a Perl array is simply to pass in
      the array reference and manipulating the <type
>AV*</type> in C
      code.</para><sect3
><title
>into C</title><para
>In this section we will illustrate how to pass Perl numeric arrays
    to C by providing an XS interface to a function that will sum the
    elements of the array and return the answer to Perl. The signature
    of the C function will be:</para><funcsynopsis
><funcprototype
><funcdef
>int <function
moreinfo="none"
>sum</function></funcdef><paramdef
>int <parameter
moreinfo="none"
>count</parameter></paramdef><paramdef
>intArray * <parameter
moreinfo="none"
>array</parameter></paramdef></funcprototype></funcsynopsis><para
>where <type
>intArray</type> is typedef'ed to an int so that
    XS can distinguish a pointer to an integer from a pointer to an
    array of integers (they are both written as <type
>int *</type> in
    C). For this example the module will be called
    <classname
>Arrays</classname>. Here is the top of the XS file
    including the <function
moreinfo="none"
>sum</function> function:</para><programlisting
format="linespecific"
>#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

typedef int intArray;

/* Add up everything in an int array */
/* Args: the number of things to add, pointer to array */

int sum ( int num, intArray * array ) {
  int thesum = 0;
  int count;
  for (count = 0; count &lt; num; count++) {
    thesum += array[count];
  }
  return thesum;
}

MODULE = Arrays		PACKAGE = Arrays
</programlisting><sect4
id="advxs.arrays.asalist"
><title
>...as a list</title><para
>One of the simplest ways to pass an array into XS (and
      into other Perl subroutines) is simply to pass in a list:</para><programlisting
format="linespecific"
>$sum = Arrays::sum_as_list( @values );</programlisting><para
>Here each element of the array <varname
>@values</varname>
is pushed onto the argument stack so in XS each argument must be
retrieved from the stack and copied into a C array. Perl provides the
T_ARRAY typemap entry for handling this situation:</para><programlisting
format="linespecific"
>int
sum_as_list( array, ...)
  intArray * array
 CODE:
  /* ix_array is the total number of elements */
  RETVAL = sum( ix_array, array );
 OUTPUT:
  RETVAL
 CLEANUP:
  Safefree( array );</programlisting><para
>This all looks fairly straightforward but there are many
      things going on behind the scenes:</para><itemizedlist
><listitem
><para
>T_ARRAY is unique in the standard typemap file in
	    that it is designed to work on multiple input
	    arguments. The ellipsis (...) is used to indicate an
	    unknown number of arguments are expected but they are all
	    processed as part of the typemap entry.</para></listitem><listitem
><para
>T_ARRAY is greedy. Only a single XS argument can be
	    associated with T_ARRAY and it must be the last argument
	    in the list. This should not be surprising since it is
	    doing the C equivalent of <userinput
moreinfo="none"
>@args =
	    @_;</userinput> There can be arguments before the final
	    list.</para></listitem><listitem
><para
>T_ARRAY creates a variable called
	    <varname
>ix_${var}</varname> (in our example this is
	    <varname
>ix_array</varname>) that contains the number of
	    elements processed by T_ARRAY.</para></listitem><listitem
><para
>Memory must be allocated in which to store the new
	    integer array. T_ARRAY assumes that there is a memory
	    allocation function called <varname
>$ntype</varname> (in
	    this case <function
moreinfo="none"
>intArrayPtr</function>) that will
	    return a pointer to some memory. It is passed a single
	    argument containing the number of elements in the
	    array. Of course, this memory must be freed at the end of
	    the XS function.</para></listitem><listitem
><para
>The XS compiler works out how to copy elements from
	    the Perl list into the C array by guessing the C type of
	    the variables from the type of the array. It does this by
	    removing any mention of <quote
>Array</quote> and
	    <quote
>Ptr</quote> from the <varname
>$ntype</varname>
	    variable and then looking in the standard typemap entry
	    for the resulting string. In this example
	    <varname
>$ntype</varname> is <type
>intArrayPtr</type> so
	    each element is copied using the <type
>int</type> typemap
	    entry. </para></listitem></itemizedlist><para
>As it stands, the above code will not compile because
	  <command
moreinfo="none"
>xsubpp</command> does not know that variables of
	  type <type
>intArray *</type> need to be processed using the
	  T_ARRAY typemap entry. In order to do this we need to create
	  a file called <filename
moreinfo="none"
>typemap</filename> and put in one
	  line:</para><programlisting
format="linespecific"
>intArray *            T_ARRAY</programlisting><para
>For completeness, here is the typemap entry for T_ARRAY:</para><programlistingco
><areaspec
><area
coords="1"
id="u32"
></area><area
coords="2"
id="ntype"
></area><area
coords="3"
id="while"
></area><area
coords="4"
id="doarrayelem"
></area><area
coords="8"
id="nelem"
></area></areaspec><programlisting
format="linespecific"
>        U32 ix_$var = $argoff;
        $var = $ntype(items -= $argoff);
        while (items--) {
            DO_ARRAY_ELEM;
            ix_$var++;
        }
        /* this is the number of elements in the array */
        ix_$var -= $argoff
</programlisting><calloutlist
><callout
arearefs="u32"
><para
>Declare a new variable and set it initially to the
	    position of the first element in the list. This
	    declaration does cause problems if previous arguments have
	    used complicated typemaps themselves. This is because C
	    does not like variable declarations part way through a
	    block. This issue is discussed further in <xref
linkend="advxs.inside"
></xref></para></callout><callout
arearefs="ntype"
><para
>Allocate some memory using function
	    <varname
>$ntype</varname>. The requested number of
	    elements is calculated by using (and modifying)
	    <varname
>items</varname>. XS automatically sets this
	    variable to the total number of XS arguments. </para></callout><callout
arearefs="while"
><para
>Loop over each element until there are no more
	    remaining. <varname
>items</varname> is decremented until
	    it hits zero whilst <varname
>ix_$var</varname> is
	    incremented to provide an index into the argument
	    list.</para></callout><callout
arearefs="doarrayelem"
><para
>DO_ARRAY_ELEM is the magic used by the XS compiler
	    to indicate that an element must be copied from the stack
	    to <varname
>$var</varname>. It uses
	    <varname
>ix_$var</varname> to index into the stack and
	    derives the type of the element from the type of the
	    array.</para></callout><callout
arearefs="nelem"
><para
>Finally, reset the value of
	    <varname
>ix_$var</varname> so that it now reflects the
	    number of elements in the C array.</para></callout></calloutlist></programlistingco><para
>So far we have not said much  about the memory
	allocation function in the current example. The default
	allocator (implied by the use of the
	<function
moreinfo="none"
>Safefree</function> function in the above example)
	could look something like this:</para><programlisting
format="linespecific"
>intArray * intArrayPtr ( int num ) {
  intArray * array;

  New(0,array, num, intArray );
  return array;
}</programlisting><para
>where we simply use the <function
moreinfo="none"
>New</function> macro to
allocate <varname
>num</varname> integers and return the
pointer. Whilst this will work we still have to make sure that the
memory is freed when we have finished with it. In most cases this just
involves the use of a CLEANUP block in the XS definition since we
usually don't want to keep the memory. Since laziness is sometimes a
virtue there is another approach to memory allocation which will
obviate the need for the CLEANUP block. During the discussion of
structure handling we introduced the concept of mortality. Perl uses 
mortal variables to make sure that variables are automatically freed
when a Perl scope is exited. We can make use of this fact by
allocating memory in a Perl scalar, marking it as mortal and then
letting perl free the memory when the XS function is completed.
The memory allocation function then becomes:</para><programlisting
format="linespecific"
>intArray * intArrayPtr ( int num ) {
  SV * mortal;
  mortal = sv_2mortal( NEWSV(0, num * sizeof(int) ) );
  return (intArray *)SvPVX(mortal);
}</programlisting><para
>This function creates a new SV and makes sure that the PV part
of the SV is large enough to hold the required number of integers (the
<function
moreinfo="none"
>sizeof</function> function is used to determine how many
bytes are required for each integer). This SV is marked as mortal and
the pointer to the PV part is returned using the
<function
moreinfo="none"
>SvPVX</function> macro.  If this function is used the
CLEANUP section of <function
moreinfo="none"
>array_as_list</function> can then be
removed.</para><para
>If we place this memory allocation function before the XS code
and remove the CLEANUP section this example, once built, will sum up
all elements in an array:</para><screen
format="linespecific"
><userinput
moreinfo="none"
><prompt
moreinfo="none"
>%</prompt> perl -Mblib -MArrays -e 'print Arrays::sum_as_list(5,6,7)'</userinput>
18</screen><remark
>Do we need to show the complete example again?</remark></sect4><sect4
><title
>...as an array reference</title><para
>Just like when programming in Perl, an alternative to
      passing in a list is to pass in a reference to an array:</para><programlisting
format="linespecific"
>$sum = Arrays::sum_as_ref( \@values );</programlisting><para
>The main advantage of this technique is that multiple arrays can
be passed to a function. The XS code for this is as follows:</para><programlistingco
><areaspec
><area
coords="3"
id="avref"
></area><area
coords="7"
id="svstarstar"
></area><area
coords="10"
id="avlen"
></area><area
coords="11"
id="malloc"
></area><area
coords="14"
id="loop"
></area><area
coords="15"
id="avfetch"
></area><area
coords="16"
id="null"
></area><area
coords="19"
id="deref"
></area><area
coords="22"
id="sum"
></area></areaspec><programlisting
format="linespecific"
>int
sum_as_ref( avref )
  AV * avref;
 PREINIT:
  int len;
  int i;
  SV ** elem;
  intArray * array;
 CODE:
  len = av_len( avref ) + 1;
  array = intArrayPtr( len );

  /* copy numbers from Perl array */
  for (i=0; i&lt;len; i++) {
    elem = av_fetch( avref, i, 0);
    if (elem == NULL) {
      array[i] = 0;
    } else {
      array[i] = SvIV( *elem );
    }
  }
  RETVAL = sum( len, array );
 OUTPUT:
  RETVAL </programlisting><calloutlist
><callout
arearefs="avref"
><para
>The argument is a pointer to an AV. The default
	      typemap entry will make sure that we have an array
	      reference and will exit the program if we don't get
	      one.</para></callout><callout
arearefs="svstarstar"
><para
>Declare <varname
>elem</varname> as a pointer to a
	      pointer to an SV. This is the type of variable returned
	      by <function
moreinfo="none"
>av_fetch</function>.</para></callout><callout
arearefs="avlen"
><para
>Find out how many elements are in the array.</para></callout><callout
arearefs="malloc"
><para
>Allocate some memory for the C array using the
	      same function that we used for
	      <function
moreinfo="none"
>sum_as_list</function>.</para></callout><callout
arearefs="loop"
><para
>Loop over each element in the AV, copying it to
	      the C array.</para></callout><callout
arearefs="avfetch"
><para
>Retrieve the i'th element from the array.</para></callout><callout
arearefs="null"
><para
>A complication here is that
	      <function
moreinfo="none"
>av_fetch</function> can return
	      <type
>NULL</type> for the requested element. This means
	      that we first have to check that the pointer is valid
	      before dereferencing it.</para></callout><callout
arearefs="deref"
><para
>Copy the integer part of the SV to the C
	      array. Since <function
moreinfo="none"
>SvIV</function> expects a pointer
	      to an SV we must dereference
	      <varname
>elem</varname>.</para></callout><callout
arearefs="sum"
><para
>Finally run the <function
moreinfo="none"
>sum</function> function.</para></callout></calloutlist></programlistingco><para
>Once built this should produce the same answer as the previous
example but this time an array reference is used:</para><screen
format="linespecific"
><userinput
moreinfo="none"
><prompt
moreinfo="none"
>%</prompt> perl -Mblib -MArrays -e 'print Arrays::sum_as_ref([5,6,7])'</userinput>
18</screen><para
></para></sect4><sect4
id="advxs.arrays.num.pack"
><title
>...as a packed string</title><sidebar
><para
>In XS the sense of pack/unpack and input/output are
	  very different to that expected by a Perl programmer. INPUT
	  is used in XS to indicate data passing into C (and out
	  of Perl) and OUTPUT is used to indicate data passing out of
	  C and into Perl. More confusing is that occassionally you
	  will see the term <quote
>pack</quote> used to indicate
	  conversion of a C array to a Perl array and
	  <quote
>unpack</quote> to indicate conversion of a Perl array to
	  a C array. This is completely different to the Perl use of
	  the <function
moreinfo="none"
>pack</function> and
	  <function
moreinfo="none"
>unpack</function> functions and we will use the
	  Perl sense in this chapter. This means that a C array is a
	  packed form of a perl array. This makes sense since a C
	  array uses less memory than a perl array. These confusions
	  arise because XS exists so that Perl data can be handled by
	  the Perl internals and therefore the internals are seen as
	  the primary consumer of the data.</para></sidebar><para
>The third way to pass an array into C is to pack the
	perl array into a byte string and then pass that string into C
	where it will be treated as a C array. From perl this would
	look like the following:</para><programlisting
format="linespecific"
>$packed = pack("i*", @values);
$sum = Arrays::sum_as_packed( $packed );</programlisting><para
>In XS you could implement this as follows:</para><programlistingco
><areaspec
><area
coords="3"
id="sv"
></area><area
coords="8"
id="retrieve"
></area><area
coords="9"
id="len"
></area></areaspec><programlisting
format="linespecific"
>int
sum_as_packed( packed )
  SV * packed
 PREINIT:
  int len;
  intArray * array;
 CODE:
  array = (intArray *)SvPV( packed, PL_na );
  len = SvCUR( packed ) / sizeof(intArray);
  RETVAL = sum( len, array );
 OUTPUT:
  RETVAL</programlisting><calloutlist
><callout
arearefs="sv"
><para
>We want to interrogate the SV directly rather than
extracting a specific piece of information.</para></callout><callout
arearefs="retrieve"
><para
>Retrieve a pointer to the byte array from the SV</para></callout><callout
arearefs="len"
><para
>Calculate the number of elements in the array by
	      asking the SV for the total number of bytes and then
	      dividing by the number of bytes used to represent an
	      integer.</para></callout></calloutlist></programlistingco><para
>The main point here is that we are using the SV directly
	rather than asking XS to translate it for us. This is useful
	since the SV knows how many bytes it is holding. If this
	information is not required or if you can pass in the number
	of elements of the array as an argument<footnote
><para
>only if
	using an intermediary wrapper function. Do not ask people to
	provide information that perl already knows!</para></footnote>
	this XS code can be simplified:</para><programlistingco
><areaspec
><area
coords="2"
id="args"
></area><area
coords="4"
id="char"
></area><area
coords="6"
id="cast"
></area></areaspec><programlisting
format="linespecific"
>int
sum_as_packed2( len, packed )
  int len
  char * packed
 CODE:
  RETVAL = sum( len, (intArray *)packed );
 OUTPUT:
  RETVAL</programlisting><calloutlist
><callout
arearefs="args"
><para
>Now the length of the array is included as an argument.</para></callout><callout
arearefs="char"
><para
>Use <type
>char *</type> to indicate that we are
	      interested in the PV part of the SV. Alternatively we
	      could have associated <type
>intArray *</type> with T_PV
	      in the typemap file.</para></callout><callout
arearefs="cast"
><para
>Since we have a pointer to a <type
>char</type> we
	      have to cast the pointer to type <type
>intArray</type>
	      before passing it to the <function
moreinfo="none"
>sum</function>
	      function.</para></callout></calloutlist></programlistingco></sect4></sect3><sect3
><title
>out of C</title><para
>Arrays can be returned to Perl as either a list pushed
      onto the stack or by creating an array and returning the
      reference.  We saw in <xref
linkend="advxs.struct.hash"
></xref> how to
      return a hash reference and a list and the only difference for
      arrays is the use of <function
moreinfo="none"
>av_</function> functions rather
      than <function
moreinfo="none"
>hv_</function> functions. </para><para
>This section will highlight some additional methods for
      returning (numeric) arrays which may be useful. We put these
      here for completeness, since they are used in existing code, but
      they are probably not the best approach for new code.</para><sect4
><title
>...as a list without PPCODE</title><para
>The T_ARRAY typemap entry was used in <xref
linkend="advxs.arrays.asalist"
></xref> to pass a list into C and it
	can, in principal, also be used to return a list from C
	without having to worry about looping and using the
	<function
moreinfo="none"
>PUSHs</function> macro (see <xref
linkend="advxs.struct.hash"
></xref> for details on pushing elements
	onto the return stack).</para><para
>The main problem with this is that it only works with XS
	CODE blocks (since OUTPUT typemap entries are only used when
	the OUTPUT keyword is used in XS) but the XS compiler always
	forces a single return value. In general it is safer to ignore
	T_ARRAY for output and just use PPCODE instead.</para><para
>If you do want to use this then the easiest trick is
	simply to co-opt the CLEANUP section and make explicit use of
	the <function
moreinfo="none"
>XSRETURN</function> function. Here is an example
	of how to use T_ARRAY to return an array of integers:</para><programlistingco
><areaspec
><area
coords="1"
id="rettype"
></area><area
coords="4"
id="array"
></area><area
coords="5"
id="size"
></area><area
coords="7"
id="assign"
></area><area
coords="8"
id="setsize"
></area><area
coords="9"
id="setarr"
></area><area
coords="11"
id="output"
></area><area
coords="13"
id="cleanup"
></area></areaspec><programlisting
format="linespecific"
>intArray *
test_t_array()
 PREINIT:
  intArray test[2];
  U32 size_RETVAL;
 CODE:
  test[0] = 1; test[1] = 2;
  size_RETVAL = 2;
  RETVAL = test;
 OUTPUT:
  RETVAL
 CLEANUP:
  XSRETURN(size_RETVAL);</programlisting><calloutlist
><callout
arearefs="rettype"
><para
>The return type is now a pointer to an array. This
	      uses the same typemap we have used for the previous
	      array examples.</para></callout><callout
arearefs="array"
><para
>Create a test array in C to contain 2 elements.</para></callout><callout
arearefs="size"
><para
>T_ARRAY requires the declaration of this variable
	      (technically declared as <varname
>size_$var</varname> in
	      the typemap file but this variable will almost always be
	      associated with <varname
>RETVAL</varname>). It is used
	      by the typemap to determine how many elements in the
	      array are to be copied to the stack.</para></callout><callout
arearefs="assign"
><para
>For this example simply copy two numbers into the
	      array. </para></callout><callout
arearefs="setsize"
><para
>Store the size of the array.</para></callout><callout
arearefs="setarr"
><para
><varname
>RETVAL</varname> now points to the first
	      element of our test array.</para></callout><callout
arearefs="output"
><para
>Mark <varname
>RETVAL</varname> for output.</para></callout><callout
arearefs="cleanup"
><para
>This macro will exit the XS routine just before
	      the normal exit provided by
	      <command
moreinfo="none"
>xsubpp</command>. The argument indicates how
	      many items have been placed on the return stack.</para></callout></calloutlist></programlistingco></sect4><sect4
><title
>...as a packed string</title><para
>Just as it is possible to pass to XS a byte array
	generated by the Perl <function
moreinfo="none"
>pack</function> function (see
	<xref
linkend="advxs.arrays.num.pack"
></xref>) it is also possible to
	return a byte array that can be unpacked with the Perl
	<function
moreinfo="none"
>unpack</function> function. If you know how many
	elements are to be stored in the array at compile time XS
	provides a way or returning the packed string to Perl. This
	example returns 3 integers as a packed string:</para><programlisting
format="linespecific"
>array(int, 3)
return_packed()
 PREINIT:
  intArray test[3];
 CODE:
  test[0] = 1; test[1] = 2; test[2] = 3;
  RETVAL = test;
 OUTPUT:
  RETVAL</programlisting><para
>When compiled this code copies <userinput
moreinfo="none"
>3 x
	sizeof(int)</userinput> bytes from
	<varname
>RETVAL</varname>. They can be unpacked in perl with
	<userinput
moreinfo="none"
>unpack("i*",$retval)</userinput>.</para><para
>If the size of the return array is not known at
	compile-time the bytes must be copied to the perl variable
	using a modified form of the T_OPAQUEPTR typemap entry:</para><programlisting
format="linespecific"
>intArray *
return_npacked()
 PREINIT:
  U32 size_RETVAL;
  intArray test[3];
 CODE:
  test[0] = 1; test[1] = 2; test[2] = 3;
  size_RETVAL = 3;
  RETVAL = test;
 OUTPUT:
  RETVAL</programlisting><para
>with a corresponding typemap entry of:</para><programlisting
format="linespecific"
>intArray *	T_OPAQUEARRAY

OUTPUT
T_OPAQUEARRAY
	sv_setpvn($arg, (char *)$var, size_$var * sizeof(*$var));</programlisting><para
>Here we associate <type
>intArray *</type> with T_OPAQUEARRAY.
The only difference between this and T_OPAQUEPTR is that we have
used the <varname
>size_$var</varname> variable to indicate how many
elements to copy.</para><para
>In general, if packed strings are returned and the bytes
	are not required directly, it is usually better to provide a
	perl wrapper to the XS function so that the bytes are hidden
	from the caller.</para><sidebar
><para
>When looking through the typemap file you will see
	  entries called T_PACKED and T_PACKEDARRAY. These are not
	  designed for dealing with packed strings!</para></sidebar></sect4></sect3><sect3
><title
>The Perl Data Language</title><para
>If you are dealing with large or multi-dimensional
	arrays the techniques described so far will probably prove
	inadequate and you should seriously consider changing approach
	and using PDL.  The Perl Data Language (<ulink
url="http://pdl.perl.org"
>PDL</ulink>) was developed as a
	means to handle multi-dimensional arrays in perl compactly and
	efficiently. These three issues are extremely important in
	scientific computing and image processing for the following
	reasons:</para><remark
>Reviewer suggests a diagram indicating what a
	multi-dimensional array really looks like. Presumably 3-d
	example as a diagram of stacked 2-d grids</remark><variablelist
><varlistentry
><term
>multi-dimensionality</term><listitem
><para
>Perl has no real concept of multi-dimensional
	      arrays. An array can have references to other arrays in
	      order to simulate additional dimensions but there is
	      nothing in the language to force the same number of
	      elements in each row or column. When the dimensionality
	      is greater than two the perl approach becomes unwieldy
	      and it is very time consuming to check the
	      dimensionality of the data.  The following code shows
	      how perl handles a 1-, 2- and 3-d array:</para><programlisting
format="linespecific"
>@oned   = ( 1, 2 );
@twod   = ( [1,2], [3,4] );
@threed = ( [ [1,2], [3,4] ],  [ [5,6],[7,8] ] );</programlisting></listitem></varlistentry><varlistentry
><term
>compactness</term><listitem
><para
>When the number of elements in array is large, the
	      representation of that array can have an enormous effect
	      on the memory requirements of the program. In <xref
linkend="perlvar.arrays"
></xref> we saw that both Perl arrays
	      and Perl scalars have a significant memory overhead
	      compared to that required for single numbers but that
	      this is accepted because of the enormous gain in
	      functionality this brings. In situations where we are
	      dealing with blocks of numbers this flexibility is not
	      required. As an example, in the 3-d array above, this
	      requires 7 perl arrays, 8 integer scalars and 6
	      references. On a 32-bit linux system this is about 128
	      bytes for just 8 numbers (assuming 12 bytes for
	      <type
>sv_any</type>, 16 bytes for a <type
>xpviv</type>
	      and 44 bytes for a <type
>xpvav</type>). A C
	      representation will require just 32 bytes (8 elements of
	      4 bytes each). Clearly for arrays of a million pixels
	      the closer the representation is to pure C the more
	      significant will be the saving on memory.</para></listitem></varlistentry><varlistentry
><term
>speed</term><listitem
><para
>So far in this section we have shown that passing
	      arrays into an out of perl requires loops to pack and
	      unpack the array each time. In cases where a large data
	      array is being passed continually to and from C the time
	      overhead in doing this will be enormous. Additionally,
	      for N-dimensional data arrays the large number of
	      dereferences required to return the data values will be
	      significant.</para></listitem></varlistentry></variablelist><para
>It is therefore not surprising that PDL was developed by
        scientists<footnote
><para
>The primary developers of PDL were
        Karl Glazebrook (an astronomer), Tuomas Lukka and Christian
        Soeller<remark
>Need to check what Christian and Tuomas
        do</remark></para></footnote> as an attempt to solve these
        problems without having to use expensive proprietary packages
        or a language other than Perl!</para><para
>PDL deals with the problems of dimensionality, speed and
	compactness by using a PDL object (known as a
	<quote
>piddle</quote><footnote
><para
>Karl Glazebrook is
	English!</para></footnote>) to store the data itself and
	information such as the dimensionality and data type. In
	reality a piddle is a C struct for efficiency and the data is
	stored as a normal C array<footnote
><para
>Version 1 of PDL
	stored the data as a packed string in an SV exactly as shown
	<xref
linkend="advxs.arrays.num.pack"
></xref>. Version 2 made the
	object more opaque.</para></footnote>. We will not
	attempt to be a complete guide to PDL in this book but
	more importantly for this book, we will show how to interact with
	PDL from within XS.</para><sect4
><title
>A primer</title><para
>Rather than try to cover all of PDL here is a quick
	  introduction. PDL provides a shell for interactive use
	  (called <command
moreinfo="none"
>perldl</command>) which can be very useful
	  for general experimentation with Perl as well as for
	  PDL. Here are some examples that will hopefully provide a
	  taster (they can be typed in at the
	  <command
moreinfo="none"
>perldl</command> shell or in a program in
	  conjunction with <userinput
moreinfo="none"
>use PDL;</userinput>):</para><variablelist
><varlistentry
><term
>$a = pdl([0,1,2],[3,4,5]);</term><listitem
><para
>Create a 3x2 piddle</para></listitem></varlistentry><varlistentry
><term
>$a = sequence(3,2);</term><listitem
><para
>Create the same piddle using the
		<function
moreinfo="none"
>sequence</function> command. This is
		effectively an n-dimensional version of the
		<function
moreinfo="none"
>..</function> Perl operator.</para></listitem></varlistentry><varlistentry
><term
>print $a;</term><listitem
><para
>Print a stringified form of the piddle. This
works for reasonably sized piddles. Here the output is:</para><screen
format="linespecific"
>[
 [0 1 2]
 [3 4 5]
]</screen></listitem></varlistentry><varlistentry
><term
>$a *= 2;</term><listitem
><para
>Multiply each element in the piddle by
		<literal
moreinfo="none"
>2</literal>. <varname
>$a</varname> is now:</para><screen
format="linespecific"
>[
 [ 0  2  4]
 [ 6  8 10]
]</screen><para
>In PDL the standard operators (+,-,*,/ etc) are overloaded so
that piddles act like normal perl variables. By default PDL does not
do matrix operations on piddles (but it can be made to).</para></listitem></varlistentry><varlistentry
><term
>$b = $a-&gt;slice("1,");</term><listitem
><para
>Extract a slice from <varname
>$a</varname>. Here
we use object notation to invoke the slice method. In this case we are
extracting column 1:</para><screen
format="linespecific"
>[
 [2]
 [8]
]</screen></listitem></varlistentry><varlistentry
><term
>$c = pdl(10,20); $b += $c;</term><listitem
><para
>Create a 2 element piddle and add it to
		<varname
>$b</varname> which becomes:</para><screen
format="linespecific"
>[
 [32]
 [38]
]</screen><para
>More importantly, <varname
>$a</varname> now
		becomes:</para><screen
format="linespecific"
>[
 [ 0 32  4]
 [ 6 38 10]
]</screen><para
>because <varname
>$b</varname> is still related
		to <varname
>$a</varname> so that changes in one are
		reflected in the other. This is one of the most
		powerful features of PDL.</para></listitem></varlistentry></variablelist><para
>PDL is a powerful tool for manipulating array data and
	  should be considered seriously for any project that is
	  dealing with arrays and perl.</para></sect4><sect4
id="advxs.xspdl"
><title
>PDL and XS</title><para
>Now that we have shown the utility of PDL when using
	  arrays we will now show how to use PDL from XS. When viewed
	  from Perl a PDL is seen as an object but from within C a PDL
	  is represented as a structure (denoted by a <type
>pdl
	  *</type>). In general you should only use PDL with XS if you
	  want direct access to the structure. PDL provides easier
	  methods of passing data to C routines with the
	  <classname
>PDL::PP</classname> (more details of which can be
	  found in <xref
linkend="altxs.pdlpp"
></xref>) and
	  <classname
>PDL::CallExt</classname> modules.</para><para
>The PDL infrastructure provides typemap entries to
	  handle the conversion from/to the PDL structure:</para><programlisting
format="linespecific"
>pdl *                   T_PDL

INPUT

T_PDL
        $var = PDL-&gt;SvPDLV($arg)

OUTPUT

T_PDL
        PDL-&gt;SetSV_PDL($arg,$var);</programlisting><para
>These typemap entries use the programming interface
	  (API) provided by the PDL core to translate perl objects to
	  the PDL structures. This raises the issue of how to use C
	  functions that are provided by a separate perl module in
	  your XS code. For external C libraries you simply make sure
	  that you link against the library when the XS module is
	  built. The PDL shared library<footnote
><para
>Assuming your
	  perl can support dynamic loading of
	  libraries</para></footnote> is installed somewhere in the
	  Perl site library tree in
	  <filename
moreinfo="none"
>PDL/Core/Core.so</filename> (on many Unix
	  systems). There are a number of difficulties associated with
	  attempting to use this library directly from other XS
	  modules:</para><orderedlist
inheritnum="ignore"
continuation="restarts"
><listitem
><para
>In order to link your PDL XS code against this
	      library you would first need to locate it (using the
	      <classname
>Config</classname> module) and then convince
	      MakeMaker that it should be included even though it does
	      not look like a standard library (this can be done by
	      fooling MakeMaker into thinking that
	      <filename
moreinfo="none"
>Core.so</filename> is an object file).</para></listitem><listitem
><para
>Each PDL-based XS module will have to jump
	      through the same hoops.</para></listitem></orderedlist><para
>To simplify access to the PDL API, pointers to the
	  public functions are stored in a C structure. A pointer to
	  this structure is then stored in a Perl variable in the PDL
	  namespace. In order to use a PDL function all that is
	  required is to retrieve this pointer from the Perl
	  variable. This is the approach also taken by the perl/Tk
	  module. XS provides a means of doing this at load time using
	  the BOOT: section and PDL recommends the following
	  code:</para><programlistingco
><areaspec
><area
coords="2"
id="pdlinc"
></area><area
coords="3"
id="corestruct"
></area><area
coords="4"
id="coresv"
></area><area
coords="10"
id="pdlshare"
></area><area
coords="11"
id="pdlnull"
></area><area
coords="13"
id="pdlcore"
></area></areaspec><programlisting
format="linespecific"
>#include "pdl.h"
#include "pdlcore.h"
static Core * PDL; 
SV* CoreSV;       

MODULE = XXXX   PACKAGE = XXXX

BOOT:
   /* Get pointer to structure of core shared C routines */
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "This module requires use of PDL::Core first");
   PDL = (Core*) (void*) SvIV( CoreSV );  /* Core* value */
</programlisting><calloutlist
><callout
arearefs="pdlinc"
><para
>Standard include files for PDL. These declare
		the PDL constants and the function structure.</para></callout><callout
arearefs="corestruct"
><para
>Declare a pointer to a <type
>Core</type>. A
		<type
>Core</type> is typedeffed to <type
>struct
		Core</type> in <filename
moreinfo="none"
>pdlcore.h</filename>. It is
		declared static since we want to retain the value each
		time we call a function.</para></callout><callout
arearefs="coresv"
><para
>A pointer to an SV. This is used to store the SV
		retrieved from the PDL namespace.</para></callout><callout
arearefs="pdlshare"
><para
>Get the variable <varname
>PDL::SHARE</varname></para></callout><callout
arearefs="pdlnull"
><para
>We must load the
		<classname
>PDL::Core</classname> module before
		attempting to load this module else
		<varname
>PDL::SHARE</varname> will not be
		defined. This is achieved most easily simply by making
		sure that our perl module loads
		<varname
>PDL::Core</varname> before calling the
		<methodname
>bootstrap</methodname> method.</para></callout><callout
arearefs="pdlcore"
><para
>Retrieve the integer part of the SV, cast it to
		type <type
>Core*</type> and store it in a C variable
		called <varname
>PDL</varname>.</para></callout></calloutlist></programlistingco><para
>Now we can see that the standard PDL typemap entries
	  assume that we have done the above because they use the
	  variable <varname
>PDL</varname> as a pointer to a structure
	  in order to run the conversion methods. Now we can use any
	  public PDL function simply by using this variable. </para><para
>With this ground work in place we can now write a PDL
	  version of our routine to sum the elements in an array using
	  the <function
moreinfo="none"
>sum</function> function presented
	  earlier<footnote
><para
>Of course we can just use the PDL
	  <methodname
>sum</methodname> method
	  directly!</para></footnote>. Here is the XS snippet:</para><programlistingco
><areaspec
><area
coords="3"
id="inpdl"
></area><area
coords="5"
id="convertpdl"
></area><area
coords="6"
id="mainpdl"
></area></areaspec><programlisting
format="linespecific"
>int
sum_as_pdl( in )
  pdl * in
 CODE:
  PDL-&gt;converttype( &amp;in, PDL_L, 1);
  RETVAL = sum( in-&gt;nvals, (intArray *)in-&gt;data);
 OUTPUT:
  RETVAL</programlisting><calloutlist
><callout
arearefs="inpdl"
><para
>Here we assume that we have a PDL argument. If
		an array is passed in it will be rejected by
		<function
moreinfo="none"
>SvPDLV</function>.</para></callout><callout
arearefs="convertpdl"
><para
>A PDL is typed (by default all PDLs are double
		precision) and this line is responsible for converting
		it to an integer type so that it can be summed by our
		function. This example is slightly naughty because it
		converts the input PDL to integer format. In a real
		application either a copy should be made so that the
		input piddle is not modified or a
		<function
moreinfo="none"
>sum</function> should be written for each
		data type.</para></callout><callout
arearefs="mainpdl"
><para
>Here we find the number of elements in the PDL
		using the <varname
>nvals</varname> part of the
		structure and retrieve the values themselves using the
		<varname
>data</varname> part.</para></callout></calloutlist></programlistingco><para
>In order to compile this XS code we need to generate a
	  perl module wrapper that will load PDL itself and a
	  <filename
moreinfo="none"
>Makefile.PL</filename> that will correctly locate
	  the PDL include files from the installed tree. Here is a
	  suitable <filename
moreinfo="none"
>pm</filename> file:</para><programlisting
format="linespecific"
>package Arrays;

use PDL::Core;
use base qw/ DynaLoader /;

our $VERSION;

$VERSION = '1.00';

bootstrap Arrays;</programlisting><para
>and corresponding
	  <filename
moreinfo="none"
>Makefile.PL</filename>:</para><programlistingco
><areaspec
><area
coords="7"
id="make.pdlinc"
></area><area
coords="13"
id="make.prereq"
></area></areaspec><programlisting
format="linespecific"
>use ExtUtils::MakeMaker;
use File::Spec;
use Config;

my $pdlinc = '-I'.
             File::Spec-&gt;catdir($Config{'installsitearch'},
                                "PDL", "Core");

# Write the makefile
WriteMakefile(
              'NAME'=&gt; 'Arrays',
              'VERSION_FROM' =&gt; 'Arrays.pm', # finds $VERSION
              'PREREQ_PM' =&gt; { 'PDL' =&gt; '2.0'},
              'INC'       =&gt; $pdlinc,
             );
</programlisting><calloutlist
><callout
arearefs="make.pdlinc"
><para
>The PDL-specific include files
		(<filename
moreinfo="none"
>pdl.h</filename> and
		<filename
moreinfo="none"
>pdlcore.h</filename>) are installed as part
		of PDL into the perl
		<filename
moreinfo="none"
>installsitearch</filename> directory. This
		line uses the <classname
>Config</classname> module to
		determine that location and
		<classname
>File::Spec</classname> to append the PDL
		directory to that location.</para></callout><callout
arearefs="make.prereq"
><para
>The PDL internals were completely rewritten for
		version 2.0. This line instructs MakeMaker to check
		the version of the installed PDL and to complain if
		the version number is less than 2.0.</para></callout></calloutlist></programlistingco></sect4></sect3><sect3
><title
>Benchmarks</title><para
>So far we have shown 4 ways of passing numeric data into
	C for processing and the associated ways of returning arrays
	back to Perl. These methods can be summarised as:</para><orderedlist
inheritnum="ignore"
continuation="restarts"
><listitem
><para
>Using a list.</para></listitem><listitem
><para
>Using a reference to an array.</para></listitem><listitem
><para
>Using a packed string.</para></listitem><listitem
><para
>Using a PDL object.</para></listitem></orderedlist><para
>To finish off this section on arrays we will now write a
	simple benchmark to compare the efficiency of these techniques
	using the summing code described earlier with the exception
	that we will use the native PDL <function
moreinfo="none"
>sum</function>
	function.</para><programlisting
format="linespecific"
>use Benchmark;
use Arrays;
use PDL;
use strict;

my @array = (0..100);
my $pdl  = sequence(long,101);

timethese(-3, {
	       'PDL' =&gt; sub { sum($pdl); },
	       'List'=&gt; sub { Arrays::sum_as_list(@array) },
	       'Ref' =&gt; sub { Arrays::sum_as_ref(\@array) },
	       'Pack'=&gt; sub { Arrays::sum_as_packed( pack("i*", @array) ); },
	      })</programlisting><para
>The above benchmark runs for at least 3 seconds and gives the following
	output:</para><screen
format="linespecific"
>Benchmark: running List, PDL, Pack, Ref, each for at least 3 CPU seconds...
      List:  3 wallclock secs ( 3.28 usr +  0.00 sys =  3.28 CPU) @ 110633.84/s (n=362879)
       Ref:  2 wallclock secs ( 3.01 usr +  0.00 sys =  3.01 CPU) @ 77112.62/s (n=232109)
      Pack:  4 wallclock secs ( 3.34 usr +  0.00 sys =  3.34 CPU) @ 52336.53/s (n=174804)
       PDL:  4 wallclock secs ( 3.08 usr +  0.00 sys =  3.08 CPU) @ 10284.09/s (n=31675)</screen><para
>Since we are asking <classname
>Benchmark</classname> to
	run for a specific amount of time the important numbers are in
	the last but one column; the number of times the subroutine
	was executed per second. This column indicates that for a
	small array (in this case 101 elements) a list is ten times
	faster than a PDL, twice as fast as using pack and one and a
	half times faster than using a reference. The PDL solution is
	surprisingly slow in this case but this is in part due to the
	additional overhead that is present in the PDL system but
	which is not being used by our example. The packed string is
	expected to be slow since it calls an additional Perl function
	each time. The reference is slower than list due to the
	overhead of taking the reference. If we now increase the size
	of the array by two orders of magnitude to 10000 elements we
	get a different result:</para><screen
format="linespecific"
>Benchmark: running List, PDL, Pack, Ref, each for at least 3 CPU seconds...
      List:  3 wallclock secs ( 3.20 usr +  0.02 sys =  3.22 CPU) @ 1495.65/s (n=4816)
       PDL:  4 wallclock secs ( 3.20 usr +  0.00 sys =  3.20 CPU) @ 4372.81/s (n=13993)
      Pack:  3 wallclock secs ( 3.14 usr +  0.00 sys =  3.14 CPU) @ 448.09/s (n=1407)
       Ref:  3 wallclock secs ( 3.08 usr +  0.00 sys =  3.08 CPU) @ 917.21/s (n=2825)</screen><para
>Now PDL is much faster than the rest so that the
	overhead due to the PDL infrastructure is now becoming
	insignificant when compared to the cost of converting large
	arrays into C data structures.</para><para
>Of course, specific benchmarks can not tell the whole
	story and the final choice you make depends on many different
	factors. For example, if you require multiple array arguments
	then you can not use a simple list; if you want maximal
	distribution you may not want to insist on the user installing
	PDL.</para></sect3></sect2><sect2
id="advxs.char.strings"
><title
>Character strings</title><para
>We saw in <xref
linkend="cadv.stringarr"
></xref> that an array of
      strings is represented in C as an array of pointers that point
      to the memory location of the start of each string; a string is
      an array of characters and a string array is an array of
      pointers. In general for XS the <type
>char**</type> can be
      created and populated just as for any other array although care
      must be taken if the new array is to persist after the call to
      the XS function. This is because in the simple case, you simply
      copy the pointers from the SV's and use them but if you return
      to Perl you can not guarantee that the SV will still be around
      at a later date. In that case you will have to take copies of
      the entire string rather than just storing the pointer.</para><para
>Converting a <type
>char**</type> to a Perl
      array is simply a case of stepping through the C array and
      copying the contents to the Perl array.</para><para
>The following XS code demonstrates both techniques by
      copying an input array to a <type
>char**</type> and then copying
      that back onto the output stack. Variants involving output
      references or input lists will be very similar and this example
      does not have complete error checking.</para><programlistingco
><areaspec
><area
coords="3"
id="inavref"
></area><area
coords="12"
id="mortalspace"
></area><area
coords="17"
id="svpv"
></area><area
coords="22"
id="newsvpv"
></area></areaspec><programlisting
format="linespecific"
>void
copy_char_arr( avref )
   AV * avref;
  PREINIT:
   char ** array;
   int len;
   SV ** elem;
   int i;
  PPCODE:
   len = av_len( avref ) + 1;
   /* First allocate some memory for the pointers */
   array = (char**) get_mortalspace( sizeof(void *) * len );   

   /* Loop over each element copying pointers to the new array */
   for (i=0; i&lt;len; i++) {
     elem = av_fetch( avref, i, 0);
     array[i] = SvPV( *elem, PL_na );
   }

   /* Now copy it back onto the stack */
   for (i=0; i&lt;len; i++) { 
     XPUSHs( sv_2mortal( newSVpv( array[i], 0)));
   }</programlisting><calloutlist
><callout
arearefs="inavref"
><para
>In this example the input is expected to be a
reference to an array and the output is a list:</para><funcsynopsis
><funcprototype
><funcdef
>@copy = <function
moreinfo="none"
>copy_char_arr</function></funcdef><paramdef
>\@src</paramdef></funcprototype></funcsynopsis></callout><callout
arearefs="mortalspace"
><para
>Get some temporary storage to hold the array of
	    pointers. The <function
moreinfo="none"
>get_mortalspace</function> is
	    identical to the <function
moreinfo="none"
>intArrayPtr</function> function
	    shown earlier except that it takes the number of bytes as
	    argument rather than the number of integers.</para></callout><callout
arearefs="svpv"
><para
>Retrieve the pointer from the SV (converting it to a
	    PV if required) and then store it in the array. If it was
	    necessary to copy the string first we would also need to
	    allocate some memory for it here.</para></callout><callout
arearefs="newsvpv"
><para
>Copy each string from the string array back into a
	    new SV and push it onto the argument stack.</para></callout></calloutlist></programlistingco></sect2></sect1><sect1
id="advxs.cb"
><title
>Callbacks</title><para
>A <firstterm
>callback</firstterm> is the name given to a user supplied
function that is called by another function. The classic example of
callbacks in perl is the <classname
>Tk</classname> module. Whenever a
Tk event occurs (for example, a button is pushed on the GUI) Tk sees
whether a perl subroutine should be called to process the event. The
following code shows how a Tk callback can be set up:</para><example
id="advxs.tkeg"
><title
>A simple <classname
>Tk</classname> callback</title><programlisting
format="linespecific"
>use Tk;
use strict;

my $MW = new MainWindow;
my $button = $MW-&gt;Button( -text =&gt; "Exit",
                          -command =&gt; sub { exit; } );
$button-&gt;pack();
MainLoop;</programlisting></example><para
>If this program is run it will put up a window containing a single
button. If the button is pressed the callback associated with the
button (configured using the <option
>-command</option> option) will be
executed and the program will therefore exit. The callback is not
called directly by user code, it is called from the event loop from C
code.</para><para
>The main difficulty handling callbacks in XS is that perl stores
subroutines in a <type
>CV</type> whereas C callbacks are implemented
as pointers to a C function. In order for C to call a perl subroutine
an intermediate function has to be inserted that knows about Perl.
This indirection leads to all the complications associated with using
callbacks from perl.</para><para
>In general there are usually three types of callbacks that must be handled:</para><itemizedlist
><listitem
><para
>A callback that is used for a single command with return
	passing back to perl once the callback has been used. This is
	common in the POSIX <function
moreinfo="none"
>qsort</function> function and
	the unix search functions (e.g. <function
moreinfo="none"
>bsearch</function>).</para></listitem><listitem
><para
>A single callback that is registered at one point in
	the program and then executed some time later (for example an
	error handler)</para></listitem><listitem
><para
>Multiple subroutines registered as callbacks that can be
	called at any time (event driven programs are examples of
	this)</para></listitem></itemizedlist><para
>We will cover each of these types in turn.</para><sect2
id="advxs.cb.imm"
><title
>Immediate Callbacks</title><para
>The simplest type of callback is one where the C function
executes given the supplied callback and then completes before
returning back from XS. The C <function
moreinfo="none"
>qsort</function> function
provides an excellent example of this. This function can be used to 
sort arrays and used to be what Perl used to implement the
Perl <function
moreinfo="none"
>sort</function> routine. The calling signature is:</para><funcsynopsis
><funcprototype
><funcdef
>void <function
moreinfo="none"
>qsort</function></funcdef><paramdef
>void *<parameter
moreinfo="none"
>base</parameter></paramdef><paramdef
>size_t <parameter
moreinfo="none"
>nel</parameter></paramdef><paramdef
>size_t <parameter
moreinfo="none"
>width</parameter></paramdef><paramdef
>void *<parameter
moreinfo="none"
>compar</parameter></paramdef></funcprototype></funcsynopsis><para
>where <parameter
moreinfo="none"
>base</parameter> is a pointer to the start of
the array, <parameter
moreinfo="none"
>nel</parameter> is the number of elements in the
array, <parameter
moreinfo="none"
>width</parameter> is the number of bytes used to
represent each element and <parameter
moreinfo="none"
>compar</parameter> is a pointer
to a function that is used to compare individual elements of the array.
It is the <parameter
moreinfo="none"
>compar</parameter> function that holds the C callback.
Obviously the Perl interface to this function should behave like the
standard <function
moreinfo="none"
>sort</function> function, that is:</para><programlisting
format="linespecific"
>@sorted = qsorti \&amp;compar, @unsorted;</programlisting><para
>We are calling the function <function
moreinfo="none"
>qsorti</function> to indicate
that this sort function can only be used to sort arrays of
integers. This simplifies the example code and allows us to focus on
the implementation of the callback rather than the complication of
handling all data types.  For this examplee we are going to use a
module called <classname
>CallBack</classname>. The following XS code
implements the <function
moreinfo="none"
>qsorti</function> function:</para><programlistingco
><areaspec
><area
coords="5"
id="tdef.intarr"
></area><area
coords="9"
id="stat.qsortsv"
></area><area
coords="13"
id="intarrayptr"
></area><area
coords="20"
id="qsorti.cb"
></area><area
coords="22"
id="vardecl"
></area><area
coords="26"
id="enter"
></area><area
coords="31"
id="xpush"
></area><area
coords="34"
id="putback"
></area><area
coords="36"
id="callsv"
></area><area
coords="38"
id="spagain"
></area><area
coords="40"
id="croak"
></area><area
coords="43"
id="answer"
></area><area
coords="45"
id="leave"
></area><area
coords="48"
id="retans"
></area><area
coords="51"
id="module"
></area><area
coords="54"
id="qsorti"
></area><area
coords="55"
id="svarg"
></area><area
coords="59"
id="proto"
></area><area
coords="61"
id="store"
></area><area
coords="62"
id="qsort"
></area><area
coords="65"
id="unpack"
></area></areaspec><programlisting
format="linespecific"
>#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

typedef int intArray;


/* Static memory for qsort callback */
static SV * qsortsv;

/* Routine to allocate memory for integer array */
/* Allocate the memory as a mortal SV so that it is freed automatically */
intArray * intArrayPtr ( int num ) {
  SV * mortal;
  mortal = sv_2mortal( NEWSV(0, num * sizeof(intArray) ) );
  return (intArray *)SvPVX(mortal);
}

/* The callback for qsort */
int qsorti_cb( const void *a, const void *b) {

  dSP;
  int count;
  int answer;

  ENTER;
  SAVETMPS;
  PUSHMARK(SP);

  /* Push some SVs onto the stack with the values of a and b */
  XPUSHs(sv_2mortal(newSViv(*(int *)a)));
  XPUSHs(sv_2mortal(newSViv(*(int *)b)));

  PUTBACK;

  count = call_sv(qsortsv, G_SCALAR );

  SPAGAIN;

  if (count != 1)
      croak("User defined qsort callback returned more than 1 value\n");

  answer = POPi;

  FREETMPS;
  LEAVE;

  return answer;
}

MODULE = CallBack		PACKAGE = CallBack		

void
qsorti(cb, array, ...)
  SV * cb
  intArray * array
 PREINIT:
  U32 i;
 PROTOTYPE: &amp;@
 PPCODE:
  qsortsv = cb;
  qsort( array, ix_array, sizeof(int), qsorti_cb);

  /* now need to push the elements back onto the stack */
  for ( i =0; i &lt; ix_array; i++) {
    XPUSHs(sv_2mortal(newSViv(array[i])));
  }</programlisting><calloutlist
><callout
arearefs="tdef.intarr"
><para
>We create a new type based on <type
>int</type> so
that we can associate it with the T_ARRAY typemap.</para></callout><callout
arearefs="stat.qsortsv"
><para
>This is some static memory that is used to store the
code reference. This is required because our C callback has to have
access to the Perl code reference.</para></callout><callout
arearefs="intarrayptr"
><para
>This is called automatically as part of the T_ARRAY
typemap entry. It is used to dynamically allocate memory for the C
integer array. It uses a mortal SV to allocate the memory rather than
the <function
moreinfo="none"
>New</function> macro. Doing this allows us to not worry
about freeing the memory since Perl will do it automatically when the
XS function returns.</para></callout><callout
arearefs="qsorti.cb"
><para
>The C function that is called by
	    <function
moreinfo="none"
>qsort</function></para></callout><callout
arearefs="vardecl"
><para
>Declare variables that we
need. <function
moreinfo="none"
>dSP</function> is just a macro that gives us access to
Perl's argument stack.</para></callout><callout
arearefs="enter"
><para
><function
moreinfo="none"
>ENTER</function>,
	    <function
moreinfo="none"
>SAVETMPS</function> and
	    <function
moreinfo="none"
>PUSHMARK</function> are always used on entry to
	    a callback to allow perl to store the current status of
	    the stack. These are paired with
	    <function
moreinfo="none"
>PUTBACK</function>,
	    <function
moreinfo="none"
>FREETMPS</function> and
	    <function
moreinfo="none"
>LEAVE</function></para></callout><callout
arearefs="xpush"
><para
>Push the arguments supplied by
<function
moreinfo="none"
>qsort</function> on to the stack so that our perl
callback can access them.</para></callout><callout
arearefs="putback"
><para
>This indicates that we have finished configuring the
	    stack for our Perl function. It forms the end bracket for
	    the <function
moreinfo="none"
>PUSHMARK</function></para></callout><callout
arearefs="callsv"
><para
>This calls the perl code block contained in
<varname
>qsortsv</varname> and returns the number of arguments that
were placed onto the stack by the subroutine. The G_SCALAR flag
indicates that we are calling the code block in a scalar context.</para></callout><callout
arearefs="spagain"
><para
>Since the stack no longer reflects the state it was
in on entry (because the perl subroutine we just called has messed
with it) we use <function
moreinfo="none"
>SPAGAIN</function> to reset it.</para></callout><callout
arearefs="croak"
><para
>In the unlikely event that more than one argument
was returned from the perl subroutine we shut down the program. This
should not happen because we forced scalar context.</para></callout><callout
arearefs="answer"
><para
>Read the answer (as an integer) off the stack.</para></callout><callout
arearefs="leave"
><para
>Free any temporary SVs that were created (for
	    example the two that we pushed onto the stack) and leave
	    the current context.</para></callout><callout
arearefs="retans"
><para
>Return the answer to <function
moreinfo="none"
>qsort</function></para></callout><callout
arearefs="module"
><para
>Begin the XS code.</para></callout><callout
arearefs="qsorti"
><para
>Our XS function is called
	    <function
moreinfo="none"
>qsorti</function> and it takes a code reference
	    and variable length list as arguments. The list will be
	    processed using the T_ARRAY typemap entry.</para></callout><callout
arearefs="svarg"
><para
>We use a simple SV as argument since the
	    <function
moreinfo="none"
>call_sv</function> function can automatically
	    deal with an SV containing a reference to a CV.</para></callout><callout
arearefs="proto"
><para
>Specify a prototype for the XS function. This
	    prototype matches that of the Perl
	    <function
moreinfo="none"
>sort</function> function.</para></callout><callout
arearefs="store"
><para
>Here we store the code reference in a static
	    variable for later retrieval by our C callback.</para></callout><callout
arearefs="qsort"
><para
>Run the normal C <function
moreinfo="none"
>qsort</function> function
	    using our array and the C callback that we defined at the
	    top of the file. The <varname
>ix_array</varname> variable
	    is defined and set by the T_ARRAY typemap.</para></callout><callout
arearefs="unpack"
><para
>Finally we unpack the integer array and push it onto
	    the return argument stack.</para></callout></calloutlist></programlistingco><para
>We also need a private <filename
moreinfo="none"
>typemap</filename> to indicate that 
an <type
>intArray *</type> should be processed using the T_ARRAY
typemap entry:</para><programlisting
format="linespecific"
>intArray *	T_ARRAY</programlisting><para
>Once this module is compiled you will be able to do the
following:</para><programlisting
format="linespecific"
>use strict;
use CallBack;

my @unsorted = (20,4,6,5,10,1);

my @sorted =  CallBack::qsorti { $_[0] &lt;=&gt; $_[1] } @unsorted;
print join("-",@sorted);</programlisting><para
>The only differences between this and the normal
<function
moreinfo="none"
>sort</function> function are that it only sorts integer
arrays and there is no special use of <varname
>$a</varname> and
<varname
>$b</varname>. This means that <varname
>@_</varname> must be
used to obtain the sort arguments.</para><para
>To summarize, we had to do the following to use the callback:</para><orderedlist
inheritnum="ignore"
continuation="restarts"
><listitem
><para
>Write a C function that can be used as the callback
	  and then use this function to configure the stack and call
	  the perl subroutine.</para></listitem><listitem
><para
>Store the code reference (as an <type
>SV*</type>) in
	  some static memory for later retrieval.</para></listitem><listitem
><para
>Call the C function (in this case
	  <function
moreinfo="none"
>qsort</function>) using our intermediary C
	  function as the callback.</para></listitem></orderedlist></sect2><sect2
id="advxs.cb.def"
><title
>Deferred Callbacks</title><para
>A deferred callback is one where the callback is registered
      with one command but called from another later in the program. A
      common example of this is an error handler. The error handler is
      registered early on in the program but it is only called when an
      error occurs. </para><para
>To demonstrate this usage we will use our existing <function
moreinfo="none"
>qsort</function> example but change the Perl calling interface to:
      </para><funcsynopsis
><funcprototype
><funcdef
>void <function
moreinfo="none"
>register_qsort_cb</function></funcdef><paramdef
><parameter
moreinfo="none"
>\&amp;callback</parameter></paramdef></funcprototype></funcsynopsis><funcsynopsis
><funcprototype
><funcdef
>@sorted = <function
moreinfo="none"
>qsorti_cb</function></funcdef><paramdef
><parameter
moreinfo="none"
>@unsorted</parameter></paramdef></funcprototype></funcsynopsis><para
>The obvious implementation of this is to simply split the existing XSUB entry into two parts:</para><programlisting
format="linespecific"
>void
register_qsort_cb( cb )
  SV * cb
 CODE:
  qsortsv = (SV *) cb;

void
qsorti_cb(array, ...)
  intArray * array
 PREINIT:
  U32 i;
 PPCODE:
  qsort( array, ix_array, sizeof(int), qsorti_cb);

  /* now need to push the elements back onto the stack */
  for ( i =0; i &lt; ix_array; i++) {
    XPUSHs(sv_2mortal(newSViv(array[i])));
  }</programlisting><para
>The correspondingly modified test program would be:</para><programlisting
format="linespecific"
>use strict;
use CallBack;

CallBack::register_qsort_cb( sub {$_[0] &lt;=&gt; $_[1] } );
my @unsorted = (20,4,6,5,10,1);
my @sorted = CallBack::qsorti_cb( @unsorted );
print join("-",@sorted);</programlisting><para
>If we run this we get the following:</para><screen
format="linespecific"
>Undefined subroutine &amp;main::20 called at ./cbtest line 6 </screen><para
>(or something similar depending on your system). What is
happening here? The problem is that the SV stored in
<varname
>qsortsv</varname> has been reallocated by perl between
registering it and using it. Specifically in this case the SV now
seems to be holding the first element of the new array. Since we are
only storing a pointer to an SV that is meant to contain a reference
to a subroutine (or a name of a sub) we are sensitive to the SV
changing.  To overcome this problem we can either copy the contents of
the SV to a new SV when storing the callback or extract the CV that is
referenced by the SV and store a pointer to that instead. Changing
<function
moreinfo="none"
>register_qsort_cb</function> to:</para><programlisting
format="linespecific"
>void
register_qsort_cb( cb )
  CV * cb
 CODE:
  qsortsv = (SV *) cb;</programlisting><para
>fixes the problem since the <type
>CV *</type> typemap entry
retrieves the reference from the SV. One issue is that this will only
work with code references (rather than sub names) but usually that is
not a problem. A bigger problem is that technically the reference
count on the CV should be incremented when it is stored to indicate to
Perl that another part of the system is interested in the CV. This
also means that the reference count should be decremented on the old
CV whenever a new callback is registered. For simple systems this is
usually not worth bothering with (in most cases you can be assured
that some other part of the system will be keeping the CV alive!) but
the better solution is to simply copy the SV on entry:</para><programlisting
format="linespecific"
>void
register_qsort_cb( cb )
  SV * cb
 CODE:
  if (qsortsv == (SV*)NULL) {
      /* This is first time in so create an SV */
      qsortsv = newSVsv(cb) ;
  } else {
      /* overwrite since we have already stored something */
      SvSetSV(qsortsv, cb) ;
  }</programlisting><para
>since the <function
moreinfo="none"
>SvSetSV</function> function
(<function
moreinfo="none"
>newSVsv</function> also calls it) automatically takes care
of reference counting. This method relies on knowing whether the
function has been called before so to guarantee this the declaration
of <varname
>qsortsv</varname> must be modified slightly to be more
explicit:</para><programlisting
format="linespecific"
>static SV * qsortsv = (SV*)NULL;</programlisting></sect2><sect2
id="advxs.cb.mult"
><title
>Multiple Callbacks</title><para
>So far we have only registered a single callback at any one time
and that callback has been stored in a static variable. In more
complex situations, such as event driven programs, we would like to
store many callbacks so a different scheme must be used; currently
each time a callback is registered the previous callback is lost.
There are a number of approaches to this and the choice depends mainly
on how the underlying library is implemented.</para><orderedlist
inheritnum="ignore"
continuation="restarts"
><listitem
><para
>If the calling interface provides a means for storing
	  extra information along with the C callback (for example a C
	  struct is used that can contain a pointer to user-supplied
	  data) then store a copy of the SV in there and retrieve it
	  when the callback occurs. This is the
	  approach taken by the <classname
>Tk</classname>
	  module.</para></listitem><listitem
><para
>If there is no provision for user-data but the
	  callback is associated with a specific data structure (such
	  as a filehandle) then one option is to store the perl
	  callback in a static hash associated with the data structure
	  and then retrieve the relevant SV from the hash as
	  required.</para></listitem><listitem
><para
>If the callback is passed arguments that do not
	  identify the source (such as a text string from a file) then
	  the only option is to write a number of callback functions
	  in C and associate each one of them with a specific Perl
	  callback. The disadvantage of this approach is that the
	  number of callbacks is then limited to a fixed
	  number. <remark
>This really does need an example but
	  perlcall already covers this quite well</remark></para></listitem></orderedlist><para
>The <classname
>Tk</classname> module is an interesting example
because it allows you to provide many more ways of specifying a
callback than simply providing a code reference or subroutine
name. Some examples are:</para><variablelist
><varlistentry
><term
>sub { }</term><term
>\&amp;somesub</term><listitem
><para
>A standard subroutine reference. This is used in
<xref
linkend="advxs.tkeg"
></xref></para></listitem></varlistentry><varlistentry
><term
>[ \&amp;somesub, $arg1, $arg2 ]</term><listitem
><para
>Invoke a subroutine with arguments. The arguments
	    are grouped in an anonymous array.</para></listitem></varlistentry><varlistentry
><term
>[ "method", $object ]</term><listitem
><para
>Invoke a method on an object. The arguments are
	    grouped in an anonymous array.</para></listitem></varlistentry></variablelist><para
>The module achieves this flexibility by, in effect, storing the
callback information in an object (in class
<classname
>Tk::Callback</classname>) and then invoking the
<methodname
>Call</methodname> method to run the callback
itself.<footnote
><para
>The <methodname
>Call</methodname> method in
<classname
>Tk::Callback</classname> is the perl interface to this but
the methods are coded in C for efficiency. See the file
<filename
moreinfo="none"
>Event/pTkCallback.c</filename> in the
<classname
>Tk</classname> source distribution for
details.</para></footnote> If necessary, this approach can be used to
simplify the C part of the callback code since the callback object can
be created in perl (to contain whatever you want it to), and then
passed to C and the C callback code can simply invoke the perl
<methodname
>Call</methodname> method on the object.</para></sect2></sect1><sect1
id="advxs.other"
><title
>Other Languages</title><para
>So far we have focussed on how to pass information between
    perl and C. This is because Perl itself is written in C and there
    are large numbers of libraries written in C. Since Perl is written
    in C it can therefore communicate with other languages that can be
    accessed from C. This section describes how to link Perl to two
    other languages. The first is C++ and the second is Fortran. If
    you have no interest in these languages feel free to skip this
    section and rejoin us at <xref
linkend="advxs.design"
></xref>.</para><sect2
id="advxs.cxx"
><title
>C++</title><para
>C++ is an evolution of C (the name indicates that this language
is a developed C language) with the addition of a true object-oriented
framework. In general C++ compilers can compile C code as well as C++
code and when the OO framework is stripped away the core language is
clearly based upon C.</para><para
>In order to provide interfaces to C++ libraries you can use XS
as before but this time in a C++ style. Since C compilers do not
understand C++ and will not include the correct C++ infrastructure
libraries we can no longer use the C compiler that was used to
build perl. The first step in building a C++ interface is therefore to
fix up the <filename
moreinfo="none"
>Makefile.PL</filename> file so that it uses your
C++ compiler. This can be done simply by using the
<literal
moreinfo="none"
>CC</literal> key to
<function
moreinfo="none"
>WriteMakefile</function>:</para><programlisting
format="linespecific"
>use ExtUtils::MakeMaker;

WriteMakefile(
       NAME =&gt; 'CXXTest',
       VERSION_FROM =&gt; 'CXXTest',
       LD   =&gt; 'g++',
       CC   =&gt; 'g++',
);</programlisting><para
>The above program can be used to configure a module called
<classname
>CXXTest</classname> (we use <literal
moreinfo="none"
>CXX</literal> because
we can't include ++ in a module name. A common alternative is to use
<literal
moreinfo="none"
>CPP</literal>) and we replace the linker and the compiler
command with <command
moreinfo="none"
>g++</command>. For compatibility with other
operating systems you can either guess the compiler name at this stage
(e.g. <command
moreinfo="none"
>CC</command> on Solaris; the approach we take later on
with Fortran) or simply ask for it from the command line.</para><remark
>This section will probably cover a made-up simple class. I've
recently been providing a perl interface to a C++ library covering a
lot of the issues but that might be too specific. The biggest problem
with C++ is that there can be multiple methods of the same name with
differing calling signature so the XS code can be complicated trying
to guess which c++ method to use. Also there is simply no
documentation on how to use perl and C++ - have you read the section
in perlxs?? It makes so many assumptions of knowledge.</remark><remark
>The real question is how much to talk about C++ itself? We
spend two chapters describing C and here we are going on to
object-oriented C in a couple of lines. Need to add the extern {} block
around the C include files, need to mention that xsubpp automatically
provides access to a THIS if it can guess one and guesses object
constructors from the XS name. I think it is worth addign some of this
but we have to be careful not to get bogged down in C++ specifics when
we should be making the reader aware of C++ generalities.</remark></sect2><sect2
id="advxs.fortran"
><title
>Fortran</title><para
>Although Fortran has been around since the 60's with its
popularity fading there are enormous numbers of scientific libraries
available in this language and you might want to use them from Perl.
Most Fortran implementations allow for the object code and libraries
to be included in C programs but the following issues must be dealt
with when doing so:</para><variablelist
><varlistentry
><term
>Pass by reference</term><listitem
><para
>All arguments are passed to Fortran subroutines as
	    pointers and it is not possible to pass by
	    value<footnote
><para
>Modern Fortran implementations
	    provide the <function
moreinfo="none"
>%VAL</function> function to allow
	    pointers to be passed by value from
	    integers.</para></footnote></para></listitem></varlistentry><varlistentry
><term
>Types</term><listitem
><para
>The variable types in Fortran are similar (there are
	    integers, floating point numbers and strings) but you must
	    be aware of the differences in representation. For
	    example, it is possible that the number of bytes used to
	    represent an <type
>INTEGER</type> in Fortran is different
	    to the default <type
>int</type> in C. Usually this is not
	    an issue.</para></listitem></varlistentry><varlistentry
><term
>Strings</term><listitem
><para
>Fortran requires that the lengths of all strings are
	    specified. Rather than using a null as a string terminator
	    the compiler automatically passes a length argument to
	    subroutines in addition to the pointer to the string
	    itself. When passing strings between C and fortran
	    additional arguments are required since the C compiler
	    will not add them automatically. The position of these
	    arguments depends on the compiler, the most popular
	    approach in Unix systems is to simply add all the lengths
	    in order to the end of the calling list (the approach
	    taken with <command
moreinfo="none"
>g77</command>, Sun Fortran and Digital
	    Unix Fortran) but it is also possible that the lengths
	    might be added into the argument list immediately
	    following the string in question (e.g. with Microsoft
	    Visual C++ and Fortran). When sending a C string to a
	    Fortran subroutine the string should be padded with blanks
	    (if it is bigger than the current contents) and when
	    returning a string from fortran the null should be
	    added.</para></listitem></varlistentry><varlistentry
><term
>Packing order</term><listitem
><para
>Perhaps the largest difference between C and Fortran
	    is the order with which multi-dimensional arrays are
	    stored in memory. Fortran arranges arrays in column-major
	    order (the column index is incremented before the row
	    index in memory) whereas C arranges arrays in row-major
	    order (the row index is incremented before the column
	    index). <xref
linkend="advxs.fig.cnf"
></xref> shows this
	    difference when using a 3 by 2 array containing the
	    numbers 1 through 6. The top diagram shows the order of
	    the elements in memory, the middle diagram shows how C
	    would arrange these elements and the lower shows how
	    Fortran would arrange them. This means that element [1][1]
	    in C will not be the same as element (2,2) in Fortran
	    (additionally, C starts counting at zero whereas Fortran
	    starts counting from 1). If you wish to pass a
	    multi-dimensional array between C and Fortran it will have
	    to be translated into the correct order.</para><example
id="advxs.fig.cnf"
><title
>Array packing in C and Fortran</title><mediaobject
><imageobject
><imagedata
fileref="cnf.eps"
format="eps"
></imagedata></imageobject><imageobject
><imagedata
fileref="cnf.gif"
format="gif"
></imagedata></imageobject><caption
><para
>Comparison of row-major and column-major
		  organisation of arrays</para></caption></mediaobject></example></listitem></varlistentry><varlistentry
><term
>String arrays</term><listitem
><para
>Since strings in Fortran are of a specified length,
	    arrays of strings in Fortran are simply contiguous blocks
	    of memory rather than arrays of pointers. For strings of
	    length 20, this is simply equivalent to the perl code
	    <userinput
moreinfo="none"
>$packed = pack("a20",@array);</userinput>. This
	    makes it very easy to pass string arrays from Perl to
	    Fortran.</para></listitem></varlistentry><varlistentry
><term
>Linker names </term><listitem
><para
>Some compilers (especially on Unix) append an
	    underscore (<literal
moreinfo="none"
>_</literal>) to the end of the
	    subroutine name when the object code is generated. For
	    example, a Fortran subroutine called
	    <function
moreinfo="none"
>MYSUB</function> would be stored in the object
	    file as <function
moreinfo="none"
>mysub_</function>. You need to know
	    whether this happens on your platform. If you don't know,
	    the easiest approach is to compile a Fortran program and
	    examine the symbols<footnote
><para
>Use the <command
moreinfo="none"
>nm</command>
	    command on unix systems.</para></footnote></para></listitem></varlistentry><varlistentry
><term
>Linking</term><listitem
><para
>When it comes to linking a Fortran library with a C
	    main it will also be necessary to link with the Fortran
	    runtime library. This library is included automatically
	    when a fortran compiler is used for the link but must be
	    specified explicitly when linking from a C
	    compiler. </para></listitem></varlistentry></variablelist><para
>Now that we have described the issues involved in calling
      Fortran subroutine libraries from C we will now provide a quick
      example, no arrays, of how to do this from XS by providing some
      glue to talk to the PGPLOT Fortran library<footnote
><para
>The
      PGPLOT library is available from <ulink
url="http://www.astro.caltech.edu/~tjp/pgplot/"
>Caltech</ulink>
      and can be used for generating scientific plots. The
      <classname
>PGPLOT</classname> Perl module by Karl Glazebrook,
      using the C binding to this library, is available from <ulink
url="http://www.cpan.org"
>CPAN</ulink></para></footnote>. We
      will use the following simple subroutines from this library:</para><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>PGEND</function></funcdef><paramdef
></paramdef></funcprototype></funcsynopsis><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>PGSCR</function></funcdef><paramdef
>INTEGER <parameter
moreinfo="none"
>CI</parameter></paramdef><paramdef
>REAL <parameter
moreinfo="none"
>CR</parameter></paramdef><paramdef
>REAL <parameter
moreinfo="none"
>CG</parameter></paramdef><paramdef
>REAL <parameter
moreinfo="none"
>CB</parameter></paramdef></funcprototype></funcsynopsis><funcsynopsis
><funcprototype
><funcdef
>INTEGER <function
moreinfo="none"
>PGBEG</function></funcdef><paramdef
>INTEGER <parameter
moreinfo="none"
>UNIT</parameter></paramdef><paramdef
>CHARACTER*(*) <parameter
moreinfo="none"
>FILE</parameter></paramdef><paramdef
>INTEGER <parameter
moreinfo="none"
>NXSUB</parameter></paramdef><paramdef
>INTEGER <parameter
moreinfo="none"
>NYSUB</parameter></paramdef></funcprototype></funcsynopsis><funcsynopsis
><funcprototype
><funcdef
><function
moreinfo="none"
>PGQINF</function></funcdef><paramdef
>CHARACTER*(*) <parameter
moreinfo="none"
>ITEM</parameter></paramdef><paramdef
>CHARACTER*(*) <parameter
moreinfo="none"
>VALUE</parameter></paramdef><paramdef
>INTEGER <parameter
moreinfo="none"
>LENGTH</parameter></paramdef></funcprototype></funcsynopsis><para
>which on linux with <command
moreinfo="none"
>g77</command> have the following
signature in C:</para><funcsynopsis
><funcprototype
><funcdef
>void <function
moreinfo="none"
>pgend_</function></funcdef><paramdef
></paramdef></funcprototype></funcsynopsis><funcsynopsis
><funcprototype
><funcdef
>void <function
moreinfo="none"
>pgscr_</function></funcdef><paramdef
>int *<parameter
moreinfo="none"
>ci</parameter></paramdef><paramdef
>float *<parameter
moreinfo="none"
>cr</parameter></paramdef><paramdef
>float *<parameter
moreinfo="none"
>cg</parameter></paramdef><paramdef
>float *<parameter
moreinfo="none"
>cb</parameter></paramdef></funcprototype></funcsynopsis><funcsynopsis
><funcprototype
><funcdef
>int <function
moreinfo="none"
>pgbeg_</function></funcdef><paramdef
>int *<parameter
moreinfo="none"
>unit</parameter></paramdef><paramdef
>char *<parameter
moreinfo="none"
>file</parameter></paramdef><paramdef
>int *<parameter
moreinfo="none"
>nxsub</parameter></paramdef><paramdef
>int *<parameter
moreinfo="none"
>nysub</parameter></paramdef><paramdef
>int <parameter
moreinfo="none"
>len_file</parameter></paramdef></funcprototype></funcsynopsis><funcsynopsis
><funcprototype
><funcdef
>void <function
moreinfo="none"
>pgqinf_</function></funcdef><paramdef
>char *<parameter
moreinfo="none"
>item</parameter></paramdef><paramdef
>char *<parameter
moreinfo="none"
>value</parameter></paramdef><paramdef
>int *<parameter
moreinfo="none"
>length</parameter></paramdef><paramdef
>int <parameter
moreinfo="none"
>len_item</parameter></paramdef><paramdef
>int <parameter
moreinfo="none"
>len_value</parameter></paramdef></funcprototype></funcsynopsis><para
>Once this translation is known the XS code becomes quite
straightforward:</para><programlistingco
><areaspec
><area
coords="5"
id="f77.buffer"
></area><areaset
coords="7"
id="f77.defines"
><area
coords="7"
id="f77.defines.pgend"
></area><area
coords="8"
id="f77.defines.pgscr"
></area></areaset><area
coords="13"
id="f77.pgend"
></area><area
coords="16"
id="f77.pgscr"
></area><area
coords="23"
id="f77.pgbeg"
></area><area
coords="29"
id="f77.pgbeg.call"
></area><area
coords="34"
id="f77.pgqinf"
></area><area
coords="38"
id="f77.pgqinf.pre"
></area><area
coords="42"
id="f77.pgqinf.call"
></area><area
coords="43"
id="f77.pgqinf.exprt"
></area></areaspec><programlisting
format="linespecific"
>#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#define F77BUFFER  256

#define pgend pgend_
#define pgscr pgscr_

MODULE = PGPLOT   PACKAGE = PGPLOT

void
pgend()

void
pgscr(ci, cr, cg, cb)
  int &amp;ci
  int &amp;cr
  int &amp;cg
  int &amp;cb

int
pgbeg(unit, file, nxsub, nysub)
  int &amp;unit
  char * file
  int &amp;nxsub
  int &amp;nysub
 CODE:
  RETVAL = pgbeg_(&amp;unit, file, &amp;nxsub, &amp;nysub, strlen(file));
 OUTPUT:
  RETVAL

void
pgqinf(item, value, length)
  char * item
  char * value = NO_INIT
  int length = NO_INIT
 PREINIT:
  char buff[F77BUFFER];
 CODE:
  value = buff;
  pgqinf_(item, value, &amp;length, strlen(item), F77BUFFER);
  value[length+1] = '\0';
 OUTPUT:
  value
  length
</programlisting><calloutlist
><callout
arearefs="f77.buffer"
><para
>We use this definition to specify the maximum size
	    of static buffers required to receive strings from Fortran
	    subroutines.</para></callout><callout
arearefs="f77.defines"
><para
>We can set up pre-processor symbols that will allow
	    us to use the expected names in our XS code but will tell
	    the C compiler to look for the Fortran name. In principal
	    all the functions could be defined in this way. For this
	    example, it is only convenient to do this for simple
	    functions (those not using character strings, arrays or
	    multiple return values) that can be dealt with
	    automatically by the XS compiler without CODE
	    blocks.</para></callout><callout
arearefs="f77.pgend"
><para
><function
moreinfo="none"
>pgend</function> is simple because the XS
	    compiler assumes that it can call a C function
	    <function
moreinfo="none"
>pgend</function> even though the C
	    pre-preprocessor will translate that text to
	    <function
moreinfo="none"
>pgend_</function>. Without the definition at the
	    top of the file the XS name will be different to the
	    function name so a CODE block would be required.</para></callout><callout
arearefs="f77.pgscr"
><para
><function
moreinfo="none"
>pgscr</function> function takes 4 integer
	    arguments but must pass them to the Fortran subroutine
	    using pointers. The XS compiler does this automatically
	    since the variables are declared with an ampersand as
	    prefix.</para></callout><callout
arearefs="f77.pgbeg"
><para
>This function is not as simple. It takes 4 input
	    arguments but one of those is a string.</para></callout><callout
arearefs="f77.pgbeg.call"
><para
>The integer arguments are passed in as pointers with
	    the length of the string added as an extra argument to the
	    C routine. We do not have to convert this string to
	    Fortran format because we know the length in C and can
	    simply inform the Fortran compiler of that length
	    directly.</para></callout><callout
arearefs="f77.pgqinf"
><para
>This function has one input string and two output
	    values. The NO_INIT tag is used to indicate that the input
	    values for those variables are irrelevant.</para></callout><callout
arearefs="f77.pgqinf.pre"
><para
>Allocate memory for a string to receive the output
	    string.</para></callout><callout
arearefs="f77.pgqinf.call"
><para
>Since there are two string arguments, two lengths
	    are appended to the argument list. The first is the length
	    of the input string and the second is the length of the
	    string output string.  In principal the output string
	    should be padded with blanks before sending it to Fortran
	    (that step has been omitted for clarity).</para></callout><callout
arearefs="f77.pgqinf.exprt"
><para
>The string that comes back from Fortran will not be
	    nul-terminated. Before sending it back to Perl the string
	    must be made compatible with C. In this example we know
	    the length of the string returned to us so we can simply
	    append the terminator. In general we would need to step
	    back through the string one character at a time until we
	    found a non-blank character.</para></callout></calloutlist></programlistingco><para
>Once the XS code is written, the final issue is linking. All
Fortran libraries require that the Fortran runtime library is included
in the build. In order to simplify the task of keeping track of the
runtime libraries required on different systems the
<classname
>ExtUtils::F77</classname> module can be used. This module
attempts to determine the libraries that are required to link Fortran
programs on your system with the relevant Fortran compiler. A
<filename
moreinfo="none"
>Makefile.PL</filename> for the above XS code that utilises
this module would look like this:</para><programlistingco
><areaspec
><area
coords="2"
id="ext.f77"
></area><area
coords="11"
id="pgplot.libs"
></area><area
coords="12"
id="f77.libs"
></area></areaspec><programlisting
format="linespecific"
>use ExtUtils::MakeMaker;
use ExtUtils::F77;

# See lib/ExtUtils/MakeMaker.pm for details of how to influence
# the contents of the Makefile that is written.
WriteMakefile(
    'NAME'              =&gt; 'PGPLOT',
    'VERSION_FROM'      =&gt; 'PGPLOT.pm', # finds $VERSION
    'PREREQ_PM'         =&gt; {}, # e.g., Module::Name =&gt; 1.1
    'LIBS'              =&gt; [ "-L/usr/local/lib -lpgplot " .
                             "-L/usr/X11R6/lib -lX11 " .
                             ExtUtils::F77-&gt;runtime ], 
);</programlisting><calloutlist
><callout
arearefs="ext.f77"
><para
>Load the <classname
>ExtUtils::F77</classname> library.</para></callout><callout
arearefs="pgplot.libs"
><para
>The PGPLOT library requires X libraries for some devices</para></callout><callout
arearefs="f77.libs"
><para
>The runtime libraries can be returned using the
	    <methodname
>runtime</methodname> class method.</para></callout></calloutlist></programlistingco><para
>Now when we run this program we get the following output (with <command
moreinfo="none"
>g77</command>):</para><programlisting
format="linespecific"
>Loaded ExtUtils::F77 version 1.14
Found compiler g77
ExtUtils::F77: Using system=Linux compiler=G77
Runtime: -L/usr/lib/gcc-lib/i386-redhat-linux/2.96 -L/usr/lib -lg2c 
          -lm -L/usr/lib/gcc-lib/i386-redhat-linux/2.96 -lgcc
ExtUtils::F77: Validating -L/usr/lib/gcc-lib/i386-redhat-linux/2.96 
          -L/usr/lib -lg2c -lm -L/usr/lib/gcc-lib/i386-redhat-linux/2.96 
          -lgcc   [ok]
ExtUtils::F77: Compiler: g77
ExtUtils::F77: Cflags: -O
Writing Makefile for PGPLOT</programlisting><para
>Where <classname
>ExtUtils::F77</classname> has determined that
we will be using the <command
moreinfo="none"
>g77</command> compiler and that we need
the <filename
moreinfo="none"
>g2c</filename> runtime library.</para><sect3
><title
>Interface Libraries and Portability</title><para
>The issue of portability depends on the particular circumstances
of your module. If you just want to use it on, for example, Solaris
and Linux where the Fortran implementations are compatible you can
simply write XS as described above. If on the other hand the intention
is for your module to be adopted widely you will need to consider
other operating systems and Fortran compilers. The
<classname
>ExtUtils::F77</classname> helps in this regard since it can
work out the libraries for many different compiler and OS
combinations. Additionally it can be used to determine whether a
trailing underscore is required on function names (this ability can be
used to set a C pre-processor macro).</para><para
>There are a number of packages available to simplify the writing
of portable interface code. One of the most extensive of these is the
CNF package<footnote
><para
>The CNF package currently uses the Starlink
Software Licence. This licence allows for redistribution of source
code but currently restricts the library to non-commercial use. Moves
are currently underway to open up the licence.</para></footnote>
written by <ulink
url="http://www.starlink.rl.ac.uk"
>Starlink</ulink><footnote
><para
>Starlink
is a research organization in the United Kingdom. It provides data
processing and analyis software for research astronomers in the
UK.</para></footnote>. CNF provides an large set of C pre-processor
macros for dealing with variable types and calling conventions. There
is also a support library that can be used to convert types (for
example, strings and arrays) between the languages.  Finally, CNF
comes with very detailed documentation on the issues associated with
mixed programming as well as the use of CNF itself.  In order to
demonstrate this alternative approach, here is the XS code for
<function
moreinfo="none"
>pgqinf</function> re-written to use CNF:</para><programlisting
format="linespecific"
>void
fpgqinf(item, value, length)
  char * item
  char * value = NO_INIT
  int length = NO_INIT
 PREINIT:
  DECLARE_CHARACTER(fitem, F77BUFFER);
  DECLARE_CHARACTER(fvalue, F77BUFFER);
  DECLARE_INTEGER(flength);
  char buff[F77BUFFER];
 CODE:
  cnfExprt(item, fitem, fitem_length);
  F77_CALL(pgqinf) ( CHARACTER_ARG(fitem),
		     CHARACTER_ARG(fvalue),
		     INTEGER_ARG(&amp;flength) 
		     TRAIL_ARG(fitem)
		     TRAIL_ARG(fvalue) );
  length = (int)flength;
  value  = (char *)buff;
  cnfImprt( fvalue, length, value );
 OUTPUT:
  value
  length</programlisting><para
>Immediately obvious is the extra verbosity inherent in this
approach and that in order to guarantee the correct types are being
used for the Fortran layer a certain amount of copying is involved to
go from the C to Fortran. This example also uses the translation
functions <function
moreinfo="none"
>cnfExprt</function> and
<function
moreinfo="none"
>cnfImprt</function> to export and import strings. Just to
prove that CNF is doing the <emphasis
>right</emphasis> thing, here is
the same code block with the macros expanded (using
<command
moreinfo="none"
>g77</command>):</para><programlisting
format="linespecific"
>char fitem[256]; const int fitem_length = 256;
char fvalue[256]; const int fvalue_length = 256;
int flength;
char buff[256];
cnfExprt(item, fitem, fitem_length);
pgqinf_ ( fitem,
          fvalue,
          &amp;flength
          ,fitem_length
          ,fvalue_length );
length = (int)flength;
value = (char *)buff;
cnfImprt( fvalue, length, value );</programlisting><para
>It is clear that the trade-off for portability in this case is counter
balanced by a decrease in speed of the resulting code. For maximum
performance it is probably best to make some assumptions.</para></sect3><sect3
><title
>Interface considerations</title><para
>The interface provided in this Fortran example is not
	very <emphasis
>perl-y</emphasis>. As described in <xref
linkend="xsi.design"
></xref> the needs of a particular library should
	be addressed on a case-by-case basis. The PGPLOT library has a
	well defined API that has been in use for many years and there
	are some benefits to following that interface. When migrating
	from C or Fortran applications it might be easier, both for
	the author of the module (less documentation to write, no
	complications with PPCODE blocks) and for the user (no need to
	learn a new interface) if the Perl port of the library looks
	as close as possible to that implemented in other
	languages. This is the approach taken with the
	<classname
>PGPLOT</classname> module on CPAN. For the routines
	described above, the most likely candidate for change is
	<function
moreinfo="none"
>pgqinf</function>. This routine has one input
	argument and two return arguments. One of these arguments is
	simply the length of the string and is not required by Perl. A
	much better approach from Perl's viewpoint is probably:</para><funcsynopsis
><funcprototype
><funcdef
>$value = <function
moreinfo="none"
>pgqinf</function></funcdef><paramdef
>$item</paramdef></funcprototype></funcsynopsis><para
>The Perl Data Language goes a step further. The PGPLOT
	interface in PDL is completely divorced from the underlying
	library API and uses an object-oriented layer to implement
	plotting. This has made it easier for users of PDL since
	different plotting engines can be used with only minimal
	changes to the perl code.</para></sect3></sect2><sect2
><title
>Java?</title><remark
>There is of course JPL (Java Perl Lingo). From the XS point of
view I'm only interested in the JNI module (along with the base JPL
module) which allows for java code to be called from Perl. The bulk of
JNI exists for embedding a perl interpreter inside java rather than
invoking java methods from perl. JNI does all the hard work so that
the author of the Java code does not actually use any XS directly so
it doesn't really sit well in this chapter even if we wanted to talk
about it. I have tried to build JNI (on linux with JDK1.1.7 and 1.3.0)
and I have not had much success so far - builds are okay but it
refuses to launch a new JVM. I have not tried it on Solaris with an
old JDK). There does not seem to be that much going on with JPL in
general so it might be safer simply to ignore it. Alternatively,
Inline::Java seems to come with a JNI interface and does seem to work
with modern JDKs (that built and tested with no problems on linux).</remark></sect2></sect1><sect1
id="advxs.design"
><title
>Interface Design - Part 2</title><para
>In <xref
linkend="xsi.design"
></xref> we covered the basic interface issues
    that should be thought about before writing even the simplest XS
module. Now that we have a more thorough grounding in XS we will
summarise the design issues that have been brought up during this chapter.</para><itemizedlist
><listitem
><para
>Look at the functions in the external library. Is the C
	library using objects in disguise? If it is repeatedly using
	an internal opaque structure then it is probably best to use
	that structure as an object in Perl.</para></listitem><listitem
><para
>Multiple return arguments should be returned as proper
	return arguments rather than as input arguments that are
	modified. Use PPCODE to adjust the return stack to
	suit.</para></listitem><listitem
><para
>If a status variable can only have two states consider
	translating the C value to a Perl true or false rather than
	matching the interface provided by the external calling
	convention. Alternatively, if the function only returns useful
	information when the status is good, do not return the status
	value at all. Return the values if everything is okay, and an
	empty list or <function
moreinfo="none"
>undef</function> otherwise. The
	<function
moreinfo="none"
>XSRETURN_*</function> functions are provided for
	this purpose.</para><para
>Using our example from <xref
linkend="xsi.design"
></xref> we can then change a signature of:</para><funcsynopsis
><funcprototype
><funcdef
>int <function
moreinfo="none"
>compute</function></funcdef><paramdef
>int <parameter
moreinfo="none"
>factor</parameter></paramdef><paramdef
>double *<parameter
moreinfo="none"
>result</parameter></paramdef></funcprototype></funcsynopsis><para
>to</para><funcsynopsis
><funcprototype
><funcdef
>$result = <function
moreinfo="none"
>compute</function></funcdef><paramdef
>	    <parameter
moreinfo="none"
>factor</parameter></paramdef></funcprototype></funcsynopsis><para
>using the following XS code:</para><programlisting
format="linespecific"
>double
compute( factor )
  int factor
 PREINIT:
  int status;
 CODE:
  status = compute( factor, &amp;RETVAL);
 OUTPUT:
  RETVAL
 CLEANUP:
   if (status == -1)
     XSRETURN_UNDEF;</programlisting></listitem><listitem
><para
>C++ context-based method overloading provides a
	particular headache for interface design. If it is possible to
	determine the correct method from the argument stack (for
	example by counting the number of arguments) then it is
	possible to have a single perl method that calls the required
	C++ method. If the distinction is simply by type then it may
	be necessary to either have distinct perl methods (one for
	each type) or a single perl method that is uses a relevant
	perl type (since perl does not care about the difference
	between an integer, double or string) . This issue is
	disccussed in <xref
linkend="advxs.cxx"
></xref></para></listitem></itemizedlist><para
>Finally, don't be scared of using perl. Many of these examples
can be simplified by using a perl intermediary layer (for example,
using <function
moreinfo="none"
>pack</function>/<function
moreinfo="none"
>unpack</function> to handle
arrays). If you feel stronger in perl than in C this is a valid
approach. If you feel that you need the extra speed you can recode it
in C without needing to change the external interface to the
module. The important thing is to have a clean public
interface. </para></sect1><sect1
id="advxs.inside"
><title
>What's Really Going On?</title><para
>So far in this book, we have created XS files, typed
    <command
moreinfo="none"
>make</command> and watched whilst lots of interesting
    things scroll off the screen. In this section we will take a
    closer look at what is really happening to these XS files and how
    XSUB really interface to the Perl internals.</para><para
>The XS interface exists to simplify the way user-supplied C
    code can be called from within Perl by being one layer above the
    perl internals.  In principal it is possible to write the C code
    directly without going through the XS layer at all but this
    approach is not recommended since (a) it is more complex than is
    required for simple interfacing, (b) it is repetitive and error
    prone when providing an interface to many external functions and
    (c) may suffer compatibility problems if the internals are
    changed.</para><sect2
><title
>What does xsubpp generate?</title><para
>By now we know that the first step in creating an XS
      module is for the <command
moreinfo="none"
>xsubpp</command> command to process
      the XS file in conjunction with a typemap file and from these
      generate a C file that can be compiled. Here we will revisit
      some of the XS examples from <xref
linkend="xsi.further"
></xref> but this
      time we will take a look at the <filename
moreinfo="none"
>.c</filename> output
      files. To refresh our memories here is the XS file that we will
      be experimenting with:</para><programlisting
format="linespecific"
>#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;


size_t strconcat (char* str1, char* str2, char* outstr) {
   strcpy( outstr, (const char*)str1 );
   strcat( outstr, (const char*)str2 );
   return strlen( outstr );
}

MODULE = Example		PACKAGE = Example		

int
treble ( x )
  int x
 CODE:
   RETVAL = 3*x;
 OUTPUT:
  RETVAL

size_t
strconcat( str1, str2, outstr )
  char* str1
  char* str2
  char* outstr = NO_INIT
 PREINIT:
  size_t length;
 CODE:
  length = strlen( str1 ) + strlen( str2 ) + 1;
  New(0, outstr, length, char );
  RETVAL = strconcat( str1, str2, outstr );
 OUTPUT:
  outstr
  RETVAL
 CLEANUP:
  Safefree( outstr );</programlisting><para
>If we now build this module we will find a C file called
      <filename
moreinfo="none"
>Example.c</filename> in the working directory. This
      file will contain the something like the following: </para><remark
>This is crying out for extensive annotation but I don't
      feel that callouts can really do what I want to do here. Should
      be a <quote
>hedgehog</quote> diagram but I'm loathe to try and
      do one in xfig. Need to investigate drawing packages.</remark><programlistingco
><areaspec
><area
coords="10"
id="advxs.xstoc.line1"
></area></areaspec><programlisting
format="linespecific"
>/*
 * This file was generated automatically by xsubpp version 1.9507 from the 
 * contents of Example.xs. Do not edit this file, edit Example.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Example.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;


size_t strconcat (char* str1, char* str2, char* outstr) {
   strcpy( outstr, (const char*)str1 );
   strcat( outstr, (const char*)str2 );
   return strlen( outstr );
}

#line 25 "Example.c"
XS(XS_Example_treble)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Example::treble(x)");
    {
	int	x = (int)SvIV(ST(0));
	int	RETVAL;
	dXSTARG;
#line 21 "Example.xs"
   RETVAL = 3*x;
#line 37 "Example.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Example_strconcat)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Example::strconcat(str1, str2, outstr)");
    {
	char*	str1 = (char *)SvPV(ST(0),PL_na);
	char*	str2 = (char *)SvPV(ST(1),PL_na);
	char*	outstr;
#line 31 "Example.xs"
  size_t length;
#line 54 "Example.c"
	size_t	RETVAL;
	dXSTARG;
#line 33 "Example.xs"
  length = strlen( str1 ) + strlen( str2 ) + 1;
  New(0, outstr, length, char );
  RETVAL = strconcat( str1, str2, outstr );
#line 61 "Example.c"
	sv_setpv((SV*)ST(2), outstr);
	SvSETMAGIC(ST(2));
	XSprePUSH; PUSHi((IV)RETVAL);
#line 40 "Example.xs"
  Safefree( outstr );
#line 67 "Example.c"
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Example)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("Example::treble", XS_Example_treble, file);
        newXS("Example::strconcat", XS_Example_strconcat, file);
    XSRETURN_YES;
}</programlisting></programlistingco><para
>The global things to get from this file are the
following:</para><itemizedlist
><listitem
><para
>The C code that appears in the XS file before the
	  MODULE keyword is passed through unchanged.</para></listitem><listitem
><para
>Each XS function appears as a real C function but with
	  a modified name. The name is derived by concatenating the
	  fixed prefix <function
moreinfo="none"
>XS_</function>, a C-ified form of the
	  current PACKAGE (as defined by the PACKAGE keyword in the XS
	  file) and the function name itself. If a PREFIX is defined
	  then that is removed from the function name before
	  concatenation. For example, if the function name is
	  <function
moreinfo="none"
>slaMap</function>, with a prefix of
	  <quote
>sla</quote> and a package name of
	  <classname
>Astro::SLA</classname>, the internal function
	  name will be <function
moreinfo="none"
>XS_Astro__SLA_Map</function>. Here
	  the colons have been replaced with underscores.</para></listitem><listitem
><para
>If there are a fixed number of arguments, code has
	  been inserted to check the correct number are on the stack
	  and to issue an error message if necessary.</para></listitem><listitem
><para
>Whenever there is a shift from original code to
	  auto-generated code, the line numbering is changed to
	  indicate the source of the code. This is achieved using the
	  <literal
moreinfo="none"
>#line</literal> special
	  directive<footnote
><para
>Identical to the
	  <literal
moreinfo="none"
>#line</literal> special comment supported by perl
	  and described in the <filename
moreinfo="none"
>perlsyn</filename>
	  manpage.</para></footnote>. This means that if an error
	  occurs in an XS line any compiler error messages will point
	  to the correct line and file name rather than to the line in
	  the translated C code. This simplifies debugging
	  enormously.</para></listitem><listitem
><para
>The final section is completely auto-generated. The
	  boot function is responsible for registering the XS
	  functions with perl and is called automatically by
	  DynaLoader when the module is loaded.</para></listitem></itemizedlist><para
>Now that we have a global overview of the file contents,
      we can cover the relationship between the XS definition
      of a function and the final C code. The XS sections are
      propogated to the C translation without changing the inherent
      order. Arguments are declared first, then comes additional
      variable definitions (PREINIT), CODE blocks, the handling of
      output variables and finally, CLEANUP code is included to tidy
      things up. Of course there are many other types of XS
      declarations and they are included by <command
moreinfo="none"
>xsubpp</command>
      in the same way. Most of these steps simply entail the addition
      of some standard stack handling code or the insertion verbatim
      of the code supplied by the module author. The main
      complications involve variable input and output. These involve
      the stack handling and variable declarations. Let's take a
      closer look at the <function
moreinfo="none"
>strconcat</function> function shown
      above. The XS declaration and corresponding C code were:</para><programlisting
format="linespecific"
>char* str1
char* str2
char* outstr = NO_INIT</programlisting><para
>and</para><programlisting
format="linespecific"
>char*	str1 = (char *)SvPV(ST(0),PL_na);
char*	str2 = (char *)SvPV(ST(1),PL_na);
char*	outstr;</programlisting><para
><command
moreinfo="none"
>xsubpp</command> does the following to generate
      this code:</para><orderedlist
inheritnum="ignore"
continuation="restarts"
><listitem
><para
>Look up <type
>char*</type> in the typemap file(s).</para></listitem><listitem
><para
>Look up T_PV in the INPUT section.</para></listitem><listitem
><para
>See if the INPUT entry matches /\t\$var =/.</para><itemizedlist
><listitem
><para
> If it matches then the typemap entry is assumed
	      to be a single statement and the variable can be
	      declared and assigned at the same time. This is the case
	      with T_PV which has a typemap entry of
	      <userinput
moreinfo="none"
>&lt;tab&gt;$var =
	      ($type)SvPV($arg,PL_na)</userinput>.</para></listitem><listitem
><para
>If it does not match this (for example, because
	      the variable is to be type-checked before copying as
	      is the case with T_AVREF) the variable is simply
	      declared and the typemap code is deferred until after
	      the other variable declarations (after the remaining
	      arguments are declared and after PREINIT blocks). This
	      is necessary since C does not allow varaiables to be
	      declared midway through a code block.</para></listitem></itemizedlist></listitem><listitem
><para
>Replace all the Perl variables in the typemap entry
	  with the corresponding values and print them to the C
	  file. Recall that <function
moreinfo="none"
>ST(n)</function> refers to an SV
	  on the argument stack (<xref
linkend="advxs.argstack"
></xref>). In
	  this example positions 0 and 1 are relevant and nothing is
	  copied from position 2.</para></listitem></orderedlist><para
>Return variables are dealt with in a similar way unless a PPCODE
block is used. In our <function
moreinfo="none"
>strconcat</function> function the
output code for <varname
>outstr</varname> is simply the typemap entry
with variable substitutions. The <varname
>RETVAL</varname> return
variable is dealt with in the same manner except
<command
moreinfo="none"
>xsubpp</command> recognizes the standard variable types and
translates them into the corresponding PUSH commands rather than using
the OUTPUT typemap entry.</para></sect2></sect1><sect1
id="advxs.summary"
><title
>Summary</title><para
>In this chapter we have extended our knowledge of XS to cover
files, hashes, arrays and callbacks and have seen how the XS code and
typemap files translate into code suitable for use by the Perl
internals. We have also seen how write XS code suitable for
interfacing perl to libraries written in Fortran and C++.</para><para
>In subsequent chapters we will step further away from the internals
and see what systems are available to simplify the linking of perl to
external libraries.</para></sect1><sect1
id="advxs.reading"
><title
>Further Reading</title><remark
>It would be really nice to provide some kind of appendix
explaining the different <quote
>standard</quote> typemaps. Some of them
are very strange and all are essentially undocumented. For now, simply
reference my XS::Typemap documentation (part of perl 5.7.1) where I
have documented most of them.</remark><variablelist
><varlistentry
><term
>perlxstut manpage</term><listitem
><para
>This XS tutorial comes with Perl and provides
	  several XS examples.</para></listitem></varlistentry><varlistentry
><term
>perlxs manpage</term><listitem
><para
>This manpage contains detailed information on XS. </para></listitem></varlistentry><varlistentry
><term
>perlcall manpage</term><listitem
><para
>This manpage from the standard distribution contains a lot of information on setting up callbacks. </para></listitem></varlistentry><varlistentry
><term
>XS::Typemap</term><listitem
><para
>Starting with Perl 5.7.1, the source distribution
	  includes the <classname
>XS::Typemap</classname> module that
	  is used to test that the typemap entries behave as
	  expected. This module is not installed but the source
	  contains examples for most of the typemap entries.</para></listitem></varlistentry><varlistentry
><term
>Astro::SLA</term><term
>PGPLOT</term><listitem
><para
>The <classname
>Astro::SLA</classname> and
	  <classname
>PGPLOT</classname> modules on CPAN both contain
	  helper code that can be used to pack and unpack arrays with
	  the minimum of effort. The code in the
	  <filename
moreinfo="none"
>arrays.c</filename> file from these distributions
	  is useful for providing a pre-packaged solution for dealing
	  with arrays without going to the expense of using
	  PDL.</para></listitem></varlistentry></variablelist></sect1></chapter><chapter
id="altxs"
><title
> Alternatives to XS</title><para
>So far we have done all of our Perl interfaces to C using XS and have
  demonstrated just how powerful and complex XS can be. In this chapter we are
  going to take a step above XS and show how it is possible to create an
  interface to C without using XS or reading page after page of
  documentation. </para><para
>We will begin by looking at one of the earliest alternatives to XS and
  then proceed to the current front-runner for XS simplification. On the way
  we will address the special demands called for by the Perl Data Language and
  finish up by covering some of the less useful approaches to ignoring XS. We
  will make use of the examples from previous chapters to demonstrate the
  differences and similarities of these approaches.</para><para
>Nearly <emphasis
>all</emphasis> the schemes described in this chapter
  are implemented as an abstraction layer above XS itself either by generating
  <filename
moreinfo="none"
>.xs</filename> files to be passed to <command
moreinfo="none"
>xsubpp</command> or
  generating the code equivalent to the output of <command
moreinfo="none"
>xsubpp</command>
  that interfaces directly to perl's internal XS system. This approach has the
  key advantage that a change to the XS system will only require a fix to the
  software that processes these definition files, all code that uses these
  systems will not require modification.</para><sect1
><title
>h2xs</title><para
>By far the oldest attempt at providing a simplified access to XS is
    the <command
moreinfo="none"
>h2xs</command> program that comes with Perl. We have already
    used this command in <xref
linkend="xsintro"
></xref> to generate a basic
    framework for perl and XS-based modules but it can be used to
    automatically generate XS wrapper code for simple libraries. As the name
    of the program suggests, it can take a C header file as input and generate
    a <filename
moreinfo="none"
>.xs</filename> file as output. We will not spend much time
    describing this program in detail but as an example let's see what happens
    when we run this command on a header file containing prototypes for the
    <function
moreinfo="none"
>print_hello</function> and <function
moreinfo="none"
>treble</function> examples
    used in <xref
linkend="xsi.xs"
></xref>. We can call this file
    <filename
moreinfo="none"
>example.h</filename>:</para><programlisting
format="linespecific"
>void print_hello ();
int treble (int x);</programlisting><para
>You can then run <command
moreinfo="none"
>h2xs</command> with the
    <option
>-x</option> option to force it to scan the header file looking for
    function prototypes (for this to work you will need to download the
    <classname
>C::Scan</classname> module from CPAN). Without this option
    <command
moreinfo="none"
>h2xs</command> will still attempt to read the include file but it
    will only be able to extract #define's rather than full XS entries. For
    our example we get the following output:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>h2xs -x -c -A example.h</userinput>
Scanning typemaps...
 Scanning /usr/lib/perl5/5.7.2/ExtUtils/typemap
Scanning example.h for functions...
Scanning example.h for typedefs...
Writing Example/Example.pm
Writing Example/Example.xs
Writing Example/Makefile.PL
Writing Example/README
Writing Example/t/1.t
Writing Example/Changes
Writing Example/MANIFEST</screen><para
>The additional options turn off the code for handling constants
    since this module won't be using any. The output file
    <filename
moreinfo="none"
>Example.xs</filename> contains the following:</para><programlisting
format="linespecific"
>#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include &lt;example.h&gt;


MODULE = Example		PACKAGE = Example		


void
print_hello()

int
treble(x)
	int	x</programlisting><para
>and looks identical to that used in <xref
linkend="xsi.xs"
></xref> except
    that the actual code for the functions is missing (you would have to put
    that after the include directives or else create a library to link
    against).</para><para
>In general <command
moreinfo="none"
>h2xs</command> is fine for handling simple
    interfaces using scalar arguments but rapidly runs out of steam. Even with
    a seemingly simple function such as <function
moreinfo="none"
>strconcat</function> from
    <xref
linkend="advxs.pointers"
></xref> <command
moreinfo="none"
>h2xs</command> gets the wrong
    answer:</para><programlisting
format="linespecific"
>STRLEN
strconcat(str1, str2, outstr)
        char *  str1
        char *  str2
        char *  outstr</programlisting><para
>It assumes that all arguments are for input and, additionally, the C
    interface requires that memory is allocated for the output string before
    use; something that <command
moreinfo="none"
>h2xs</command> can not possibly guess.</para><para
>If you intend to use <command
moreinfo="none"
>h2xs</command> for anything but the
    simplest interface be prepared to do a lot of work on the file that is
    automatically generated for you.</para></sect1><sect1
id="altxs.swig"
><title
>SWIG</title><para
>SWIG (standing for Simplified Wrapper and Interface
    Generator) was developed in 1995 by David Beazley at Los Alamos to
    simplify the writing of interface code between scripting languages
    and C/C++ libraries. First for a little known language, and then,
    in 1996, to cover Tcl, Perl and Guile. Since then it has been
    developed to cover many more languages including Java. One of the
    major advantages of SWIG over XS is that it allows you to write a
    single interface specification and use it for all the languages
    supported by SWIG. </para><para
>Let's start our investigation of SWIG by seeing how to
    provide a perl interface to the <function
moreinfo="none"
>sinh</function> math
    function (this already exists in the <classname
>POSIX</classname>
    module) and a related constant. All SWIG interfaces begin with the
    definition of the generic interface definition. For
    <function
moreinfo="none"
>sinh</function> this would look something like:</para><programlistingco
><areaspec
><area
coords="1"
id="altxs.swig.simple.mod"
></area><area
coords="3"
id="altxs.swig.simple.proto"
></area><area
coords="4"
id="altxs.swig.simple.const"
></area></areaspec><programlisting
format="linespecific"
>%module Simple

double sinh ( double ang );
#define PI 3.141592654
</programlisting><calloutlist
><callout
arearefs="altxs.swig.simple.mod"
><para
>All SWIG files begin by declaring the module name (if
	  it is not defined in here it must be specified on the
	  command line). SWIG commands always start with a per cent
	  sign.</para></callout><callout
arearefs="altxs.swig.simple.proto"
><para
>This is simply the C prototype for the function we are
	  trying to call. SWIG can be used to simply parse a C include
	  file and generate a language interface directly. In general
	  this is not the recommended approach since C include files
	  tend to include many functions and data structures that are
	  not required for the interface itself.</para></callout><callout
arearefs="altxs.swig.simple.const"
><para
>A C pre-processor define will be treated as a constant
	  variable. Constants can also be defined using the
	  <literal
moreinfo="none"
>%constant</literal> command.</para></callout></calloutlist></programlistingco><para
>If we now save the above description to a file
    <filename
moreinfo="none"
>simple.swg</filename> (<filename
moreinfo="none"
>simple.i</filename> is
    a common alternative) we can run SWIG on this file and generate
    the code required to interface the target language to the library
    function:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>swig -perl5 simple.swg</userinput></screen><para
>Here we use the <option
>perl5</option> option to generate
    code for Perl rather than another language. Once executed, this
    command writes a file <filename
moreinfo="none"
>simple_wrap.c</filename>
    containing all the code necessary to call our function from Perl
    and a small perl wrapper module called
    <filename
moreinfo="none"
>Simple.pm</filename>. With version 1.3.9 of
    SWIG<footnote
><para
>SWIG has undergone a major rewrite between
    1999 and 2001 and version 1.3.6 was the first stable version
    released since February 1998 (when version 1.1p5 was
    released). The examples all used version 1.3.9.</para></footnote>
    this C output file is approximately 10kB; impressively large for a
    2 line interface description file. The important thing to realise
    is that the output code is C that can be compiled and linked as a
    module directly as <command
moreinfo="none"
>xsubpp</command> is not required
    here. To convince yourself this is the case look in
    <filename
moreinfo="none"
>simple_wrap.c</filename> and you will find the following
    XS code (or something similar) for <function
moreinfo="none"
>sinh</function>:</para><programlisting
format="linespecific"
>XS(_wrap_sinh) {
    double arg0 ;
    int argvi = 0;
    double result ;
    dXSARGS;
    
    if ((items &lt; 1) || (items &gt; 1)) 
    croak("Usage: sinh(ang);");
    arg0 = (double )SvNV(ST(0));
    result = (double )sinh(arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) result);
    XSRETURN(argvi);
}</programlisting><para
>Unsurprisingly this is very similar to the code generated by
    <command
moreinfo="none"
>xsubpp</command> (see for example <xref
linkend="advxs.inside"
></xref>). Once you've got this C code the next
    step is to compile it and link it as a shared library such that it
    can be used as a module. Rather than doing this manually we can do
    it using <classname
>MakeMaker</classname> as for any other
    module. Here is the <filename
moreinfo="none"
>Makefile.PL</filename>:</para><programlisting
format="linespecific"
>use ExtUtils::MakeMaker;

WriteMakefile(
              'NAME'      =&gt; 'Simple',
              'VERSION'   =&gt; '0.01',
              'OBJECT'    =&gt; 'simple_wrap.o',
);</programlisting><para
>The key difference here between an XS module and a SWIG
    module is that we don't need to run <command
moreinfo="none"
>xsubpp</command> and
    <classname
>MakeMaker</classname> just needs to compile a C
    file. We do this by using the <varname
>OBJECT</varname> hash key
    to tell <classname
>MakeMaker</classname> the names of the object
    files that we wish to use to form the module. The makefile will
    automatically add the code for compiling the corresponding C files
    to object files. We can now build the module as we would any other
    XS module:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl Makefile.PL</userinput>
Writing Makefile for Simple
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>make</userinput>
cp Simple.pm blib/lib/Simple.pm
cc -c   -fno-strict-aliasing -I/usr/local/include -D_LARGEFILE_SOURCE 
 -D_FILE_OFFSET_BITS=64 -O2   -DVERSION=\"0.01\" -DXS_VERSION=\"0.01\" 
  -fpic -I/home/timj/test/lib/perl5/5.7.2/i686-linux/CORE   simple_wrap.c
Running Mkbootstrap for Simple ()
chmod 644 Simple.bs
rm -f blib/arch/auto/Simple/Simple.so
LD_RUN_PATH="" cc  -shared -L/usr/local/lib simple_wrap.o  
    -o blib/arch/auto/Simple/Simple.so     
chmod 755 blib/arch/auto/Simple/Simple.so
cp Simple.bs blib/arch/auto/Simple/Simple.bs
chmod 644 blib/arch/auto/Simple/Simple.bs</screen><para
>You could include a makefile dependency for the SWIG input
    file itself (running SWIG on it when it is modified) but for a
    distribution that is to be put on CPAN you probably will not want
    to add a SWIG dependency to your distribution since that may limit
    its appeal (many sites may not have SWIG installed and you will
    not be able to guarantee a particular version of SWIG). We can now
    run it to see if it does what we expect:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MSimple -e 'print Simple::sinh(3)'</userinput>
10.0178749274099
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MSimple -e 'print $Simple::PI'</userinput>
3.141592654</screen><para
>As an ever so slightly more complicated example let's take a
    look at how we would write an interface file for the
    <function
moreinfo="none"
>treble</function> of <xref
linkend="xsi.xs"
></xref>:</para><programlisting
format="linespecific"
>%module Treble

%{

int treble(int x)
{
   x *= 3;
   return x;
}

%}

int treble (int x);</programlisting><para
>The difference here is that C code has been inserted into
    the definition. The code between <literal
moreinfo="none"
>%{</literal> and
    <literal
moreinfo="none"
>%}</literal> is copied directly from the definition file
    to the output C code. This is where you can put include file
    loading as well as actual C code. This module can be built in
    exactly the same way as the <classname
>Simple</classname>
    module.</para><sect2
><title
>Arrays and Structs</title><para
>As already mentioned, one thing that distinguishes SWIG
      from other approaches such as XS or
      <classname
>Inline</classname> is its language agnostic
      approach. In many cases this is beneficial but when it comes to
      dealing with complicated data structures the approach usually
      leads to modules that do not fit in well with the language
      philosophy. In SWIG all complex data types (i.e. pointer types)
      are treated as opaque objects. This means that arrays and
      structures are always treated as pointers. In most cases this is
      fine since many libraries use structures as opaque entities
      already and simply pass the pointer from function to
      function. Additionally, if the components of the structure are
      defined SWIG will generate accessor methods to enable access to
      the individual structure components.</para><para
>In this section we'll examine the use of structures from
      SWIG by looking at the <function
moreinfo="none"
>gmtime</function> and related
      functions that we used for the examples in <xref
linkend="advxs.cstruct"
></xref>. Here is a simple SWIG interface to
      <function
moreinfo="none"
>gmtime</function>, <function
moreinfo="none"
>asctime</function> and
      <function
moreinfo="none"
>mktime</function>:</para><programlistingco
><areaspec
><area
coords="4"
id="altxs.swig.include"
></area><area
coords="7"
id="altxs.swig.typedef"
></area><area
coords="9"
id="altxs.swig.typemap"
></area><area
coords="10"
id="altxs.swig.sviv"
></area><area
coords="11"
id="altxs.swig.pntr"
></area></areaspec><programlisting
format="linespecific"
>%module Time

%{
#include "time.h"
%}

typedef int time_t;

%typemap(perl5, in) time_t * (time_t temp) {
  temp = SvIV( $source );
  $target = &amp;temp;
}

struct tm *gmtime(time_t * timep);
char * asctime( const struct tm *timeptr);
time_t mktime( struct tm *timeptr);</programlisting><calloutlist
><callout
arearefs="altxs.swig.include"
><para
>This C code simply makes sure that the C
	    declarations are available when the module is built (the
	    include directive is passed straight to the output C
	    code).</para></callout><callout
arearefs="altxs.swig.typedef"
><para
>Tell SWIG that a <type
>time_t</type> is an integer.</para></callout><callout
arearefs="altxs.swig.typemap"
><para
>Declare a new input typemap for variables of type
	    <type
>time_t *</type> specifically for use with Perl5 (to
	    use this SWIG file for other languages you will need to
	    define different typemaps in the same file). This typemap
	    also declares an additional varialbe similar to PREINIT in
	    XS.</para></callout><callout
arearefs="altxs.swig.sviv"
><para
>Retrieve the integer associated with the input
	    scalar and store it in a temporary variable.</para></callout><callout
arearefs="altxs.swig.pntr"
><para
>Store the pointer of the temporary variable in the
	    target variable.</para></callout></calloutlist></programlistingco><para
>This looks really straightforward except for the
      complication of the typemap definition (the
      <function
moreinfo="none"
>typedef</function> is there simply to tell SWIG that a
      <varname
>time_t</varname> can be treated as an integer). The
      problem is that <function
moreinfo="none"
>gmtime</function> expects a pointer to
      a <type
>time_t</type> variable rather than a simple variable of
      type <type
>time_t</type>. We could write a wrapper C routine
      that allocates memory and populates the value, returning a
      pointer to perl that can be passed to this function but it is
      much simpler from the perl perspective to write a typemap that
      will convert a simple integer (usually the output of the perl
      <function
moreinfo="none"
>time</function> function) to a pointer. If we build
      this module and run we can see the following:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MTime -e 'print Time::gmtime(time)'</userinput>
_p_tm=SCALAR(0x8107cc8)
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MTime -e '$t=Time::gmtime(time); print Time::asctime($t)'</userinput>
Tue Nov 13 02:22:55 2001</screen><para
>SWIG has provided us with an interface even though it
      doesn't know what the contents of a <varname
>tm</varname>
      structure are. All you get is a blessed scalar of an unhelpful
      class (in this case <classname
>_p_tm</classname> since this is a
      pointer to a <varname
>tm</varname>) which SWIG can use for
      internal type consistency checking. If you want to be able to
      look inside the structure you simply tell SWIG what it
      contains:</para><programlisting
format="linespecific"
>%module Time

%{
#include "time.h"
%}

typedef int time_t;

%typemap(perl5, in) time_t * (time_t temp) {
  temp = SvIV( $source );
  $target = &amp;temp;
}

struct tm
{
  int tm_sec;                   /* Seconds.     [0-60] (1 leap second) */
  int tm_min;                   /* Minutes.     [0-59] */
  int tm_hour;                  /* Hours.       [0-23] */
  int tm_mday;                  /* Day.         [1-31] */
  int tm_mon;                   /* Month.       [0-11] */
  int tm_year;                  /* Year - 1900.  */
  int tm_wday;                  /* Day of week. [0-6] */
  int tm_yday;                  /* Days in year.[0-365] */
  int tm_isdst;                 /* DST.         [-1/0/1]*/
};


struct tm *gmtime(time_t * timep);
char * asctime( const struct tm *timeptr);
time_t mktime( struct tm *timeptr);
</programlisting><para
>Now if we use this module we can find out the time from
      the structure:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MTime -e '$t=Time::gmtime(time); print Time::tm_tm_year_get($t)'</userinput>
101</screen><para
>SWIG automatically creates accessor function (there is a
corresponding set method). In this case the function is an accessor
for the <varname
>tm_year</varname> field in the struct
<varname
>tm</varname> so the name is a bit repetitive. Since this
approach is clearly not going to win any fans with users of your class
SWIG provides an option for handling structures as true Perl
objects. If you use the <option
>-shadow</option> option to SWIG the
interface looks much more agreeable:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>swig -perl5 -shadow time.swg</userinput>
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>make</userinput>
...
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MTime -e '$t=Time::gmtime(time); print $t'</userinput>
Time::tm=HASH(0x8144648)
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MTime -e '$t=Time::gmtime(time); print $t-&gt;mktime;'</userinput>
1005656269
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Mblib -MTime -e '$t=Time::gmtime(time); print $t-&gt;{tm_year}'</userinput>
101</screen><para
>The above example shows that the structure is converted to
      an object in class <classname
>Modulename::structname</classname>
      and can be used to invoke methods (in this case
      <function
moreinfo="none"
>mktime</function>) and to access object instance data
      via a tied hash interface.</para><remark
>Still to do with SWIG section if required: Something on
      memory management, an explicit example of array use (including
      N-Dim arrays with accessor methods?), maybe more explicit typemap
      examples. Again, depends on how deeply we want to go before
      moving people onto the SWIG documentation. 4.5 pages so far so
      can probably justify a couple more to round the chapter out at
      approximately 20 pages (without diagrams).</remark></sect2></sect1><sect1
id="altxs.inline"
><title
>The <classname
>Inline</classname> module</title><para
>The <classname
>Inline</classname> modules were first
    developed in 2000 by Brian Ingerson in order to simplify the XS
    learning curve. The family of <classname
>Inline</classname>
    modules allow you to write non-Perl code within the body of your
    Perl program with the expectation that Perl will know what to do
    with it. This can be demonstrated by showing the
    <classname
>Inline</classname> version of our first XS examples
    from <xref
linkend="xsi.xs"
></xref>.</para><sidebar
><para
><classname
>Inline</classname> is not distributed as part of
      Perl. You will need to download it and its dependencies (such as the
      <classname
>Parse::RecDescent</classname> module) from CPAN before you
      can run any of these examples</para></sidebar><programlisting
format="linespecific"
>use Inline "C";

print treble(5),"\n";
&amp;print_hello;

__END__
__C__
void print_hello ()
{
   printf("hello, world\n");
}

int treble(int x)
{
   x *= 3;
   return x;
}</programlisting><para
>If you run this program it does exactly what you expect. No need to
    create a module and work out the XS syntax; it just works. You should get
    the following output:</para><screen
format="linespecific"
>15
hello,world</screen><para
>The first time you run it it will probably take a few seconds to
    execute. The second time it will run as fast as you would expect the XS
    version to run.</para><para
><classname
>Inline</classname> itself is not limited to
    C. Modules exist for writing and calling C++, Python and Java code
    from perl. As an introduction to the techniques of using
    <classname
>Inline</classname> we will keep our description to the
    C implementation but if you are interested in other languages CPAN
    will probably have them all covered!</para><sect2
><title
>What is going on?</title><para
>Before we rush headlong into more examples, it may be
      instructive to explain what is really happening here.<footnote
><para
>At least, what is happening with version 0.43 of
      <classname
>Inline</classname>. Development of this module is
      fairly rapid so things may have changed to some extent by the
      time you read this.</para></footnote> When you write a Perl
      program using <classname
>Inline</classname> unsurprisingly a lot
      of work is going on behind the scenes. In outline, the following
      is occurring:</para><orderedlist
inheritnum="ignore"
continuation="restarts"
><listitem
><para
>The module reads the code from the appropriate place
	  (usually below the <varname
>DATA</varname> handle).</para></listitem><listitem
><para
>An MD5 checksum is then calculated for the code in
	  question.</para></listitem><listitem
><para
>This checksum and associated information (such as
	  operating system and perl version number) is compared with
	  any modules that may have been automatically generated on
	  previous occasions (this all happens in the
	  <filename
moreinfo="none"
>_Inline</filename> or
	  <filename
moreinfo="none"
>$HOME/.inline</filename> directory unless
	  specified otherwise). If it does not match with any
	  existing checksum or configuration the code is analysed to
	  determine the function names and calling arguments (maybe
	  using a parser module such as
	  <classname
>Parse::RecDescent</classname>).</para></listitem><listitem
><para
>An XS module is then generated based on the functions
	  and arguments in the inlined code and with a name derived
	  from the checksum (If no name is specified the module will
	  be the name of the file containing the original code with
	  punctuation removed and the first few letters of the
	  checksum).</para></listitem><listitem
><para
>The module is now built and installed into a local
	  directory.</para></listitem><listitem
><para
>Alternatively, if the checksum matches with a checksum
	  calculated during a previous run of the program the module
	  is loaded directly with out being compiled.</para></listitem></orderedlist><para
>In essence this is fairly straightforward. A module is
      built automatically if required, else it is simply loaded as for
      any other module. This explains why an inlined program takes a
      while to run the first time through but is then almost as fast
      as for a normal module on subsequent runs. The main complication
      is the parsing of the C code to generate XS specifcation. The
      relationship between <classname
>Inline</classname> and the
      approaches of SWIG and XS is shown in <xref
linkend="altxs.layers"
></xref>.</para><figure
float="1"
id="altxs.layers"
><title
>Conceptual relationship between
	<classname
>Inline</classname>, SWIG and XS.</title><mediaobject
><imageobject
><imagedata
fileref="layers.eps"
format="eps"
></imagedata></imageobject><imageobject
><imagedata
fileref="layers.png"
format="png"
></imagedata></imageobject><caption
><para
>This diagram shows the conceptual relationship
	    between the three most popular ways to integrate C with
	    Perl. From this you can see that
	    <classname
>Inline</classname> goes through an XS layer
	    whereas SWIG cuts out the middle man and goes straight to
	    the low level API.</para></caption></mediaobject></figure></sect2><sect2
><title
>Some more examples</title><para
>Now that we have seen the magic and have an idea of what
      is really happening we should now tak a look at some more
      serious examples. Anything that simply passes some scalar
      arguments in and gets a return value should look just like a
      normal C function. In this section we'll cover memory allocation
      issues, lists and multiple return arguments since these are the
      most likely sources of confusion.</para><sect3
><title
>Strings and things</title><para
>If your function returns a string (essentially a memory
	buffer) that has been created in your function then you will
	likely have to worry about memory allocation. We can examine
	this issue by using the string concatenation example of <xref
linkend="advxs.pointers"
></xref>. This function took two strings and
	returned the concatenated string. In that example we used
	<function
moreinfo="none"
>New</function> and <function
moreinfo="none"
>Safefree</function> for
	the memory allocation. This was okay but it relied on the
	<function
moreinfo="none"
>CLEANUP</function> section of the XS code running
	after the memory buffer had been copied back onto the argument
	stack. With <classname
>Inline</classname> we can not get away
	with this since we are being called by the XS routine so if we
	return a <type
>char*</type> we have no way of freeing it after
	it has been returned. To overcome this problem we have two
	choices:</para><itemizedlist
><listitem
><para
>Return an SV containing the result rather than
	    returning a <type
>char*</type>. This allows you to free
	    the memory before returning from your function since the
	    string is copied into an SV:</para><programlistingco
><areaspec
><area
coords="1"
id="altxs.inline.str.svret"
></area><area
coords="5"
id="altxs.inline.str.new"
></area><areaset
coords="7"
id="altxs.inline.str.cpy"
><area
coords="7"
id="altxs.inline.str.cpy1"
></area><area
coords="8"
id="altxs.inline.str.cpy2"
></area></areaset><area
coords="10"
id="altxs.inline.str.newsv"
></area><area
coords="11"
id="altxs.inline.str.free"
></area><area
coords="12"
id="altxs.inline.str.retsv"
></area></areaspec><programlisting
format="linespecific"
>SV * strconcat( char * str1, char * str2 ) {
  char * outstr;
  SV* outsv;
  int len = strlen(str1) + strlen(str2) +1;
  New(0, outstr, len, char);

  strcpy( outstr, (const char*)str1 );
  strcat( outstr, (const char*)str2 );

  outsv = newSVpv(outstr, len);
  Safefree(outstr);
  return outsv;
}</programlisting><calloutlist
><callout
arearefs="altxs.inline.str.svret"
><para
>We mark this function as returning an
		  <type
>SV*</type>.</para></callout><callout
arearefs="altxs.inline.str.new"
><para
>Allocate a string buffer of the right size.</para></callout><callout
arearefs="altxs.inline.str.cpy"
><para
>These two lines are the core of the
		  <function
moreinfo="none"
>strconcat</function> function described in
		  earlier chapters. They represent a real-world call
		  to an external library. Of course, implementing this
		  function using the perl SV API is much
		  easier!</para></callout><callout
arearefs="altxs.inline.str.newsv"
><para
>Create a new SV and copy the contents of the
		  string buffer into it.</para></callout><callout
arearefs="altxs.inline.str.free"
><para
>Free the buffer since we don't need it any
		  longer.</para></callout><callout
arearefs="altxs.inline.str.retsv"
><para
>Return the <type
>SV*</type>. It is
		  automatically marked as mortal by XS before being
		  put onto the return stack.</para></callout></calloutlist></programlistingco><para
>This is a little inefficient since you actually end
	    up allocating two string buffers: once for the string
	    buffer you are using and once when you create the SV. In
	    fact, since you are going to the trouble of using an SV
	    you may as well use the SV's buffer directly:</para><programlistingco
><areaspec
><area
coords="4"
id="altxs.inline.str2.newsv"
></area><areaset
coords="6"
id="altxs.inline.str2.svpvx"
><area
coords="6"
id="altxs.inline.str2.svpvx1"
></area><area
coords="7"
id="altxs.inline.str2.svpvx2"
></area></areaset><areaset
coords="9"
id="altxs.inline.str2.flags"
><area
coords="9"
id="altxs.inline.str2.svpok"
></area><area
coords="10"
id="altxs.inline.str2.svcur"
></area></areaset></areaspec><programlisting
format="linespecific"
>SV * strconcat( char * str1, char * str2 ) {
  SV* outsv;
  int len = strlen(str1) + strlen(str2) +1;
  outsv = NEWSV(0, len);

  strcpy( SvPVX(outstr), (const char*)str1 );
  strcat( SvPVX(outstr), (const char*)str2 );

  SvPOK_on(outsv);
  SvCUR_set(outsv, len);
  return outsv;
}</programlisting><calloutlist
><callout
arearefs="altxs.inline.str2.newsv"
><para
>Create a new SV with a string buffer of the
		  correct size.</para></callout><callout
arearefs="altxs.inline.str2.svpvx"
><para
>We use the <function
moreinfo="none"
>SvPVX</function> macro to
		  obtain the <type
>char*</type> pointing to the start
		  of the buffer.</para></callout><callout
arearefs="altxs.inline.str2.flags"
><para
>Now that we have populated the string we need
		  to tell Perl that the string component is valid and
		  what its useful length is.</para></callout></calloutlist></programlistingco><para
>This has the added inconvenience of having to mark
	    the SV as a valid string (<function
moreinfo="none"
>SvPOK</function>) and
	    the length of it (<function
moreinfo="none"
>SvCur</function>) but you only
	    allocate one buffer.</para></listitem><listitem
><para
>Do what XS does and simply create a new SV with the
	    result and push it onto the stack ourselves. This is
	    essentially identically to returning an <type
>SV*</type>
	    to <classname
>Inline</classname> but cuts out the middle
	    man. We'll describe how to manipulate the argument stack
	    from <classname
>Inline</classname> in the next
	    section.</para></listitem><listitem
><para
>If you really need to allocate a buffer and return
	    it as a non-SV then you will have to use a memory
	    allocator that makes use of mortal SVs:</para><programlistingco
><areaspec
><area
coords="4"
id="altxs.inline.str3.getmem"
></area><area
coords="11"
id="altxs.inline.str3.getmortal"
></area></areaspec><programlisting
format="linespecific"
>char * strconcat3( char * str1, char * str2 ) {
  char* outstr;
  int len = strlen(str1) + strlen(str2) + 1;
  outstr = (char *)get_mortalspace( len );
  strcpy( outstr, (const char*)str1 );
  strcat( outstr, (const char*)str2 );

  return outstr;
}

void * get_mortalspace ( size_t nbytes ) {
  SV * mortal;
  mortal = sv_2mortal( NEWSV(0, nbytes ) );
  return (void *)SvPVX(mortal);
}</programlisting><calloutlist
><callout
arearefs="altxs.inline.str3.getmem"
><para
>Allocate some memory for the buffer.</para></callout><callout
arearefs="altxs.inline.str3.getmortal"
><para
>This is the memory allocator described in
		  <xref
linkend="advxs.char.strings"
></xref>. It is here
		  explicitly rather than putting it in an external
		  file. This does mean that
		  <classname
>Inline</classname> will create a perl
		  interface for the function even though it is not
		  required (if you call it, the function will allocate
		  the requested number of points and free it before
		  you get the return value. The return value will be a
		  pointer).</para></callout></calloutlist></programlistingco><para
>The XS code will receive the <type
>char*</type> put
	    it into an SV and push it onto the argument stack. Once it
	    is read from the stack the memory associated with the SV
	    will be freed automatically.</para></listitem></itemizedlist></sect3><sect3
><title
>Summing an array</title><para
>In <xref
linkend="advxs.numarr"
></xref> we covered in detail
	how to handle perl arrays in XS in the form of a list, a
	reference and a packed string. Here we will show how to use
	<classname
>Inline</classname> to deal with lists and an array
	reference.</para><para
>First a reference. Since a reference is a scalar and a
	corresponding typemap entry exists this is fairly easy to do
	with <classname
>Inline</classname>:</para><programlisting
format="linespecific"
>use Inline "C";

print sum_as_ref([1..10]);

__END__
__C__

int sum_as_ref(AV* avref)
{
  int len;
  int i;
  int sum = 0;
  SV ** elem;

  len = av_len(avref) + 1;

  for (i=0; i&lt;len; i++) {
    elem = av_fetch(avref, i, 0);
    if (elem != NULL)
       sum += SvIV( *elem );
  }
  return sum;
}</programlisting><para
>The above code is almost identical to the example using
	XS (for clarity we are doing the sum in place rather than
	calling the external C routine) and there is nothing new in it
	at all.</para><para
>When processing lists things get more
	interesting. <classname
>Inline</classname> generates the XS
	code for our function and then calls our function. This means
	that we can no longer rely on XS to provide all the stack
	handling facilities that we are familiar
	with. <classname
>Inline</classname> overcomes this problem by
	providing some simple macros of its own for initialising the
	stack variables and manipulating it. These can be demonstrated
	in the following code (without the perl code removed since it
	will be nearly identical to the previous example):</para><programlistingco
><areaspec
><area
coords="1"
id="inline.list.arg"
></area><area
coords="7"
id="inline.list.stackinit"
></area><area
coords="9"
id="inline.list.stacknum"
></area><area
coords="11"
id="inline.list.stackitem"
></area><area
coords="12"
id="inline.list.sviv"
></area></areaspec><programlisting
format="linespecific"
>int sum_as_list( SV* arg1, ... )
{
  int i;
  int len;
  int sum = 0;
  SV* elem;
  Inline_Stack_Vars;

  len = Inline_Stack_Items;
  for (i=0; i&lt;len; i++) {
    elem = Inline_Stack_Item(i);
    sum += SvIV( elem );
  }
  return sum;
}</programlisting><calloutlist
><callout
arearefs="inline.list.arg"
><para
>Ellipsis (...) are used to indicate to
	      <classname
>Inline</classname> that multiple arguments
	      will be used. At least one argument has to be declared
	      even though you may be retrieving all the stack
	      variables using the macros. In this case
	      <varname
>arg1</varname> is declared but is not used in
	      the function directly (it is used via
	      <function
moreinfo="none"
>Inline_Stack_Item(0)</function>).</para></callout><callout
arearefs="inline.list.stackinit"
><para
>Initialise the stack-related variables used by the
	      othe stack macros. This must always be placed in the
	      variable declaration section of the function.</para></callout><callout
arearefs="inline.list.stacknum"
><para
>This counts the number of arguments on the stack.</para></callout><callout
arearefs="inline.list.stackitem"
><para
>Retrieve the i'th SV from the stack.</para></callout><callout
arearefs="inline.list.sviv"
><para
>Now that we have the <type
>SV*</type> from the
	      stack, retrieve the associated integer and add it into
	      the sum.</para></callout></calloutlist></programlistingco><para
>Rather than use the <varname
>T_ARRAY</varname> typemap
	entry to do this (which would require us to provide a memory
	allocator as well as losing information about the size of the
	array) we have written this using
	<classname
>Inline</classname>'s stack macros. Since the set of
	macros is limited they are designed to be very simple and easy
	to understand rather than having to face the daunting contents
	of the perl internals documentation. Using them has the
	additional advantage that you are not tied to the perl XS
	macros themselves - if XS is changed or replaced then it is
	likely that your <classname
>Inline</classname> module would
	continue working without any problems.</para></sect3><sect3
><title
>Multiple return arguments</title><para
>Just as we can read multiple arguments off the stack we
	can also push return arguments onto the stack using
	<classname
>Inline</classname> macros. Here is how we would
	implement the function to return the current time in a hash
	that was described earlier in <xref
linkend="advxs.cstruct.retlist"
></xref>:</para><programlistingco
><areaspec
><area
coords="1"
id="altxs.inline.ppcode.void"
></area><area
coords="4"
id="altxs.inline.ppcode.stackvars"
></area><area
coords="5"
id="altxs.inline.ppcode.stackreset"
></area><area
coords="9"
id="altxs.inline.ppcode.stackpush"
></area><area
coords="26"
id="altxs.inline.ppcode.stackdone"
></area></areaspec><programlisting
format="linespecific"
>void gmtime_as_list( time_t clock )
{
  struct tm * tmbuf;
  Inline_Stack_Vars;
  Inline_Stack_Reset;

  tmbuf = gmtime( &amp;clock );

  Inline_Stack_Push( sv_2mortal( newSVpv("sec", 3) ));
  Inline_Stack_Push( sv_2mortal( newSViv(tmbuf-&gt;tm_sec) ));
  Inline_Stack_Push( sv_2mortal( newSVpv("min", 3) ));
  Inline_Stack_Push( sv_2mortal( newSViv(tmbuf-&gt;tm_min) ));
  Inline_Stack_Push( sv_2mortal( newSVpv("hour", 4) ));
  Inline_Stack_Push( sv_2mortal( newSViv(tmbuf-&gt;tm_hour) ));
  Inline_Stack_Push( sv_2mortal( newSVpv("mday", 4) ));
  Inline_Stack_Push( sv_2mortal( newSViv(tmbuf-&gt;tm_mday) ));
  Inline_Stack_Push( sv_2mortal( newSVpv("mon", 3) ));
  Inline_Stack_Push( sv_2mortal( newSViv(tmbuf-&gt;tm_mon) ));
  Inline_Stack_Push( sv_2mortal( newSVpv("year", 4) ));
  Inline_Stack_Push( sv_2mortal( newSViv(tmbuf-&gt;tm_year) ));
  Inline_Stack_Push( sv_2mortal( newSVpv("wday", 4) ));
  Inline_Stack_Push( sv_2mortal( newSViv(tmbuf-&gt;tm_wday) ));
  Inline_Stack_Push( sv_2mortal( newSVpv("yday", 4) ));
  Inline_Stack_Push( sv_2mortal( newSViv(tmbuf-&gt;tm_yday) ));

  Inline_Stack_Done;
}</programlisting><calloutlist
><callout
arearefs="altxs.inline.ppcode.void"
><para
>Just as for XS we use a <type
>void</type> return
	      type when we are pushing arguments onto the stack
	      ourselves.</para></callout><callout
arearefs="altxs.inline.ppcode.stackvars"
><para
>This initializes the stack variables used by the
	      other macros.</para></callout><callout
arearefs="altxs.inline.ppcode.stackreset"
><para
>This must be used before any variables are pushed
	      onto the stack. It resets the stack pointer to the
	      beginning of the stack (rather than at the end of the
	      input arguments).</para></callout><callout
arearefs="altxs.inline.ppcode.stackpush"
><para
>Push an SV onto the stack. This is completely
	      equivalent to <function
moreinfo="none"
>XPUSHs</function>.</para></callout><callout
arearefs="altxs.inline.ppcode.stackdone"
><para
>Use this macro to indicate when all the necessary
	      variables have been pushed onto the stack.</para></callout></calloutlist></programlistingco><para
>All we have done here is replace
	<function
moreinfo="none"
>PUSHs</function> with
	<function
moreinfo="none"
>Inline_Stack_Push</function>. It's as simple as
	that!</para></sect3></sect2><sect2
><title
>Summary</title><para
><classname
>Inline</classname> is a very powerful addition
      to your armoury. With only a small loss in overall flexibility
      (much of which you won't miss) you can mix perl and C code
      without ever having to worry about makefiles and XS syntax. All
      you need is a knowledge of the variable manipulation API and
      possibly typemaps. The main things to be aware of are:</para><itemizedlist
><listitem
><para
>You can not have input arguments that are also return
	  arguments. If you need this simply use the SV* as an
	  argument and modify it directly. For example,</para><programlisting
format="linespecific"
>void modify_inplace( SV* sv) {
  sv_setiv(sv, 5);
}</programlisting><para
>If the above function is called via
	  <classname
>Inline</classname> then the scalar argument will
	  be set to <literal
moreinfo="none"
>5</literal> on completion. Also, as
	  mentioned in <xref
linkend="xsi.design"
></xref> in many cases the interface
	  is better designed handling this in a different way.</para></listitem><listitem
><para
>Be careful with memory allocation. You will not be
	  able to explicitly free memory when you return from your
	  <classname
>Inline</classname> function (especially if you
	  have allocated memory for a string buffer that is to be
	  returned) so either just use an SV directly (either by
	  pushing it on the stack or by returning it) or allocate
	  memory using mortal SV's
	  (<function
moreinfo="none"
>sv_2mortal(NEWSV(..))</function> and return the
	  buffer pointer with <function
moreinfo="none"
>SvPVX</function>) rather than
	  with <function
moreinfo="none"
>New</function>.</para></listitem></itemizedlist><para
>We can not cover all of <classname
>Inline</classname> here
      but hopefully this section has given a taste of what is
      possible.</para><remark
>If we want to flesh out this section we could include
      instructions on how to package these into modules (without
      installing Inline) and how to link against external
      libraries. In general I think that is probably overkill since
      this chapter exists to fill the reader with wonder at the
      possibilities - they can read up further themselves.</remark></sect2></sect1><sect1
id="altxs.pdlpp"
><title
>PDL::PP</title><para
>We saw in <xref
linkend="advxs.xspdl"
></xref> that creating interfaces to from
the Perl Data Language to external libraries using XS is quite complex. In
addition to the native complexity of PDL there are four issues that further
complicate PDL/XS interfaces:</para><variablelist
><varlistentry
><term
>Data typing</term><listitem
><para
>Many libraries have different routines for different data
	  types. Writing XS interfaces that are identical except for the data
	  type of the PDL is time consuming and error prone.</para></listitem></varlistentry><varlistentry
><term
>Slicing</term><listitem
><para
>When a subsection of a PDL is used PDL does not make a copy
	  (data can be modified <quote
>in place</quote>). If a slice is passed
	  to XS the pointer will not be referring to the start of the slice
	  but the start of the parent PDL!</para></listitem></varlistentry><varlistentry
><term
>PDL <quote
>threading</quote></term><listitem
><para
>One nice feature of PDL is its ability to automatically
	  <quote
>thread</quote> over additional dimensions. This has to be
	  implemented in C for speed but is essentially impossible to get
	  right if it is coded <quote
>by hand</quote>.</para></listitem></varlistentry><varlistentry
><term
>Changes in API</term><listitem
><para
>If the internal API for either PDL or Perl is modified it is
	  highly likely that the XS code would have to be fixed. Writing XS
	  code that works for multiple versions of internals API is difficuly
	  and quickly leaves to an <quote
>ifdef forest</quote> of C pre
	  processor directives.</para></listitem></varlistentry></variablelist><para
>To solve the above issues a PDL pre-processor language was written
    to abstract out the numeric interface from the XS implementation. These
    interface definitions (using a file suffix of <filename
moreinfo="none"
>.pd</filename>)
    are automatically processed by the <classname
>PDL::PP</classname> module
    to generate the required XS code. <classname
>PDL::PP</classname>
    automatically generates code for multiple data types, keeps track of
    slicing and implement threading. If the API is changed all that
    needs to be modified is <classname
>PDL::PP</classname>, PDL itself can be
    rebuilt with minimal changes.</para><para
>In fact the primary goal of <classname
>PDL::PP</classname> is to
    allow numerical code to be written in a C-like language (for speed)
    without having to worry about XS. Support for external libraries is a side
    effect of this goal. <classname
>PDL::PP</classname> is an extremely
    complicated module and no attempt will be made to describe all it's
    features. What we will show is how to write a
    <classname
>PDL::PP</classname> interface to the <function
moreinfo="none"
>sum</function>
    described in <xref
linkend="advxs"
></xref>.</para><sect2
><title
>The <filename
moreinfo="none"
>.pd</filename> file</title><para
>Instead of using a <filename
moreinfo="none"
>.xs</filename> file
      <classname
>PDL::PP</classname> code is written to a
      <filename
moreinfo="none"
>.pd</filename> file. In this example we'll create a file
      called <filename
moreinfo="none"
>sum.pd</filename> to hold the definitions.  This file
      is a perl program that is run as part of the make process (see the next
      section to see how). This program creates the normal XS infrastructure:
      the XS file and the associated perl module. For this example the first
      thing we need to do is to supply the code for the
      <function
moreinfo="none"
>sum</function> itself. We do this using the
      <function
moreinfo="none"
>pp_addhdr</function> . This function is used to place
      additional C code at the top of the output XS file (before the MODULE
      line). That C code is supplied as an argument:</para><programlisting
format="linespecific"
>pp_addhdr('

int sum ( int num, int * array ) {
  int thesum = 0;
  int count;
  for (count = 0; count &lt; num; count++) {
    thesum += array[count];
  }
  return thesum;
}

');</programlisting><para
>Now that the C function is present we can supply the PP code for
      the PDL interface. We do this using the <function
moreinfo="none"
>pp_def</function>
      function:</para><programlistingco
><areaspec
><area
coords="1"
id="altxs.pdlpp.ppdef.sum"
></area><area
coords="2"
id="altxs.pdlpp.ppdef.pars"
></area><area
coords="3"
id="altxs.pdlpp.ppdef.gentype"
></area><area
coords="4"
id="altxs.pdlpp.ppdef.code"
></area></areaspec><programlisting
format="linespecific"
>pp_def( 'sum',
        Pars =&gt; 'a(n); [o]b()',
        GenericTypes =&gt; [L],
        Code =&gt; '$b() = sum( $SIZE(n), $P(a));',
);</programlisting><calloutlist
><callout
arearefs="altxs.pdlpp.ppdef.sum"
><para
>The first argument to <function
moreinfo="none"
>pp_def</function> is the
name of the routine being generated.</para></callout><callout
arearefs="altxs.pdlpp.ppdef.pars"
><para
>This is the calling signature of the PDL routine. Here we
	    are saying that the first argument is a one dimensional vector of
	    dimension <literal
moreinfo="none"
>n</literal> with an output argument (that can
	    also be a second input argument treated as a buffer) that is
	    simple scalar PDL (there are no dimensions specified).</para></callout><callout
arearefs="altxs.pdlpp.ppdef.gentype"
><para
>GenericTypes indicates to PP that only specific data types
	    are supported by the routine. In this case only type <type
>long
	    int</type> is supported by our C function.</para></callout><callout
arearefs="altxs.pdlpp.ppdef.code"
><para
>This is the actual implementation of the PP
	    routine. <function
moreinfo="none"
>$SIZE(n)</function> is used to retrieve the
	    size of dimensions labelled
	    <varname
>n</varname>. <function
moreinfo="none"
>$P(a)</function> retrieves the
	    pointer to the PDL named <varname
>$a</varname>. These two
	    arguments are passed to the C <function
moreinfo="none"
>sum</function> and the
	    result is stored in the scalar variable named
	    <varname
>$b</varname>.</para></callout></calloutlist></programlistingco><para
>This all looks fairly strange at first but there is some logic to
      it all and it has successfully formed a layer between you and XS (the XS
      file generated from this example PP file is 30kB!). This definition on
      its own is useless so the next step is to convert the file to XS
      code<footnote
><para
>An <classname
>Inline::PDLPP</classname> module is
      under development at this time. This will allow PP definitions to be
      placed in perl programs directly in the same way as described in <xref
linkend="altxs.inline"
></xref> for the C language.</para></footnote>.</para></sect2><sect2
><title
>The <filename
moreinfo="none"
>Makefile.PL</filename></title><para
>Since we now have a file called <filename
moreinfo="none"
>sum.pd</filename> rather
      than the file <filename
moreinfo="none"
>Sum.xs</filename> expected by
      <classname
>ExtUtils::MakeMaker</classname> we have to add some PDL
      helper routines to the <filename
moreinfo="none"
>Makefile.PL</filename> to make sure
      that the PP definition file is processed in order to generate a normal
      XS file. We do this by adding a new makefile target and retrieving
      PDL-specific build options from the module
      <classname
>PDL::Core::Dev</classname>:</para><programlistingco
><areaspec
><area
coords="5"
id="altxs.pdlpp.coredev"
></area><area
coords="7"
id="altxs.pdlpp.pack"
></area><area
coords="8"
id="altxs.pdlpp.stdargs"
></area><area
coords="12"
id="altxs.pdlpp.mypostamble"
></area><area
coords="13"
id="altxs.pdlpp.postamble"
></area></areaspec><programlisting
format="linespecific"
># Use this as a template for the Makefile.PL for
# any external PDL module.

use ExtUtils::MakeMaker;
use PDL::Core::Dev qw/ pdlpp_stdargs pdlpp_postamble/;

$pack = [qw/ sum.pd Sum PDL::Sum /];
%hash = pdlpp_stdargs($pack);

WriteMakefile(%hash);

sub MY::postamble {
        pdlpp_postamble($::pack);
}  # Add genpp rule</programlisting><calloutlist
><callout
arearefs="altxs.pdlpp.coredev"
><para
>The <classname
>PDL::Core::Dev</classname> module
	    contains some helper routines designed specifically for
	    generating makefiles for <classname
>PDL::PP</classname>
	    extensions.</para></callout><callout
arearefs="altxs.pdlpp.pack"
><para
><varname
>$pack</varname> contains a reference to an
	    array specifying the name of the source file, the name of
	    the resulting module (<filename
moreinfo="none"
>.pm</filename> and
	    <filename
moreinfo="none"
>.xs</filename>) files and the namespace of the
	    module.</para></callout><callout
arearefs="altxs.pdlpp.stdargs"
><para
>The <function
moreinfo="none"
>pdlpp_stdargs</function> returns a
	    hash containing the MakeMaker arguments required to build a
	    <classname
>PDL::PP</classname> based module.</para></callout><callout
arearefs="altxs.pdlpp.mypostamble"
><para
>The <methodname
>postamble</methodname> method
	    overrides the default version in the
	    <classname
>MY</classname> class (as setup by MakeMaker)
	    and is invoked automatically by MakeMaker to place
	    additional dependencies in the output
	    <filename
moreinfo="none"
>Makefile</filename>. </para></callout><callout
arearefs="altxs.pdlpp.postamble"
><para
>The <function
moreinfo="none"
>pdlpp_postamble</function> function
	    generates the PDL-specific makefile dependencies from the
	    single argument. The argument is specified as
	    <varname
>$::pack</varname> to indicate that the variable
	    from the main namespace and not from the
	    <classname
>MY</classname> namespace.</para></callout></calloutlist></programlistingco><para
>Now if we attempt to build this module we get the following output
      (on linux):</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl Makefile.PL</userinput>
Writing Makefile for PDL::Sum
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>make</userinput>
/local/bin/perl -I/usr/local/perl-5.6/lib/site_perl/5.6.0/i686-linux/blib/lib 
   -I/usr/local/perl-5.6/lib/site_perl/5.6.0/i686-linux/blib/arch 
   "-MPDL::PP qw/PDL::Sum PDL::Sum Sum/" sum.pd
cp Sum.pm blib/lib/PDL/Sum.pm
/local/bin/perl -I/usr/local/perl-5.6/lib/5.6.0/i686-linux 
  -I/usr/local/perl-5.6/lib/5.6.0 
   /usr/local/perl-5.6/lib/5.6.0/ExtUtils/xsubpp  
    -typemap /usr/local/perl-5.6/lib/5.6.0/ExtUtils/typemap 
     -typemap/usr/local/perl-5.6/lib/site_perl/5.6.0/i686-linux/PDL/
Core/typemap.pdl 
      Sum.xs &gt; Sum.xsc &amp;&amp; mv Sum.xsc Sum.c
gcc -c -I/usr/local/perl-5.6/lib/site_perl/5.6.0/i686-linux/PDL/Core 
   -fno-strict-aliasing -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -O2     
   -DVERSION=\"0.10\" -DXS_VERSION=\"0.10\" -fpic 
   -I/usr/local/perl-5.6/lib/5.6.0/i686-linux/CORE  Sum.c
Running Mkbootstrap for PDL::Sum ()
chmod 644 Sum.bs
LD_RUN_PATH="" gcc -o blib/arch/auto/PDL/Sum/Sum.so  
   -shared -L/usr/local/lib Sum.o     
chmod 755 blib/arch/auto/PDL/Sum/Sum.so
cp Sum.bs blib/arch/auto/PDL/Sum/Sum.bs
chmod 644 blib/arch/auto/PDL/Sum/Sum.bs
Manifying blib/man3/PDL::Sum.3</screen><para
>The first step in the build is now to run the pd file through perl
      before proceeding with a normal build (<command
moreinfo="none"
>xsubpp</command>
      followed by the C compiler).</para></sect2><sect2
><title
>Pure PDL</title><para
>Now that we have shown how to call an external library using
      <classname
>PDL::PP</classname> it may be instructive to show the
      equivalent routine written using the PP language without referring to any
      external C code:</para><programlistingco
><areaspec
><area
coords="4"
id="altxs.pdlpp.sumover.tmp"
></area><area
coords="5"
id="altxs.pdlpp.sumover.loop"
></area><area
coords="6"
id="altxs.pdlpp.sumover.inc"
></area><area
coords="7"
id="altxs.pdlpp.sumover.close"
></area><area
coords="8"
id="altxs.pdlpp.sumover.assign"
></area></areaspec><programlisting
format="linespecific"
>pp_def(
       'sumover',
       Pars =&gt; 'a(n); [o]b();',
       Code =&gt; 'double tmp=0;
               loop(n) %{ 
                   tmp += $a(); 
               %}
               $b() = tmp;
               '
              );</programlisting><calloutlist
><callout
arearefs="altxs.pdlpp.sumover.tmp"
><para
>Initialise a new double precision variable.</para></callout><callout
arearefs="altxs.pdlpp.sumover.loop"
><para
>Loop over dimension <varname
>n</varname> using the inbuilt
	    <function
moreinfo="none"
>loop()</function> macro.</para></callout><callout
arearefs="altxs.pdlpp.sumover.inc"
><para
>Add the current value to the temporary placeholder. Note how
	    no index is required. <classname
>PDL::PP</classname> automatically
	    works out what index you are referring to.</para></callout><callout
arearefs="altxs.pdlpp.sumover.close"
><para
>This is the special syntax for ending a loop.</para></callout><callout
arearefs="altxs.pdlpp.sumover.assign"
><para
>Assign the total to the output variable.</para></callout></calloutlist></programlistingco><para
>This code is still translated to C and built as an XS module but
      now works on all data types natively. This is the recommended approach
      to writing fast loops in PDL and is one of the resons that PDL can
      approach the speed of pure C.</para></sect2></sect1><sect1
><title
>The Rest</title><para
>The modules and packages described so far are by no means an
  exhaustive list but do cover the techniques you would most likely want to
  pursue. There are other, less portable, methods for calling functions in C
  shared libraries from perl but with the appearance of the
  <classname
>Inline</classname> module most of these techniques can (and
  probably should) be safely ignored. For example, the
  <classname
>C::DynaLib</classname> module can be used to call C functions
  directly from shared libraries and did have a use for prototyping simple
  systems without requiring XS. The following example (from the
  <classname
>C::DynaLib</classname> documentation) shows how to use it to
  call a function from the standard math library:</para><programlisting
format="linespecific"
>use C::DynaLib;
$libm = new C::DynaLib("-lm");
$sinh = $libm-&gt;DeclareSub("sinh", "d", "d");
print "The hyperbolic sine of 3 is ", &amp;$sinh(3), "\n";</programlisting><para
>and this does print the expected answer of 10.018 (on supported
architectues). With <classname
>Inline</classname> this would be written
as</para><programlisting
format="linespecific"
>use Inline "C";

print "The hyperbolic sine of 3 is ", mysinh(3), "\n";

__END__
__C__
double mysinh (double ang) { 
    return sinh(ang); 
}</programlisting><para
>which has the two key advantages of being simpler to write<footnote
><para
>This can be written in 2 lines for those of you who prefer
compactness:</para><programlisting
format="linespecific"
>use Inline C =&gt; "double mysinh (double ang) { return sinh(ang); }";
print "The hyperbolic sine of 3 is ", mysinh(3), "\n";</programlisting></footnote>
 and more
portable. The PDL equivalent of <classname
>C::DynaLib</classname> is
<classname
>PDL::CallExt</classname> and this has also been superceded, this
time by <classname
>PDL::PP</classname>.</para></sect1><sect1
><title
>Further reading</title><variablelist
><varlistentry
><term
>SWIG</term><listitem
><para
><ulink
url="http://www.swig.org"
>http://www.swig.org</ulink></para></listitem></varlistentry><varlistentry
><term
>Inline</term><listitem
><para
><ulink
url="http://inline.perl.org"
>http://inline.perl.org</ulink></para></listitem></varlistentry></variablelist></sect1></chapter><chapter
><title
>Functions for Embedding and Internals</title><para
></para></chapter><chapter
><title
>Embedding Perl in C</title><sect1
><title
>What is Embedding?</title><para
>      In the first half of this book, we've looked at what it means to
      extend Perl with additional routines from C. Sometimes, however,
      there are occasions when you want to call a piece of Perl from
      inside a C program - we call this "embedding" Perl in C, because
      we link an entire Perl interpreter inside another C program.
    </para><sect2
><title
>When do I want to embed?</title><para
>	The best and most well-known example of embedding Perl in C is
	Apache's <literal
moreinfo="none"
>mod_perl</literal> module. This allows the
	user to interact with Perl at every level of the Apache web
	server - one can write configuration files in Perl, write Perl
	programs to handle HTTP requests with Perl objects, and so
	on. In short, it allows you to use Perl to script and control
	the rest of the program.
      </para><para
>	More specific examples include the embedding of Perl into the
	Xchat IRC client to enable the user to script complex actions
	in Perl; the GIMP graphics editor, which allows graphical
	manipulations to be encoded in Perl; vim, a text editor, which
	can be both configured and manipulated using Perl; and
	gnumeric, the GNOME spreadsheet, which exposes the data in the
	spreadsheet cells to Perl for additional manipulation.
      </para><para
>	All of these examples have some common objectives: to make the
	application extensible through user-provided plugin scripts,
	to make configuration more flexible by involving a high-level
	language and the control structures that it provides, and to
	help the user script common or complex sequences of
	actions. If an application that you are working with could
	benefit from these features, you should contemplate the
	possibility of embedding a Perl interpreter.
      </para></sect2><sect2
><title
>When do I <emphasis
>not</emphasis> want to embed?</title><para
>	Embedding Perl into a program is not a panacea, and embedding
	Perl into an existing program is not a step to be taken
	lightly. We don't recommended embedded Perl as a cheap way of
	avoiding writing a configuration parser or extensible
	scripting system.
      </para><para
>	Another thing to be conscious of is that embedding Perl into
	an application will increase its size and memory usage,
	possibly introduce memory leaks or instabilities, and
	occasionally slow the application down. Nevertheless, the
	examples we have given above do show that there is sometimes a
	really big gain to be won by including Perl in your program.
      </para></sect2><sect2
><title
>Things to think about</title><para
>	In the next chapter, we'll look in more detail at the
	decisions that need to be made when embedding Perl into an
	application. Fundamentally, however, you need to consider to
	what degree Perl should have access to the guts of your
	program.
      </para><para
>	This in turn influences details such as which data structures
	you are going to expose to Perl and how they will appear to
	the Perl programmer; what C functions in your API will be
	available, and, again, how they would be used from Perl; where
	your Perl programs will come from and at what point in the
	program they will be used, and so on.
      </para><para
>	Again, we'll see practical answers to these questions in the
	next chapter; let's now see an example of calling a Perl
	program from inside a C program.
      </para></sect2></sect1><sect1
><title
> ``Hello C'' from Perl</title><para
>      The fundamentals of embedding are simple: we perform almost
      exactly the same function as the main body of the
      <literal
moreinfo="none"
>perl</literal> binary. That's to say, we construct and
      initialize an interpreter, use it to parse a string of code, and
      then execute that code. Here's a simple program which does that.
    </para><programlistingco
><areaspec
><area
coords="1"
id="embed.simple.1"
></area><area
coords="2"
id="embed.simple.2"
></area><area
coords="4"
id="embed.simple.3"
></area><area
coords="8"
id="embed.simple.4"
></area><area
coords="10"
id="embed.simple.5"
></area><area
coords="11"
id="embed.simple.6"
></area><area
coords="12"
id="embed.simple.7"
></area><area
coords="13"
id="embed.simple.8"
></area><areaset
coords=""
id="embed.simple.9"
><area
coords="14"
id="foo.dummy.3"
></area><area
coords="15"
id="foo.dummy.4"
></area></areaset></areaspec><programlisting
format="linespecific"
>#include &lt;EXTERN.h&gt;
#include &lt;perl.h&gt;

static PerlInterpreter *my_perl;

int main(int argc, char **argv)
{
    char* command_line[] = {"", "-e", "print \"Hello from C!\\n\";"};

    my_perl = perl_alloc();
    perl_construct(my_perl);
    perl_parse(my_perl, NULL, 3, command_line, (char **)NULL);
    perl_run(my_perl);
    perl_destruct(my_perl);
    perl_free(my_perl);
}</programlisting><calloutlist
><callout
arearefs="embed.simple.1"
><para
>	    This first header file sets up some macros to tell the
	    main Perl header file that we're not really Perl itself,
	    but an external application using the Perl API.
	  </para></callout><callout
arearefs="embed.simple.2"
><para
>	    Now we load up the main Perl header, which provides the
	    macros and prototypes for all the functions in the Perl
	    API.
	  </para></callout><callout
arearefs="embed.simple.3"
><para
>	    Since one can actually have multiple Perl interpreters in
	    a program, all the interpreter-global data gets stored in
	    a structure called, naturally, a <classname
>PerlInterpreter</classname>.
	  </para></callout><callout
arearefs="embed.simple.4"
><para
>	    Even when we're embedding Perl, we're dealing with the
	    honest-to-goodness Perl interpreter, which expects to get
	    arguments from the command line. Hence, we have to provide
	    a set of command line arguments, just as we'd expect to
	    find in <literal
moreinfo="none"
>argv</literal>. (And just like in
	    <literal
moreinfo="none"
>argv</literal>, the first element of the array is
	    the name of the command, rather than the first command
	    line argument; since we're not bothered about that, we
	    leave it blank.)
	  </para></callout><callout
arearefs="embed.simple.5"
><para
>	    Just like any other structure pointer, we need to allocate
	    memory for it; <literal
moreinfo="none"
>perl_malloc</literal> returns us
	    some memory for a Perl interpreter.
	  </para></callout><callout
arearefs="embed.simple.6"
><para
>	    Next, we set up the interpreter and all its associated
	    data structures with <literal
moreinfo="none"
>perl_construct</literal>.
	  </para></callout><callout
arearefs="embed.simple.7"
><para
>	    Now we're in a position where we can parse the incoming
	    Perl "script", which is specified in the
	    <literal
moreinfo="none"
>-e</literal> argument to the faked command line.
	  </para></callout><callout
arearefs="embed.simple.8"
><para
>	    As we know, Perl is bytecode-compiled - first, the code is
	    parsed into an internal representation, and then it's run;
	    <literal
moreinfo="none"
>perl_run</literal> starts the main loop running
	    the code.
	  </para></callout><callout
arearefs="embed.simple.9"
><para
>	    Finally, we cleanly shut down the interpreter, and release
	    the memory that had been allocated for it.
	  </para></callout></calloutlist></programlistingco><para
>      It's interesting to compare this with the source to the Perl
      interpreter itself; if you don't believe we're performing the
      same functions as the Perl interpreter, take a look at the guts
      of <filename
moreinfo="none"
>miniperlmain.c</filename>:
      <programlisting
format="linespecific"
>    if (!PL_do_undump) {
        my_perl = perl_alloc();
        if (!my_perl)
            exit(1);
        perl_construct(my_perl);
        PL_perl_destruct_level = 0;
    }

    exitstatus = perl_parse(my_perl, xs_init, argc, argv, (char **)NULL);
    if (!exitstatus) {
        exitstatus = perl_run(my_perl);
       perl_destruct(my_perl);
       exitstatus = STATUS_NATIVE_EXPORT;
    } else {
      perl_destruct(my_perl);
    }

    perl_free(my_perl);

    PERL_SYS_TERM();

    exit(exitstatus);
    return exitstatus;</programlisting>
      As you can see, this is more or less the same as the above with
      a little more error checking.
    </para><sect2
><title
>Compiling Embedded Programs</title><para
>	Compiling programs which embed Perl is a little bit special;
	you need to ensure that you're compiling the code with exactly
	the same options that were used to compile the Perl
	interpreter. While we could get these out of
	<filename
moreinfo="none"
>Config.pm</filename>, there's a module which makes
	it very easy for us: <classname
>ExtUtils::Embed</classname>. 
      </para><para
>	As we know from the first chapter, a program's compilation
	takes place in two stages: compilation proper, and
	linking. <classname
>ExtUtils::Embed</classname> provides two
	functions, <literal
moreinfo="none"
>ccopts</literal> and
	<literal
moreinfo="none"
>ldopts</literal> to tell us the options for each
	stage. In fact, if we run these functions from the Perl
	command line, they'll handily spit the options to standard
	output, making it ideal to use as part of our build process.
      </para><para
>	So, let's take the example code above,
	<filename
moreinfo="none"
>simple.c</filename>, and compile it and then link it:
	<screen
format="linespecific"
> % cc -o simple.o -c simple.c `perl -MExtUtils::Embed -e ccopts`
 % cc -o simple simple.o `perl -MExtUtils::Embed -e ldopts`
 % ./simple
Hello from C!</screen>
      </para><para
>	Now we have a way to execute simple Perl programs from C,
	albeit if we specify them on the Perl command line;
	let's make this a bit more powerful.
      </para></sect2></sect1><sect1
><title
> Passing Data</title><para
>      In a real embedded application, we need a way to share data
      between Perl and C. For instance, the Apache embedded Perl
      module, <literal
moreinfo="none"
>mod_perl</literal>, allows you to store
      configuration data in Perl variables.
    </para><para
>      As we saw in <xref
linkend="api.get.sv"
></xref>, Perl provides a
      function called <literal
moreinfo="none"
>get_sv</literal> which allows to grab
      an SV from the Perl symbol table. Let's suppose we're writing a
      mail client, (we'll call it "Hermes") and we want our users to
      be able to set some of the configuration in Perl. First, we'll
      look at general settings which apply to the whole application;
      in the next section, we'll write some logic for settings which
      apply on a per-message basis.
    </para><para
>      Our sample configuration file would look something like this:
      <programlisting
format="linespecific"
>package Hermes;

$save_outgoing = 1;

# Prefer vim, but use emacs if vim not available.
$editor = `which vim` || `which emacs`; 

$quote_char = "&gt; ";

$check_every = 10; # seconds</programlisting>
    </para><para
>      Now, inside our mail client, we're going to want to have Perl
parse and run this configuration, and we'll want to get at the
results. Well, we know how to do the first part: we allocate, make and
instantiate a Perl interpreter.</para><programlisting
format="linespecific"
>#include &lt;EXTERN.h&gt;
#include &lt;perl.h&gt;

static PerlInterpreter *my_perl;

int parse_config(char * config_file)
{
    char* command_line[2] = {"", NULL};
    command_line[1] = config_file;

    my_perl = perl_alloc();
    perl_construct(my_perl);
    if (perl_parse(my_perl, NULL, 3, command_line, (char **)NULL)) {
        return 0; /* Failed to parse */ 
    }

    perl_run(my_perl);
    if (SvTRUE(ERRSV)) {
        return 0; /* Failed to execute */
    }

    return 1;
}
</programlisting><para
>This is substantially the same as the above, except that the "command
line" passed to Perl is determined at run time, when the name of the
configuration file is passed in to the
<function
moreinfo="none"
>parse_config</function>.  The other difference is that once
we have run the Perl, we check whether or not <literal
moreinfo="none"
>ERRSV</literal>
is true; this is the C-side equivalent of checking
<literal
moreinfo="none"
>$@</literal>.</para><para
>Now we have our Perl run, we should be able to get at the values using
the <literal
moreinfo="none"
>get_sv</literal> function. For instance, when it comes
to time to send a mail message for text editing:
<programlisting
format="linespecific"
>
int edit_message(char* filename) {
    char *editor;

    editor = SvPV_nolen(get_sv("Hermes::editor"));

    /* And now we execute the editor */
    ...
}</programlisting></para><para
>      Similarly, we can set these SVs to values from our C code if we
      want to communicate information back to Perl, using
      <literal
moreinfo="none"
>get_sv</literal>. However, it's more usual for us to
      pass values to Perl subroutines, so let's see how to do this. 
    </para></sect1><sect1
><title
> Calling Perl Routines</title><para
>      The techniques we saw in <xref
linkend="advxs.cb.imm"
></xref> for
      calling Perl subroutines from XS are equally applicable to
      calling Perl subroutines from an embedded program. We still need
      to go about putting parameters onto the stack, making a call out
      to Perl, and collecting return values. Let's take a closer look
      at those techniques now.
    </para><para
>      Perl has a number of different functions for calling routines,
      but the two we're going to concentrate on are
      <function
moreinfo="none"
>call_sv</function> and
      <function
moreinfo="none"
>call_pv</function>. How you decide which one to call
      is easy: if you have an SV which refers to a subroutine - one
      which contains either a code reference or a subroutine's name (a
      symbolic reference) - then you use
      <function
moreinfo="none"
>call_sv</function>. Otherwise, if you only have the
      name as a string, you use <function
moreinfo="none"
>call_pv</function>.
    </para><para
>      The typical embedded program will generally call subroutines by
      name, using <function
moreinfo="none"
>call_pv</function>, although there are
      instances where <function
moreinfo="none"
>call_sv</function> is correct.
    </para><para
>      For example, let's suppose we want to allow users of our mailer
      to define a subroutine which gets passed a mail message for
      pre-processing as the user replies to it. We could state in our
      program's embedding API that the configuration file must define
      a subroutine called <function
moreinfo="none"
>Hermes::reply_to_hook</function>,
      and we could use <function
moreinfo="none"
>call_pv</function> with the string
      <literal
moreinfo="none"
>"Hermes::reply_to_hook"</literal>, or we could allow
      something like this:
      <programlisting
format="linespecific"
>package Hermes;
$reply_to_hook = sub {
	my @mail = @_;
	...
}</programlisting>
    </para><para
>      In this case, we'd use <function
moreinfo="none"
>get_sv("Hermes::reply_to_hook",
      TRUE)</function> to return a code reference, which we'd then
      call with <function
moreinfo="none"
>call_sv</function>.
    </para><para
>      We'll see another example of where <function
moreinfo="none"
>call_sv</function>
      is necessary when we look at callbacks later in the chapter, but
      for now, we'll concentrate on <function
moreinfo="none"
>call_pv</function>.
    </para><para
>      Here's the simplest possible instance of calling a Perl routine
      from C; it has no parameters and no return value. One good
      example of this type of routine would be an exit handler -
      something that our mail program calls when it's about to quit,
      so that any state established by the Perl program can be cleared
      up<footnote
><para
>	  Of course, this is what <literal
moreinfo="none"
>END</literal> blocks are
	  for, and if we used an <literal
moreinfo="none"
>END</literal> block in our
	  Perl configuration file, then all this would get done
	  automatically, but that would not make a good example.
	</para></footnote>.
      This would be the Perl side of it: 
      <programlisting
format="linespecific"
>package Hermes;
    sub atexit {
    # Close any open file handles
    ...
    # 
    print "Thank you for using Hermes/Perl. Going away now.\n";
}</programlisting></para><para
>      And here would be the C side:
<programlistingco
><areaspec
><area
coords="2"
id="embed.perlstop.1"
></area><area
coords="3"
id="embed.perlstop.2"
></area><area
coords="5"
id="embed.perlstop.3"
></area><area
coords="6"
id="embed.perlstop.4"
></area><areaset
coords=""
id="embed.perlstop.5"
><area
coords="8"
id="embed.dummy.1"
></area><area
coords="9"
id="embed.dummy.2"
></area></areaset></areaspec><programlisting
format="linespecific"
>/* Clean up Perl embedding */
void perl_stop(void) {
    dSP;

    PUSHMARK(SP);
    call_pv("Hermes::atexit", G_DISCARD | G_NOARGS);

    perl_destruct(my_perl);
    perl_free(my_perl);
}</programlisting><calloutlist
><callout
arearefs="embed.perlstop.1"
><para
>	      This function will be used before the mailer exits to
	      shut down all elements of the Perl embedding - we'll
	      call our exit handler routine
	      <function
moreinfo="none"
>Hermes::atexit</function>, and then close down
	      the Perl interpreter. It's a good idea when you're
	      embedding to keep the number of function which interact
	      with the Perl interpreter to a minimum, and if possible,
	      in their own separate file. Hence, we have a wrapper
	      function which can be called anywhere in our mailer
	      to shut down the Perl embedding.
	    </para></callout><callout
arearefs="embed.perlstop.2"
><para
>	      As in <xref
linkend="advxs.cb.imm"
></xref>,
	      <literal
moreinfo="none"
>dSP</literal> provides local access to Perl's
	      argument stack.
	    </para></callout><callout
arearefs="embed.perlstop.3"
><para
>	      <literal
moreinfo="none"
>PUSHMARK</literal> pushes a "bookmark" onto the
	      argument stack. In our example in Advanced XS, we used
	      quite a complicated prologue to calling the callback,
	      using
	      <literal
moreinfo="none"
>ENTER</literal>/<literal
moreinfo="none"
>SAVETMPS</literal>/<literal
moreinfo="none"
>PUSHMARK</literal>
	      and
	      <literal
moreinfo="none"
>PUTBACK</literal>/<literal
moreinfo="none"
>FREETMPS</literal>/<literal
moreinfo="none"
>LEAVE</literal>,
	      but as we are not concerned about parameters and return
	      values here, we can do without most of these. However,
	      we must still push a bookmark.
	    </para><para
>	      This is because the argument stack is not always empty;
	      if we're already inside a Perl expression, the stack
	      will certainly not be empty. However, when a callback
	      receives parameters or returns values, it needs to know
	      how many items from the top of the stack "belong" to
	      it. For instance, there may already be four items on the
	      stack before we call
	      <literal
moreinfo="none"
>Hermes::atexit</literal>. Let's suppose we want
	      to push another two items on as parameters. Perl needs
	      some way of knowing that the four items previously on
	      the stack are no concern of <literal
moreinfo="none"
>atexit</literal>,
	      and so it pushes a bookmark to denote the bottom of the
	      'local' stack.
	    </para></callout><callout
arearefs="embed.perlstop.4"
><para
>	      Now we call the routine. <function
moreinfo="none"
>call_pv</function>
	      and <function
moreinfo="none"
>call_sv</function> take two parameters:
	      the name or SV for the subroutine to be called, and a
	      set of flags. In this instance, our flags are
	      <literal
moreinfo="none"
>G_DISCARD</literal>, signifying that we're
	      going to discard the output of the call, (and therefore
	      that <literal
moreinfo="none"
>Hermes::atexit</literal> should be called
	      in void context) and <literal
moreinfo="none"
>G_NOARGS</literal> to
	      state that we're not pushing in any arguments, so the
	      subroutine doesn't need to look at the stack.
	    </para></callout><callout
arearefs="embed.perlstop.5"
><para
>	      Now we've called the routine, we can shut down the
	      interpreter and free the memory it used in preparation
	      for exiting the program.
	    </para></callout></calloutlist></programlistingco>
    </para><sect2
><title
>Stack Manipulation</title><para
>	So much for the easy case. Unfortunately, in most other
	examples, we have both parameters and return values to deal with.
      </para><para
>	First, parameters. We already know the basics of this from
	<xref
linkend="advxs.cstruct.retlist"
></xref>; we're going to use
	<literal
moreinfo="none"
>PUSHs</literal> to put things on the stack. So that
	the values that we put on the stack are properly garbage
	collected, we need to make them temporary, to tell Perl that
	they should go away at the end of the scope. This means we
	have to declare a scope, and this is where the
	<literal
moreinfo="none"
>ENTER</literal>/<literal
moreinfo="none"
>SAVETMPS</literal>/<literal
moreinfo="none"
>PUSHMARK</literal>
	business comes in.
      </para><para
>	Let's take another example from our mythical mailer, and pass
	a mail message to a Perl function for pre-processing. The
	message will come in as an array of strings, so we need to
	make them all into temporary SVs before pushing them onto the
	stack.
      </para><programlistingco
><areaspec
><area
coords="2"
id="embed.pp1.1"
></area><areaset
coords=""
id="embed.pp1.2"
><area
coords="5"
id="foo.dummy.5"
></area><area
coords="6"
id="foo.dummy.6"
></area></areaset><area
coords="7"
id="embed.pp1.3"
></area><areaset
coords=""
id="embed.pp1.4"
><area
coords="9"
id="foo.dummy.7"
></area><area
coords="10"
id="foo.dummy.8"
></area></areaset><area
coords="12"
id="embed.pp1.5"
></area><area
coords="14"
id="embed.pp1.6"
></area><areaset
coords=""
id="embed.pp1.7"
><area
coords="9"
id="foo.dummy.9"
></area><area
coords="10"
id="foo.dummy.10"
></area></areaset></areaspec><programlisting
format="linespecific"
>void preprocess_callout(char** message) {
     dSP;
     int i;

     ENTER;
     SAVETMPS;
     PUSHMARK(SP);

     for (i=0; i++; message[i])
          XPUSHs(sv_2mortal(newSVpv(message[i], 0)));

     PUTBACK;

     call_pv("Hermes::preprocess", G_DISCARD);

     FREETMPS;
     LEAVE;

}</programlisting><calloutlist
><callout
arearefs="embed.pp1.1"
><para
>	      As before, we need a copy of the stack pointer so we
	      know where things are going.
	    </para></callout><callout
arearefs="embed.pp1.2"
><para
>	      We start by opening a new scope with
	      <literal
moreinfo="none"
>ENTER</literal> and setting out a new set of
	      temporaries for collection with <literal
moreinfo="none"
>SAVETMPS</literal>.
	    </para></callout><callout
arearefs="embed.pp1.3"
><para
>	      Again, we push a bookmark to declare the local
	      bottom of the stack.
	    </para></callout><callout
arearefs="embed.pp1.4"
><para
>	      Now we iterate over the array, creating new SVs for each
	      of the lines of the message, (see <xref
linkend="api.newsvpv"
></xref>) making them temporary with
	      <function
moreinfo="none"
>sv_2mortal</function> and then pushing them
	      onto the stack. If we happened to know how many lines we
	      had in advance, we could use
	      <function
moreinfo="none"
>EXTEND(n)</function> to pre-extend the stack
	      and then use <function
moreinfo="none"
>PUSHs</function> instead of
	      <function
moreinfo="none"
>XPUSHs</function>, but this way keeps things simple.
	    </para></callout><callout
arearefs="embed.pp1.5"
><para
>	      <literal
moreinfo="none"
>PUTBACK</literal> sets Perl's copy of the stack
	      pointer equal to the <literal
moreinfo="none"
>SP</literal> we have -
	      since we've put things on the stack, out
	      <literal
moreinfo="none"
>SP</literal> will have grown, but our changes
	      to the local variable need to be reflected in the global
	      stack pointer.
	    </para></callout><callout
arearefs="embed.pp1.6"
><para
>	      Now we can call the function; this time we have some
	      arguments, so we don't use <literal
moreinfo="none"
>G_NOARGS</literal>,
	      but we're still discarding the return value.
	    </para></callout><callout
arearefs="embed.pp1.7"
><para
>	      Finally, we clean up the temporaries we created and
	      close the scope.
	    </para></callout></calloutlist></programlistingco><para
>	Now, it's not much good preprocessing a message if you don't
	get the message back after preprocessing it, so we have to
	deal with return values. Once again, we're making use of the
	same principles we saw in respect to XS callbacks. We can
	modify our example slightly:
      </para><programlistingco
><areaspec
><area
coords="16"
id="embed.pp2.1"
></area><area
coords="18"
id="embed.pp2.2"
></area><area
coords="24"
id="embed.pp2.3"
></area></areaspec><programlisting
format="linespecific"
>char** preprocess_callout(char** message) {
     dSP;
     int i;
     int count;
     char **newmessage;

     ENTER;
     SAVETMPS;
     PUSHMARK(SP);

     for (i=0; i++; message[i])
          XPUSHs(sv_2mortal(newSVpv(message[i], 0)));

     PUTBACK;

     count = call_pv("Hermes::preprocess", G_ARRAY);

     SPAGAIN;

     newmessage = malloc(count * sizeof(char*));
     i = count;

     while (i &gt; 0)
         newmessage[--i] = savepv(SvPV_nolen(POPs));
      
     FREETMPS;
     LEAVE;

     return newmessage;
}</programlisting><calloutlist
><callout
arearefs="embed.pp2.1"
><para
>	      This time we use <literal
moreinfo="none"
>G_ARRAY</literal> to specify
	      that we're calling the function in array context, and
	      <function
moreinfo="none"
>call_pv</function> returns the number of
	      values returned by the subroutine.
	    </para></callout><callout
arearefs="embed.pp2.2"
><para
>	      Because the subroutine will have put some more values on
	      the stack, we need to refresh our local copy of the
	      stack pointer - this is what <literal
moreinfo="none"
>SPAGAIN</literal>
	      does. Again, this is the same as we saw in <xref
linkend="advxs.cb.imm"
></xref>.
	    </para></callout><callout
arearefs="embed.pp2.3"
><para
>	      The way we fetch the values is slightly tricky. First,
	      we have to remember that the values come off the stack
	      in reverse order, so we put the first value to be popped
	      at the end of the array. Second, we need to remember
	      that the values on the stack are temporaries, and will
	      be swept away at the <literal
moreinfo="none"
>FREETMPS</literal>. Since
	      we don't want to end up with an array of null pointers,
	      we make a copy of each string with
	      <function
moreinfo="none"
>savepv</function>.
	    </para><para
>	      We also need to remember that arrays are zero-based, so
	      if <varname
>count</varname> = 2, we should store the
	      first value in <varname
>newmessage[1]</varname>. This is
	      why we say <varname
>newmessage[--i]</varname>.
	    </para></callout></calloutlist></programlistingco></sect2><sect2
><title
>Context</title><para
>	We've seen that the <literal
moreinfo="none"
>G_</literal>... flags can be used
	to affect the context of a call. For instance, we can force
	scalar context on a list function by passing the
	<function
moreinfo="none"
>G_SCALAR</function> flag. The
	<filename
moreinfo="none"
>perlcall</filename> documentation has a
	comprehensively list of what all the flag values do and how
	they affect the context of your call.
      </para></sect2><sect2
><title
>Trapping errors with <literal
moreinfo="none"
>eval</literal></title><para
>	One thing you may have noticed is that if there is a fatal
	error generated by the Perl subroutine, then the entire
	process gets shut down. This is probably something you want to
	guard against in embedded situations, so there is another
	<literal
moreinfo="none"
>G_</literal>... flag you ought to be aware of.
      </para><para
>	<literal
moreinfo="none"
>G_EVAL</literal> is the equivalent of wrapping the
	code to be executed in an <literal
moreinfo="none"
>eval { ... } </literal>
	block. Let's modify our example again to make sure it doesn't
	die on us.
      </para><programlistingco
><areaspec
><area
coords="16"
id="embed.pp3.1"
></area><area
coords="20"
id="embed.pp3.2"
></area><area
coords="21"
id="embed.pp3.3"
></area></areaspec><programlisting
format="linespecific"
>char** preprocess_callout(char** message) {
     dSP;
     int i;
     int count;
     char **newmessage;

     ENTER;
     SAVETMPS;
     PUSHMARK(SP);

     for (i=0; i++; message[i])
          XPUSHs(sv_2mortal(newSVpv(message[i], 0)));

     PUTBACK;

     count = call_pv("Hermes::preprocess", G_ARRAY | G_EVAL);

     SPAGAIN;

     if (SvTRUE(ERRSV)) {
         display_message("An error occurred in the Perl preprocessor: %s",
           SvPV_nolen(ERRSV)); 
         return message; /* Go with the original */
     }

     newmessage = malloc(count * sizeof(char*));
     i = count;

     while (i &gt; 0)
         newmessage[--i] = savepv(SvPV_nolen(POPs));
      
     FREETMPS;
     LEAVE;

     return newmessage;
}</programlisting><calloutlist
><callout
arearefs="embed.pp3.1"
><para
>	      Adding the <literal
moreinfo="none"
>G_EVAL</literal> flag is all we need
	      to do to protect ourselves from a <literal
moreinfo="none"
>die</literal>
	      in the Perl code.
	    </para></callout><callout
arearefs="embed.pp3.2"
><para
>	      Once we've called the subroutine and restored the stack
	      to normality, we check to see whether or not the error
	      SV (<varname
>$@</varname>) has a true value.
	    </para></callout><callout
arearefs="embed.pp3.3"
><para
>	      Assuming we have a function for displaying formatted
	      messages, we spit out the text of the error message, and
	      return the original array unmodified.
	    </para></callout></calloutlist></programlistingco></sect2><sect2
><title
>Calling Perl methods in C</title><para
>	As we know, there are two types of method - an object method
	and a class method. These are both called using the
	<function
moreinfo="none"
>call_method</function> function from C code; the
	trick here is that the object (in the case of an object
	method) or an SV representing the class name (in the case of a
	class method) must be placed on the stack before any
	parameters. Here's an example of calling an object method from C:
      </para><programlisting
format="linespecific"
>
    PUSHMARK(sp);
    XPUSHs(object);
    XPUSHs(param);
    PUTBACK;

    call_method("display", G_DISCARD);
</programlisting></sect2><sect2
><title
>Calling Perl statements</title><para
>	But isn't this a lot of work? There ought to be a much easier
	way of running Perl code from C. Thankfully, Perl provides
	functions called <function
moreinfo="none"
>eval_pv</function> and
	<function
moreinfo="none"
>eval_sv</function>, which are essentially the
	equivalent of <literal
moreinfo="none"
> eval "..."</literal>. As with
	<literal
moreinfo="none"
>eval</literal>, we can do anything that we can
	normally do in a Perl program, including loading other
	modules.
      </para><para
>	For instance, we can use Perl to nicely format a C string,
	using the <literal
moreinfo="none"
>Text::Autoformat</literal> module:
	<programlisting
format="linespecific"
>char* tidy_string (char* input) {
    SV* result;

    setSVpv(PL_defsv, input, 0);
    result = eval_pv("use Text::Autoformat; autoformat($_)", FALSE);
    if (SvTRUE(ERRSV)) 
        return NULL;
    else
        return SvPV_nolen(result);
}</programlisting>
      </para><para
>	Notice that we stored the input string in
	<varname
>$_</varname>, (<varname
>PL_defsv</varname>) and that
	the second argument to <function
moreinfo="none"
>eval_pv</function> and
	<function
moreinfo="none"
>eval_sv</function> is a boolean denoting the
	behaviour on error - if this is <literal
moreinfo="none"
>TRUE</literal>, then
	the process will exit if the Perl code <literal
moreinfo="none"
>die</literal>s.
      </para><para
>	In many cases, <function
moreinfo="none"
>eval_sv</function> and
	<function
moreinfo="none"
>eval_pv</function> are all you need to get a lot out
	of embedding Perl in your application. The
	<filename
moreinfo="none"
>perlembed</filename> man page contains a very good
	example of making use of Perl's regular expression functions
	from C using these functions.
      </para></sect2></sect1><sect1
><title
>Using C in Perl in C</title><para
>      In many cases when embedding Perl in C, you're providing the
      user with an alternative way of scripting the program's
      behaviour. Because of this, you often want to provide a way for
      the user's Perl to perform actions back in the original C
      program. For instance, the <literal
moreinfo="none"
>mod_perl</literal> Apache
      module allows Perl programs to control incoming HTTP requests;
      this involves such things as finding out information about the
      request and sending a HTTP response back via the Apache server
      to the remote client. These things can't be done from Perl, and
      have to be implemented as calls to C functions inside
      Apache. That's to say, as well as an embedding framework, we
      also need some XS modules to expose the C API of our programs
      back to the Perl scripts.
    </para><para
>      Let's assume that we've written an XS module to do this. If we
      then try the obvious solution:
      <programlisting
format="linespecific"
>	eval_pv("use Hermes;", TRUE);
      </programlisting>
      then this happens:
      <screen
format="linespecific"
>	<computeroutput
moreinfo="none"
>Can't load module Hermes, dynamic loading not available in this perl.
(You may need to build a new perl executable which either supports
dynamic loading or has the Hermes module statically linked into it.)</computeroutput></screen>
    </para><para
>      The very basic Perl interpreter that we created does not have
      support for dynamic loading of XS modules<footnote
><para
>	  This is, in fact, the exact difference between
	  <filename
moreinfo="none"
>miniperlmain.c</filename>, from which we took our
	  first example, and <filename
moreinfo="none"
>perlmain.c</filename>, which is
	  the main file used in building an ordinary <filename
moreinfo="none"
>perl</filename>.
	</para></footnote>
. 
    </para><para
>      Adding this support is easy, especially since
      <classname
>ExtUtils::Embed</classname> can help us out again.
    </para><sect2
><title
>Callbacks and data</title><para
></para></sect2></sect1><sect1
><title
>Using multiple interpreters</title><para
></para></sect1></chapter><chapter
><title
>Embedding Case Study</title><para
>    As we mentioned in the previous chapter, we're now going to apply
    what we've learnt about embedding Perl to a real application. For
    our case study, we're going to use the <command
moreinfo="none"
>mutt</command>
    mail client, a relatively commonly-used Unix mail reader.
  </para><para
>    The case study is going to be a no-holds-barred look at the
    process of embedding Perl into an existing application, including
    some of the problems we faced and how we worked around them.
  </para><sect1
><title
>Goals</title><para
>      First, though, let's look at what we're trying to
      achieve. Primarily, we want to give Perl control over the
      configuration of <command
moreinfo="none"
>mutt</command> - we want to rip out
      the <filename
moreinfo="none"
>muttrc</filename> configuration file parsing and
      options checking code, and replace it with Perl
      equivalents. This will allow a Perl configuration file to be
      used by <command
moreinfo="none"
>mutt</command> users.
    </para><para
>      For our example, we're not going to completely rewrite
      <command
moreinfo="none"
>mutt</command>'s option parsing - we'll deal with the
      easiest set of options, and leave alone the hooks, address
      books, custom headers, aliases and so on. In true textbook
      style, these can be considered an exercise for the reader.
    </para></sect1><sect1
><title
>Preparing the ground</title><para
>      We start, fairly obviously, by getting a copy of the
      <command
moreinfo="none"
>mutt</command> sources to work from; at the time of
      writing, the current development development version was 1.3.24,
      which we downloaded from <ulink
url="ftp://ftp.mutt.org/pub/mutt/mutt-1.3.24i.tar.gz"
>the Mutt
      FTP site</ulink>.
    </para><para
>      After unpacking a pristine copy of the sources, we make another
      copy called <filename
moreinfo="none"
>mutt-1.3.24i-perl</filename>, for our
      working environment.
    </para><para
>      The first thing for us to look at is how we're going to get Perl
      compiled into the eventual binary, and this means modifying the
      configuration and Makefile. <command
moreinfo="none"
>mutt</command> uses the
      <emphasis
>de facto</emphasis> standard <ulink
url="http://www.gnu.org/software/autoconf/"
><command
moreinfo="none"
>autoconf</command>
      system.</ulink> We'll make Perl support a configure-time option
      which defines the <literal
moreinfo="none"
>USE_PERL</literal> macro.
    </para><para
>      The way we do this with <command
moreinfo="none"
>autoconf</command> is to declare
      the macro in <filename
moreinfo="none"
>acconfig.h</filename> like so:
      <programlisting
format="linespecific"
> #undef USE_SASL

+/* Do you want to use Perl for config file parsing? (--with-perl) */
+#undef USE_PERL
+
 /* Do you want support for IMAP GSSAPI authentication? (--with-gss) */
 #undef USE_GSS</programlisting>
      and then also add an option in
      <filename
moreinfo="none"
>configure.in</filename>. We copy some of the code for
      linking in the SASL authentication library, since it also needs
      to define a macro and add libraries to the build path. As in the
      previous chapter, we use <classname
>ExtUtils::Embed</classname>
      as a handy, portable way of determining the compile and link
      options:
      <programlisting
format="linespecific"
>+dnl Perl config file support
+AC_ARG_WITH(perl, [  --with-perl            Perl support for .muttrc parsing],
+        [
+        if test "$with_perl" != "no"
+        then
+           CFLAGS="$CFLAGS `perl -MExtUtils::Embed -e ccopts`"
+           LDFLAGS="$LDFLAGS `perl -MExtUtils::Embed -e ldopts`"
+          AC_DEFINE(USE_PERL)
+        fi
+        ])
+</programlisting>
(<literal
moreinfo="none"
>AC_DEFINE</literal> means "#define this macro") 
    </para><para
>      Notice that since <filename
moreinfo="none"
>configure</filename>, the file
      generated from <filename
moreinfo="none"
>configure.in</filename>, is a shell
      script, the backticks are performed when
      <filename
moreinfo="none"
>configure</filename> is run, and so the options are
      determined when the <filename
moreinfo="none"
>Makefile</filename> is built.
    </para><para
>      Next, we rerun <command
moreinfo="none"
>autoconf</command> to regenerate the
      <filename
moreinfo="none"
>configure</filename> command. Testing this both with
      and without the new <literal
moreinfo="none"
>--use-perl</literal> option, we can
      make sure that <command
moreinfo="none"
>mutt</command> still compiles.
    </para><para
>      For completeness, we notice that, like <command
moreinfo="none"
>perl</command>,
      <command
moreinfo="none"
>mutt</command> will show all of its configuration
      options when given the appropriate command-line
      argument. So, we make the following change to
      <filename
moreinfo="none"
>main.c</filename>'s <function
moreinfo="none"
>show_version</function>
      function:
      <programlisting
format="linespecific"
> #ifdef DL_STANDALONE
     "+DL_STANDALONE  "
 #else
     "-DL_STANDALONE  "
 #endif

+#ifdef USE_PERL
+    "+USE_PERL  "
+#else
+    "-USE_PERL  "
+#endif</programlisting>
    </para></sect1><sect1
><title
>Configuration Options</title><para
>      Now we can move on to thinking about how we're going to replace
      the configuration file parsing. <command
moreinfo="none"
>mutt</command> has
      several different kinds of options: binary options, string
      options, and quad-state options. After examining the sources, we
      find that these options are parsed in
      <filename
moreinfo="none"
>init.c</filename>, with the main function being
      <function
moreinfo="none"
>source_rc</function>. As we're going to provide our
      own facility for parsing <command
moreinfo="none"
>mutt</command> RC files, we
      can conditionalize these functions on <literal
moreinfo="none"
>#ifndef
      USE_PERL</literal>.
    </para><para
>      The initial idea was to keep everything inside
      <filename
moreinfo="none"
>init.c</filename>, and simply provide two versions of
      <function
moreinfo="none"
>source_rc</function> - one for the Perl-based parsing,
      and one for the ordinary parsing. However, this turned out to be
      problematic - some of the things defined in the
      <command
moreinfo="none"
>mutt</command> header files conflicted with Perl's
      header files, and it would be very messy to extricate it
      all.
    </para><para
>      So we decided to follow our own advice from the previous
      chapter, and put all the embedding functionality in a single
      file, <filename
moreinfo="none"
>perl.c</filename>. This would need another
      change to the Makefile, which would have to be specified in
      <filename
moreinfo="none"
>configure.in</filename>. This time, we need to add to
      the substituted variable <literal
moreinfo="none"
>MUTT_LIB_OBJECTS</literal>. So
      we edit <filename
moreinfo="none"
>configure.in</filename> again:
      <programlisting
format="linespecific"
>           LDFLAGS="$LDFLAGS `perl -MExtUtils::Embed -e ldopts`"
+          MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS perl.o"
           AC_DEFINE(USE_PERL)</programlisting>
    </para><para
>      And now we're all set up to use <filename
moreinfo="none"
>perl.c</filename>;
      this gives us the added advantage that we can make our Perl
      interpreter static to this file. We can now write our
      replacement for <function
moreinfo="none"
>source_rc</function>, parsing the
      config file using Perl. Here's what our initial cut of
      <filename
moreinfo="none"
>perl.c</filename> looks like.
    </para><programlisting
format="linespecific"
>#include "config.h"

#define REGEXP mutt_REGEXP
#include "mutt.h"
#undef REGEXP /* Don't want mutt's version of this */

#include &lt;EXTERN.h&gt;
#include &lt;perl.h&gt;

static PerlInterpreter *my_perl;

int source_rc (const char *rcfile, BUFFER *err)
{
  FILE *f;
  pid_t pid;
  struct stat file_stat;
  size_t rc_size;
  char* rc;

  if (stat(rcfile, &amp;file_stat) || ((f = mutt_open_read (rcfile, &amp;pid))
	== NULL))
  {
    snprintf (err-&gt;data, err-&gt;dsize, "%s: %s", rcfile, strerror
	(errno));
    return (-1);
  }

  if (!my_perl)
  {
    char *embedding[] = { "", "-e", "0" };
    my_perl = perl_alloc();
    perl_construct(my_perl);
    perl_parse(my_perl, NULL, 3, embedding, NULL);
    perl_run(my_perl);
    /* OK, we now have a Perl up and running */
  }

  rc_size = file_stat.st_size;
  rc = malloc(rc_size);
  read(f, rc, rc_size);

  if (!rc)
  {
    snprintf (err-&gt;data, err-&gt;dsize, "%s: %s", rcfile, strerror
	(errno));
    return (-1);
  }

  eval_pv(rc, FALSE);
  if (SvTRUE(ERRSV))
  {
    snprintf (err-&gt;data, err-&gt;dsize, "%s: %s", rcfile, SvPV_nolen(ERRSV));
    return (-1);
  }
}</programlisting><para
>      The bulk of this is taken from the original
      <function
moreinfo="none"
>source_rc</function>; notice that we've even kept the
      original code's brace and indentation style, a suprisingly
      important point when contributing to third-party projects.
    </para><para
>      The beginning few lines are necessary for the definition of
      <literal
moreinfo="none"
>BUFFER</literal>. We protect <literal
moreinfo="none"
>REGEXP</literal>
      by substituting it for <literal
moreinfo="none"
>mutt_REGEXP</literal> while the
      original header files do their thing, then removing the
      substitution once they're finished. Then come the familiar
      set-up lines for an embedded application - the Perl header files
      and our interpreter.
    </para><para
>      After testing that we can open the rc file comes the good stuff:
      we read the contents of the file into memory, and evaluate it as
      a Perl string. This means that a Perl
      <filename
moreinfo="none"
>.muttrc</filename> of the form:
      <programlisting
format="linespecific"
>package Mutt;
our $folder = "/home/simon/mail/";
our $copy = 1;
...</programlisting>
      will set the appropriate variables. Of course, if there's an
      error, we need to tell the user about it.
    </para><para
>      Notice that we don't simple pass the RC file name to Perl on our
      faked command line, because it's possible that we could be
      sourcing more than one RC file. That's also why we test whether
      or not we've already got a Perl interpreter instantiated before
      creating one.
    </para><para
>      Since we've removed the <function
moreinfo="none"
>source_rc</function> function
      from the file it gets called from, we've got to add a prototype
      into one of the header files to keep the compiler
      satisfied. We'll add something to <filename
moreinfo="none"
>mutt.h</filename>:
      <programlisting
format="linespecific"
>#ifdef USE_PERL
int source_rc (const char *rcfile, BUFFER *err);
#endif</programlisting>
    </para><para
>      Now our program won't do very much, but it should still compile,
      and run the user's <filename
moreinfo="none"
>.muttrc</filename>s as Perl
      programs. However, we don't tidy up the Perl interpreter on
      exit; let's do that by adding a hook to
      <command
moreinfo="none"
>mutt</command>'s <function
moreinfo="none"
>mutt_exit</function> in
      <filename
moreinfo="none"
>main.c</filename>:
      <programlisting
format="linespecific"
> void mutt_exit (int code)
 {
   mutt_endwin (NULL);
+#ifdef USE_PERL
+  perl_stop();
+#endif
   exit (code);
 }</programlisting>
      Once again, this requires a prototype in
      <filename
moreinfo="none"
>mutt.h</filename>. Our <function
moreinfo="none"
>perl_stop</function>
      destructor is simply:
      <programlisting
format="linespecific"
> void perl_stop(void) 
 {
   perl_destruct(my_perl);
   perl_free(my_perl);
 }</programlisting>
    </para></sect1><sect1
><title
>Testing options</title><para
>      That takes care we need to replace the functions which
      actually set and test the options. We'll begin with the binary
      options, because these are the easiest to deal with. </para><para
>      <command
moreinfo="none"
>mutt</command> uses four macros to get and
      set binary options:
      <programlisting
format="linespecific"
>#define set_option(x) mutt_bit_set(Options,x)
#define unset_option(x) mutt_bit_unset(Options,x)
#define toggle_option(x) mutt_bit_toggle(Options,x)
#define option(x) mutt_bit_isset(Options,x)</programlisting>
      We're going to use a similar trick to our previous section, and
      conditionally replace these with functions in
      <filename
moreinfo="none"
>perl.c</filename>. We can fold all the conditional
      things together, and end up with something like this:
      <programlisting
format="linespecific"
>#ifdef USE_PERL
void perl_set_option(int x);
void perl_unset_option(int x);
void perl_toggle_option(int x);
int perl_option(int x);

int source_rc (const char *rcfile, BUFFER *err);

#define set_option(x) perl_set_option(x)
#define unset_option(x) perl_unset_option(x)
#define toggle_option(x) perl_toggle_option(x)
#define option(x) perl_option(x)
#else
#define set_option(x) mutt_bit_set(Options,x)
#define unset_option(x) mutt_bit_unset(Options,x)
#define toggle_option(x) mutt_bit_toggle(Options,x)
#define option(x) mutt_bit_isset(Options,x)
#endif</programlisting>
    </para><para
>      Now we need to define these functions in
      <filename
moreinfo="none"
>perl.c</filename> and this is where things get
      tricky. This is because the <literal
moreinfo="none"
>option</literal> macros do
      not get passed the name of the option, but an integer enumerator
      for the option; this is keyed to the actual option by the
      <varname
>MuttVars</varname> structure in
      <filename
moreinfo="none"
>init.h</filename>. The
      <function
moreinfo="none"
>mutt_option_index</function> allows us to go from an
      option name to an enumerator, but we need the opposite. Let's
      use <function
moreinfo="none"
>mutt_option_index</function> as a template, and
      write us a function to get the name of a boolean value:
      <programlisting
format="linespecific"
>const char* mutt_option_name_bool(int o) {
  int i;

  for (i = 0; MuttVars[i].option; i++)
    if (MuttVars[i].type == DT_BOOL &amp;&amp; MuttVars[i].data = o)
      return MuttVars[i].option;

  return NULL;
}</programlisting>

      Since <varname
>MuttVars</varname> is declared in the header file
      for <filename
moreinfo="none"
>init.c</filename>, our
      <function
moreinfo="none"
>mutt_option_name_bool</function> function needs to go
      in there as well. Now we can think about our functions to get
      options:
      <programlisting
format="linespecific"
>int perl_option(int o) {
  char* optname = mutt_option_name_bool(o);
  char* varname;
  int   rv;

  if (!optname) /* unknown option */
    return 0;

  varname = malloc(strlen(optname) + 7);
  sprintf(varname, "Mutt::%s", optname); 
  rv = SvTRUE(get_sv(varname, TRUE));
  free(varname);
  
  return rv;
}</programlisting></para><para
>      We form our Perl variable name by adding
      <literal
moreinfo="none"
>Mutt::</literal> to the front of the option name we
      derived from the previous step; then we use
      <function
moreinfo="none"
>get_sv</function> to get the Perl-side variable, and
      <function
moreinfo="none"
>SvTRUE</function> to test its boolean value. The set
      functions can be implemented in a similar manner.
    </para><para
>      With that under our belt, we can turn to
      <command
moreinfo="none"
>mutt</command>'s quad-state options: quad-state options
      can be either "yes", "no", "ask but yes" and "ask but no". These
      are handled by a similar method of enumerated constants, this
      time with the <literal
moreinfo="none"
>OPT_</literal> prefix. We need to
      redefine the <function
moreinfo="none"
>quadoption</function>,
      <function
moreinfo="none"
>set_quadoption</function> and
      <function
moreinfo="none"
>toggle_quadoption</function> functions from
      <filename
moreinfo="none"
>init.c</filename>. We start once again by going from
      the enumeration to the Perl variable name:
    </para><programlisting
format="linespecific"
>const char* mutt_option_name_quad(int o) {
  int i;

  for (i = 0; MuttVars[i].option; i++)
    if (MuttVars[i].type == DT_QUAD &amp;&amp; MuttVars[i].data = o)
      return MuttVars[i].option;

  return NULL;
}</programlisting><para
>      And now we create a <function
moreinfo="none"
>perl_quadoption</function>,
      <function
moreinfo="none"
>perl_set_quadoption</function> and
      <function
moreinfo="none"
>perl_toggle_quadoption</function> in <filename
moreinfo="none"
>perl.c:
    </filename></para><programlisting
format="linespecific"
>int perl_quadoption(int o) {
  char* optname = mutt_option_name_quad(o);
  char* varname;
  SV* option;

  if (!optname) /* unknown option */
    return 0;

  varname = malloc(strlen(optname) + 7);
  sprintf(varname, "Mutt::%s", optname); 
  option = get_sv(varname, TRUE);
  free(varname);
  if (strEQ(SvPV_nolen(option), "no")) 
    return 0;
  else if (strEQ(SvPV_nolen(option), "yes")) 
    return 1;
  else if (strEQ(SvPV_nolen(option), "ask-no")) 
    return 2;
  else if (strEQ(SvPV_nolen(option), "ask-yes")) 
    return 3;
  else /* invalid value */
    return 0;
}</programlisting><para
>      Finally, we turn to string options, the most difficult of
      all. These are a pain because they're keyed slightly differently
      from the other options. For instance, when the RC file parser
      comes across <literal
moreinfo="none"
>attach_format</literal>, it looks it up in
      the <varname
>MuttVars</varname> structure and finds that it is
      attached to the global variable
      <varname
>AttachFormat</varname>. Other parts of the code use
      this variable directly.
    </para><para
>      This is one of the points in embedding where we just have to get
      our hands dirty, and rip up the existing code. We replace every
      occurrence of string option variables with a function - hence
      <varname
>AttachFormat</varname> now appears as
      <literal
moreinfo="none"
>mutt_string_option("attach_format")</literal>. The function
      has two definitions - one in <filename
moreinfo="none"
>init.c</filename> like
      this:
      <programlisting
format="linespecific"
>char* mutt_string_option(char* o) {
  int i;

  for (i = 0; MuttVars[i].option; i++)
    if (mutt_strcmp (o, MuttVars[i].option) == 0)
      return *(MuttVars[i].data);

  return NULL;
}</programlisting>
      and the one in <filename
moreinfo="none"
>perl.c</filename> like this:
      <programlisting
format="linespecific"
>char* string_option(char* o) {
  char * rv;
  char * varname = malloc(strlen(o) + 7);

  sprintf(varname, "Mutt::%s", o); 
  rv = SvPV_nolen(get_sv(varname, TRUE));
  free(varname);
  return rv;
}   </programlisting>
    </para><para
>      And after all that, <command
moreinfo="none"
>mutt</command> should be able to
      read configuration files in Perl!
    </para></sect1><sect1
><title
>Where to from here?</title><para
>      We've seen simple example of what it means to embed Perl into a
      real application, as well as some of the problems that we come
      across and how we've faced them. In most cases, it's
      surprisingly easy to add Perl support; unfortunately, there'll
      always be some cases where there's no option but to restructure
      the code of the host application.
    </para><para
>      If you are lucky, the application will be designed with
      embedding in mind - Apache's module support made it very easy to
      embed Perl without disturbing too much of the code around it. In
      our example, we really had to start from scratch, planning how
      we were going to get Perl into the application and the interface
      we would provide for it. Notice, however, that we kept the
      embedding completely optional, switchable by a single
      configuration option. Aim to do this if possible, as it further
      minimizes the effect of your changes on the rest of the code base.
    </para><para
>      There's a lot more we could have done with
      <command
moreinfo="none"
>mutt</command> - for instance, we could have turned
      <command
moreinfo="none"
>mutt</command>'s built-in hook mechanism into a
      callback mechanism to call Perl subroutines. We could have dealt
      with the list-based options, using Perl arrays to hold multiple
      values. And finally we could have tidied up our interface, using
      Perl hashes to store the <varname
>MuttVars</varname> options
      structure, eliminating some of the lookups. But hopefully we've
      given you a taste of how to approach the topic of embedding Perl
      in an existing application.
    </para></sect1></chapter><chapter
id="internals"
><title
>Introduction to Perl Internals</title><sect1
id="internals.sourcetree"
><title
>The Source Tree</title><para
>        This section introduces you to the major parts of the Perl
        source tree that you should familiarise yourself with.
    </para><sect2
><title
>The Perl Library</title><para
>      The most approachable part of the source code, for Perl
      programmers, is the Perl library. This lives in
      <filename
moreinfo="none"
>lib/</filename>, and comprises all the standard, pure
      Perl modules and pragmata that ship with
      <filename
moreinfo="none"
>perl</filename>.
    </para><para
>      There are both Perl 5 modules and unmaintained Perl 4 libraries,
      shipped for backwards compatibility. In Perl 5.6.0 and above,
      the Unicode tables are placed in
      <filename
moreinfo="none"
>lib/unicode</filename>.
    </para></sect2><sect2
><title
>The XS Library</title><para
>      In <filename
moreinfo="none"
>ext/</filename>, we find the XS modules which ship
      with Perl. For instance, the Perl compiler <classname
>B</classname> 
      can be found here,
      as can the DBM interfaces. The most important XS module here is
      <classname
>DynaLoader</classname>, the dynamic loading interface
      which allows the runtime loading of every other XS module.
    </para><para
>      As a special exception, the XS code to the methods in the
      <classname
>UNIVERSAL</classname> class can be found in <filename
moreinfo="none"
>universal.c</filename>.
    </para></sect2><sect2
><title
>The IO Subsystem</title><para
>      Recent versions of Perl come with a completely new standard IO
      implementation, <classname
>PerlIO</classname>.  This allows for
      several "layers" to be defined through which all IO is filtered,
      similar to the line disciplines mechanism in
      <classname
>sfio</classname>. These layers interact with modules
      such as <classname
>PerlIO::Scalar</classname>, also in the
      <filename
moreinfo="none"
>ext/</filename> directory.
    </para><para
>      The IO subsystem is implemented in
      <filename
moreinfo="none"
>perlio.c</filename> and
      <filename
moreinfo="none"
>perlio.h</filename>. Declarations for defining the
      layers are in <filename
moreinfo="none"
>perliol.h</filename>, and documentation
      on how to create layers is in <filename
moreinfo="none"
>pod/perliol.pod</filename>.
    </para><para
>      Perl may be compiled without <classname
>PerlIO</classname>
      support, in which case there are a number of abstraction layers
      to present a unified IO interface to the Perl
      core. <filename
moreinfo="none"
>perlsdio.h</filename> aliases ordinary standard
      IO functions to their <classname
>PerlIO</classname> names, and
      <filename
moreinfo="none"
>perlsfio.h</filename> does the same thing for the
      alternate IO library <classname
>sfio</classname>.
    </para><para
>      The other abstraction layer is the "Perl host" scheme in
      <filename
moreinfo="none"
>iperlsys.h</filename>. This is confusing. The idea is
      to reduce process overhead on Win32 systems by having multiple
      Perl interpreters access all system calls through a shared "Perl
      host" abstraction object. There is an explanation of it in
      <filename
moreinfo="none"
>perl.h</filename>, but it is best avoided.
    </para></sect2><sect2
><title
>The Regexp Engine</title><para
>      Another area of the Perl source best avoided is the regular
      expression engine. This lives in <filename
moreinfo="none"
>re*.*</filename>. The
      regular expression matching engine is, roughly speaking, a state
      machine generator. Your match pattern is turned into a state
      machine made up of various match nodes - you can see these nodes
      in <filename
moreinfo="none"
>regcomp.sym</filename>. The compilation phase is
      handled by <filename
moreinfo="none"
>regcomp.c</filename>, and the state
      machine's execution is performed in <filename
moreinfo="none"
>regexec.c</filename>.
    </para></sect2><sect2
><title
>The Parser and Tokeniser</title><para
>      The first stage in Perl's operation is to
      "understand" your program. This is done by a joint effort of the
      tokeniser and the parser. The tokeniser is found in
      <filename
moreinfo="none"
>toke.c</filename>, and the parser in
      <filename
moreinfo="none"
>perly.c</filename>. (although you're far, far better
      off looking at the YACC source in <filename
moreinfo="none"
>perly.y</filename>)
    </para><para
>      The job of the tokeniser is to split up the input into
      meaningful chunks, or <firstterm
>tokens</firstterm>, and also to
      determine what type of thing they represent - a Perl keyword, a
      variable, a subroutine name, and so on. The job of the parser is
      to take these tokens and turn them into "sentences",
      understanding their relative meaning in context.
    </para></sect2><sect2
><title
>Variable Handling</title><para
>      As we already know, Perl provides C-level implementations of
      scalars, arrays and hashes. The code for handling
      arrays is in <filename
moreinfo="none"
>av.*</filename>, hashes are in
      <filename
moreinfo="none"
>hv.*</filename> and scalars are in
      <filename
moreinfo="none"
>sv.*</filename>.
    </para></sect2><sect2
><title
>Run-time Execution</title><para
>      What about the code to Perl's built-ins -
      <literal
moreinfo="none"
>print</literal>, <literal
moreinfo="none"
>foreach</literal> and the
      like? These live in <filename
moreinfo="none"
>pp.*</filename>, and some
      of the functionality is shelled out to
      <filename
moreinfo="none"
>doio.c</filename>.
    </para><para
>      The actual main loop of the interpreter is in
      <filename
moreinfo="none"
>run.c</filename>.
    </para></sect2></sect1><sect1
id="internals.parser"
><title
>The Parser</title><para
>      Perl is a bytecode-compiled language, which means that execution
      of a Perl program happens in two stages. First of all, the
      program is read, parsed and compiled into an internal
      representation of the operations to be performed; after that,
      the interpreter takes over and traverses this internal
      representation, executing the operations in order. We'll first
      look at how Perl is parsed, before moving on to looking at the
      internal representation of a program.
    </para><para
>      As discussed above the parser lives in
      <filename
moreinfo="none"
>perly.y</filename>. This is code in a language called
      Yacc, which is converted to C using the <command
moreinfo="none"
>byacc</command>
      command.  In order to understand this language, we need to
      understand how grammars work and how parsing works.  </para><sect2
><title
>BNF and Parsing</title><para
>	Computer programmers define a language by its grammar, which
	is a set of rules. They usually describe this grammar in a
	form called "Backhaus-Naur Form"
	<footnote
><para
>Sometimes "Backhaus Normal Form"</para></footnote>
	or <firstterm
>BNF</firstterm>. BNF tells us how phrases fit
	together to make sentences. For instance, here's a simple BNF
	for English - obviously, this isn't going to describe the
	whole of the English grammar, but it's a start:

	<programlisting
format="linespecific"
>	  sentence   : nounphrase verbphrase nounphrase;

	  verbphrase : VERB;

	  nounphrase : NOUN
	  | ADJECTIVE  nounphrase
	  | PRONOMINAL nounphrase
	  | ARTICLE    nounphrase;
	</programlisting>

	Here is the prime rule of BNF: you can make the thing on the
	left of the colon if you see all the things on the right in
	sequence. So, this grammar tells us that a sentence is made up
	of a noun phrase, a verb phrase and then a noun phrase. The
	vertical bar does exactly what it does in regular expressions:
	you can make a noun phrase if you have a noun, or an adjective
	plus another noun phrase, or an article plus a noun
	phrase. Turning the things on the right into the thing on the
	left is called a <firstterm
>reduction</firstterm>. The idea of
	parsing is to reduce all of the input down to the first thing
	in the grammar - a sentence.
      </para><para
>	You'll notice that things which can't be broken down any
	further are in capitals - there's no rule which tells us how
	to make a noun, for instance. This is because these are fed to
	us by the lexer; these are called <firstterm
>terminal
	  symbols</firstterm>, and the things which aren't in capitals
	are called <firstterm
>non-terminal symbols</firstterm>. Why?
	Well, let's see what happens if we try and parse a sentence in
	this grammar.
	<inlinemediaobject
><imageobject
><imagedata
fileref="mycat.eps"
format="eps"
></imagedata></imageobject><imageobject
><imagedata
fileref="mycat.gif"
format="gif"
></imagedata></imageobject></inlinemediaobject>
      </para><para
>	The text right at the bottom - "my cat eats fish" - is what we
	get in from the user. The tokeniser then turns that into a
	series of tokens - "PRONOMINAL NOUN VERB NOUN". From that, we
	can start performing some reductions: we have a pronominal, so
	we're looking for a noun phrase to satisfy the
	<literal
moreinfo="none"
>nounphrase : PRONOMINAL nounphrase</literal>
	rule. Can we make a noun phrase? Yes, we can, by reducing the
	<literal
moreinfo="none"
>NOUN</literal> ("cat") into a
	<literal
moreinfo="none"
>nounphrase</literal>. Then we can use
	<literal
moreinfo="none"
>PRONOMINAL nounphrase</literal> to make another
	<literal
moreinfo="none"
>nounphrase</literal>.
      </para><para
>	Now we've got a <literal
moreinfo="none"
>nounphrase</literal> and a
	<literal
moreinfo="none"
>VERB</literal>. We can't do anything further with the
	<literal
moreinfo="none"
>nounphrase</literal>, so we'll switch to the
	<literal
moreinfo="none"
>VERB</literal>, and the only thing we can do with
	that is turn it into a <literal
moreinfo="none"
>verbphrase</literal>. Finally,
	we can reduce the noun to a <literal
moreinfo="none"
>nounphrase</literal>,
	leaving us with <literal
moreinfo="none"
>nounphrase verbphrase
	  nounphrase</literal>. Since we can turn this into a
	<literal
moreinfo="none"
>sentence</literal>, we've parsed the text.
      </para></sect2><sect2
><title
>Parse actions and token values</title><para
>	It's important to note that the tree we've constructed above -
	the "parse tree" - is only a device to help us understand the
	parsing process. It doesn't actually exist as a data structure
	anywhere in the parser. This is actually a little
	inconvenient, because the whole point of parsing a piece of
	Perl text is to come up with a data structure pretty much like
	that.
      </para><para
>	Not a problem. Yacc allows us to extend BNF by adding
	actions to rules - every time the parser performs a reduction
	using a rule, it can trigger a piece of C code to be
	executed.  Here's an extract from Perl's grammar in
	<filename
moreinfo="none"
>perly.y</filename>:
	<programlisting
format="linespecific"
>term    :   term ASSIGNOP term
	  { $$ = newASSIGNOP(OPf_STACKED, $1, $2, $3); }
        |   term ADDOP term
	  { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
	</programlisting>
	The pieces of code in the curlies are actions to be
	performed. Here's the final piece of the puzzle: each symbol
	carries some additional information around. For instance, in
	our "cat" example, the first <literal
moreinfo="none"
>NOUN</literal> had the
	value "cat". You can get at the value of a symbol by a Yacc
	variable starting with a dollar sign: in the example above,
	<varname
>$1</varname> is the value of the first symbol on the
	right of the colon (<literal
moreinfo="none"
>term</literal>),
	<varname
>$2</varname> is the value of the second symbol
	(either <literal
moreinfo="none"
>ASSIGNOP</literal> or
	<literal
moreinfo="none"
>ADDOP</literal> depending on which line you're
	reading) and so on. <varname
>$$</varname> is the value of the
	symbol on the left. Hence information is propagated "up" the
	parse tree by manipulating the information on the right and
	assigning it to the symbol on the left.
      </para></sect2><sect2
><title
>Parsing some Perl</title><para
>	So, let's see what happens if we parse the Perl code
	<userinput
moreinfo="none"
>$a = $b + $c</userinput>. We have to assume that
	<userinput
moreinfo="none"
>$a</userinput>, <userinput
moreinfo="none"
>$b</userinput> and
	<userinput
moreinfo="none"
>$c</userinput> have already been parsed a little;
	they'll turn into <literal
moreinfo="none"
>term</literal> symbols. Each of
	these symbols will have a value, and that will be an "op". An
	"op" is a data structure representing an operation, and the
	operation to be represented will be that of retrieving the
	storage pointed to by the appropriate variable.
      </para><para
>	Let's start from the right<footnote
><para
>	    This is slightly disingenous, as parsing is always done
	    from left to right, but this simplification is easier than
	    getting into the details of how Yacc grammars recognise
	    the precendence of operators.
	  </para></footnote>
	, and deal with <userinput
moreinfo="none"
>$b + $c</userinput>. The
	<userinput
moreinfo="none"
>+</userinput> is turned by the lexer into the
	terminal symbol <literal
moreinfo="none"
>ADDOP</literal>. Now, just like there
	can be lots of different nouns that all get tokenised to
	<literal
moreinfo="none"
>NOUN</literal>, there can be several different
	<literal
moreinfo="none"
>ADDOP</literal>s - concatenation is classified as an
	<literal
moreinfo="none"
>ADDOP</literal>, so <userinput
moreinfo="none"
>$b . $c</userinput>
	would look just the same to the parser. The difference, of
	course, is the value of the symbol - this
	<literal
moreinfo="none"
>ADDOP</literal> will have the value
	<literal
moreinfo="none"
>'+'</literal>.
      </para><para
>	Hence, we have <literal
moreinfo="none"
>term ADDOP term</literal>. This means
	we can perform a reduction, using the second rule in our
	snippet. When we do that, we have to perform the code in
	curlies underneath the rule - 
	<literal
moreinfo="none"
> { $$ = newBINOP($2, 0, scalar($1), scalar($3));	}</literal>. 
	<function
moreinfo="none"
>newBINOP</function> is a function which creates a
	new binary "op". The first argument is the type of binary
	operator, and we feed it the value of the second symbol. This
	is <literal
moreinfo="none"
>ADDOP</literal>, and as we have just noted, this
	symbol will have the value <literal
moreinfo="none"
>'+'</literal>. So although
	<literal
moreinfo="none"
>'.'</literal> and <literal
moreinfo="none"
>'+'</literal> look the
	same to the parser, they'll eventually be distinguished by the
	value of their symbol. Back to
	<function
moreinfo="none"
>newBINOP</function>. The next argument is the flags
	we wish to pass to the op. We don't want anything special, so
	we pass zero.
      </para><para
>	Then we have our arguments to the binary operator - obviously,
	these are the value of the symbol on the left and the value of
	the symbol on the right of the operator. As we mentioned
	above, these are both "op"s, to retrieve the values of
	<varname
>$b</varname> and <varname
>$c</varname> respectively.
	We assign the new "op" created by
	<function
moreinfo="none"
>newBINOP</function> to be the value of the symbol
	we're propagating upwards. Hence, we've taken two ops - the
	ones for <varname
>$b</varname> and <varname
>$c</varname> -
	plus an addition symbol, and turned them into a new op
	representing the combined action of fetching the values of
	<varname
>$b</varname> and <varname
>$c</varname> and then
	adding them together.
      </para><para
>	Now we do the same thing with <literal
moreinfo="none"
>$a =
	  ($b+$c)</literal>. I've put the right hand side in brackets to
	show that we've already got something which represents
	fetching <varname
>$b</varname> and <varname
>$c</varname> and
	adding them. <literal
moreinfo="none"
>=</literal> is turned into an
	<literal
moreinfo="none"
>ASSIGNOP</literal> by the tokeniser in the same way
	as we turned <literal
moreinfo="none"
>+</literal> into an
	<literal
moreinfo="none"
>ADDOP</literal>. And, in just the same way, there are
	various different types of assignment operator -
	<literal
moreinfo="none"
>||=</literal> and <literal
moreinfo="none"
>&amp;&amp;=</literal> are
	also passed as <literal
moreinfo="none"
>ASSIGNOP</literal>s. From here, it's
	easy: we take the <literal
moreinfo="none"
>term</literal> representing
	<varname
>$a</varname>, plus the <literal
moreinfo="none"
>ASSIGNOP</literal>,
	plus the <literal
moreinfo="none"
>term</literal> we've just constructed,
	reduce them all to another <literal
moreinfo="none"
>term</literal>, and
	perform the action underneath the rule. In the end, we end up
	with a data structure a little like this:
	<inlinemediaobject
><imageobject
><imagedata
fileref="abc-simple.eps"
format="eps"
></imagedata></imageobject><imageobject
><imagedata
fileref="abc-simple.gif"
format="gif"
></imagedata></imageobject></inlinemediaobject>
      </para><para
>	You can find a hypertext version of the Perl grammar at <ulink
url="http://simon-cozens.org/hacks/grammar.pdf"
>http://simon-cozens.org/hacks/grammar.pdf</ulink>
      </para></sect2></sect1><sect1
id="internals.tokeniser"
><title
>The Tokeniser</title><para
>      The tokeniser, in <filename
moreinfo="none"
>toke.c</filename> is one of the most
      difficult parts of the Perl core to understand; this is
      primarily because there is no real "roadmap" to explain its
      operation. In this section, we'll try to show how the tokeniser
      is put together.
    </para><sect2
><title
>Basic tokenising</title><para
>	The core of the tokeniser is the intimidatingly long
	<function
moreinfo="none"
>yylex</function> function. This is the function
	called by the parser, <function
moreinfo="none"
>yyparse</function>, when it
	requests a new token of input.
      </para><para
>	First, some basics. When a token has been identified, it is
	placed in <varname
>PL_tokenbuf</varname>. The file handle from
	which input is being read is <varname
>PL_rsfp</varname>. The
	current position in the input is stored in the variable
	<varname
>PL_bufptr</varname>, which is a pointer into the PV
	of the SV <varname
>PL_linestr</varname>. When scanning for a
	token, the variable <varname
>s</varname> advances from the
	start of <varname
>PL_bufptr</varname> towards the end of the
	buffer (<varname
>PL_bufend</varname>) until it finds a token.
      </para><para
>	The first thing the parser does is test whether the next thing
	in the input stream has already been identified as an
	identifier; when the tokeniser sees <literal
moreinfo="none"
>'%'</literal>,
	<literal
moreinfo="none"
>'$'</literal> and the like as part of the input, it
	tests to see whether it introduces a variable. If so, it puts
	the variable name into the token buffer. It then returns the
	type sigil (<literal
moreinfo="none"
>%</literal>, <literal
moreinfo="none"
>$</literal>, etc.) 
	as a token, and sets a flag
	(<varname
>PL_pending_ident</varname>) so that the next time
	<function
moreinfo="none"
>yylex</function> is called, it can pull the variable
	name straight out of the token buffer. Hence, right at the top
	of <function
moreinfo="none"
>yylex</function>, you'll see code which tests
	<varname
>PL_pending_ident</varname> and deals with the
	variable name.
      </para><sect3
><title
>Tokeniser State</title><para
>	  Next, if there's no identifier in the token buffer, it checks
	  its tokeniser state. The tokeniser uses the variable
	  <varname
>PL_lex_state</varname> to store state
	  information.
	</para><para
>	  One important state is <literal
moreinfo="none"
>LEX_KNOWNEXT</literal>, which
	  occurs when Perl has had to look ahead one token to identify
	  something. If this happens, it has tokenised not just the next
	  token, but the one after as well. Hence, it sets
	  <literal
moreinfo="none"
>LEX_KNOWNEXT</literal> to say "we've already
	  tokenised this token, simply return it."
	</para><para
>	  The functions which set <literal
moreinfo="none"
>LEX_KNOWNEXT</literal> are
	  <function
moreinfo="none"
>force_word</function>, which declares that the next
	  token has to be a word, (for instance, after having seen an
	  arrow in <literal
moreinfo="none"
>$foo-&gt;bar</literal>)
	  <function
moreinfo="none"
>force_ident</function>, which makes the next token
	  an identifier, (for instance, if it sees a
	  <literal
moreinfo="none"
>*</literal> when not expecting an operator, this must
	  be a glob) <function
moreinfo="none"
>force_version</function>, (on seeing a
	  number after <literal
moreinfo="none"
>use</literal>) and the general
	  <function
moreinfo="none"
>force_next</function>.
	</para><para
>	  Many of the other states are to do with interpolation of
	  double-quoted strings; we'll look at those in more detail in
	  the next section.
	</para></sect3><sect3
><title
>Looking ahead</title><para
>	  After checking the lexer state, it's time to actually peek at
	  the buffer and see what's waiting; this is the start of the
	  giant <literal
moreinfo="none"
>switch</literal> statement in the middle of
	  <function
moreinfo="none"
>yylex</function>, just following the label
	  <literal
moreinfo="none"
>retry</literal>.
	</para><para
>	  One of the first things we check for is character zero - this
	  signifies either the start or the end of the file or the end
	  of the line. If it's the end of the file, the tokeniser
	  returns zero and the game is one; at the beginning of the
	  file, Perl has to process the code for command line switches
	  such as <literal
moreinfo="none"
>-n</literal> and
	  <literal
moreinfo="none"
>-p</literal>. Otherwise, Perl calls
	  <function
moreinfo="none"
>filter_gets</function> to get a new line from the
	  file through the source filter system, and calls
	  <function
moreinfo="none"
>incline</function> to increase the line
	  number.
	</para><para
>	  The next test is for comments and new lines, which Perl skips
	  over. After that come the tests for individual special
	  characters. For instance, the first test is for minus, which
	  could be unary minus if followed by a number or identifier, or
	  the binary minus operator if Perl is expecting an operator, or
	  the arrow operator if followed by a <literal
moreinfo="none"
>&gt;</literal>,
	  or the start of a filetest operator if followed by an
	  appropriate letter, or a quoting option such as <literal
moreinfo="none"
>(-foo
	    =&gt; "bar" )</literal>. Perl tests for each case, and returns
	  the token type using one of the upper-case token macros
	  defined at the beginning of <filename
moreinfo="none"
>toke.c</filename>:
	  <literal
moreinfo="none"
>OPERATOR</literal>, <literal
moreinfo="none"
>TERM</literal>, and so on.
	</para><para
>	  If the next character isn't a symbol that Perl knows about,
	  it's an alphabetic character which might start a keyword: the
	  tokeniser jumps to the label <literal
moreinfo="none"
>keylookup</literal>
	  where it checks for labels and things like
	  <literal
moreinfo="none"
>CORE::function</literal>. It then calls
	  <function
moreinfo="none"
>keyword</function> to test whether it is a valid
	  built-in or not - if so, <function
moreinfo="none"
>keyword</function> turns it
	  into a special constant (such as <literal
moreinfo="none"
>KEY_open</literal>)
	  which can be fed into the <literal
moreinfo="none"
>switch</literal>
	  statement. If it's not a keyword, Perl has to determine
	  whether it's a bareword, a function call or an indirect object
	  or method call.
	</para></sect3><sect3
><title
>Keywords</title><para
>	  The final section of the <literal
moreinfo="none"
>switch</literal> statement
	  deals with the <literal
moreinfo="none"
>KEY_</literal> constants handed back
	  from <function
moreinfo="none"
>keyword</function>, performing any actions
	  necessary for using the builtins. (For instance, given
	  <literal
moreinfo="none"
>__DATA__</literal>, the tokeniser sets up the
	  <literal
moreinfo="none"
>DATA</literal> filehandle.)
	</para></sect3></sect2><sect2
><title
>Sublexing</title><para
>	"Sublexing" refers to the the fact that inside double-quoted
	strings and other interpolation contexts (regular expressions,
	for instance) a different type of tokenisation is needed.
      </para><para
>	This is typically started after a call to
	<function
moreinfo="none"
>scan_str</function>, which is an exceptionally
	clever piece of code which extracts a string with balanced
	delimiters, placing it into the SV
	<varname
>PL_lex_stuff</varname>. Then
	<function
moreinfo="none"
>sublex_start</function> is called which sets up the
	data structures used for sublexing and changes the lexer's
	state to <literal
moreinfo="none"
>LEX_INTERPPUSH</literal>, which is
	essentially a scoping operator for sublexing.
      </para><para
>	Why does sublexing need scoping? Well, consider something like
	<literal
moreinfo="none"
>"Foo\u\LB\uarBaz"</literal>. This actually gets
	tokenized as the moral equivalent of <literal
moreinfo="none"
>"Foo" .
	ucfirst(lc("B" . ucfirst("arBaz")))</literal>. The push state
	(which makes a call to <function
moreinfo="none"
>sublex_push</function>) quite
	literally pushes an opening bracket onto the input
	stream.</para><para
>	This in turn changes the state to
	<literal
moreinfo="none"
>LEX_INTERPCONCAT</literal>; the concatentation state
	uses <function
moreinfo="none"
>scan_const</function> to pull out constant
	strings and supplies the concatenation operator between
	them. If a variable to be interpolated is found, the state is
	changed to <literal
moreinfo="none"
>LEX_INTERPSTART</literal>: this means that
	<literal
moreinfo="none"
>"foo$bar"</literal> is changed into
	<literal
moreinfo="none"
>"foo".$bar</literal> and <literal
moreinfo="none"
>"foo@bar"</literal>
	is turned into <literal
moreinfo="none"
>"foo".join($",@bar)</literal>. 
      </para><para
>	There are times when it is not sure when sublexing of an
	interpolated variable should end - in these cases, the
	horrifyingly scary function <function
moreinfo="none"
>intuit_more</function>
	is called to make an educated guess on the likelihood of more
	interpolation.
      </para><para
>	Finally, once sublexing is done, the state is set to
	<literal
moreinfo="none"
>LEX_INTERPEND</literal> which fixes up the closing
	brackets.
      </para></sect2><sect2
><title
>Summary</title><para
>	So far, we've briefly examined how Perl turns Perl
	source input into a tree data structure suitable for executing;
	next, we'll look more specifically at the nature
	of the nodes in that tree.
      </para><para
>	There are two stages to this operation: the tokeniser,
	<filename
moreinfo="none"
>toke.c</filename>, chops up the incoming program and
	recognises different token types; the parser
	<filename
moreinfo="none"
>perly.y</filename> then assembles these tokens into
	phrases and sentences. In reality, the whole task is driver by
	the parser - Perl calls <function
moreinfo="none"
>yyparse</function> to parse a
	program, and when the parser needs to know about the next token,
	it calls <function
moreinfo="none"
>yylex</function>.
      </para><para
>	While the parser is relatively straightforward, the tokeniser is
	somewhat more tricky. The key to understanding it is to divide
	its operation into checking tokeniser state, dealing with
	non-alphanumeric symbols in ordinary program code, dealing with
	alphanumerics, and dealing with double-quoted strings and other
	interpolation contexts.
      </para><para
>      Very few people actually understand the whole of how the
      tokeniser and parser work, but this chapter should have given
      you a useful insight into how Perl understands program code, and
      how to locate the source of particular behaviour inside the
      parsing system.
    </para></sect2></sect1><sect1
id="internals.optree"
><title
> Op Code Trees </title><para
>    So we've seen that the job of the parsing stage is to reduce a
    program to a tree structure, and each node of the tree represents
    an operation. In this chapter, we'll look more closely at those
    operations: what they are, how they're coded, and how they fit together.
  </para><sect2
id="internals.optress.basic"
><title
> The basic op </title><para
>      Just AVs and HVs are "extensions" of the basic SV structure,
      there are a number of different "flavours" of ops, built on a
      basic OP structure; you can find this structure defined as
      <literal
moreinfo="none"
>BASEOP</literal> in <filename
moreinfo="none"
>op.h</filename>:
    </para><programlisting
format="linespecific"
>    OP*         op_next;
    OP*         op_sibling;
    OP*         (CPERLscope(*op_ppaddr))(pTHX); 
    PADOFFSET   op_targ;
    OPCODE      op_type;
    U16         op_seq;
    U8          op_flags;
   U8          op_private;
    </programlisting><para
>      Some of these fields are easy to explain, so we'll deal with
      them now. 
    </para><para
>      The <literal
moreinfo="none"
>op_next</literal> field is a pointer to the next op
      which needs to be executed. We'll see later, in <xref
linkend="internals.optree.tied"
></xref>, how the "thread of execution" is derived
      from the tree.
    </para><para
>      <literal
moreinfo="none"
>op_ppaddr</literal> is the address of the C function
      which carries out this particular operation. It's stored here so
      that our main execution code can simply dereference the function
      pointer and jump to it, instead of having to perform a lookup.
    </para><para
>      Each unique operation has a different number; this can be found
      in the <literal
moreinfo="none"
>enum</literal> in
      <filename
moreinfo="none"
>opnames.h</filename>:

      <programlisting
format="linespecific"
>typedef enum opcode {
    OP_NULL,        /* 0 */
    OP_STUB,        /* 1 */
    OP_SCALAR,      /* 2 */
    OP_PUSHMARK,    /* 3 */
    OP_WANTARRAY,   /* 4 */
    OP_CONST,       /* 5 */
    OP_GVSV,        /* 6 */
    OP_GV,          /* 7 */
    ...
};</programlisting>

      The number of the operation to perform is stored in the
      <literal
moreinfo="none"
>op_type</literal> field. We'll examine some of the more
      interesting operations in <xref
linkend="internals.optree.diff"
></xref>.
    </para><para
>      <literal
moreinfo="none"
>op_flags</literal> is a set of flags generic to all
      ops; <literal
moreinfo="none"
>op_private</literal> stores flags which are
      specific to the type of op. For instance, the
      <literal
moreinfo="none"
>repeat</literal> op which implements the
      <literal
moreinfo="none"
>x</literal> operator has the flag
      <literal
moreinfo="none"
>OPpREPEAT_DOLIST</literal> set when it's repeating a
      list rather than a string. This flag only makes sense for that
      particular operation, so is stored in
      <literal
moreinfo="none"
>op_private</literal>. Private flags have the
      <literal
moreinfo="none"
>OPp</literal> prefix, and public flags begin with
      <literal
moreinfo="none"
>OPf</literal>.
    </para><para
>      <literal
moreinfo="none"
>op_seq</literal> is a sequence number allocated by the
      optimizer. It allows for, for instance, correct scoping of
      lexical variables by storing the sequence numbers of the
      beginning and end of scope operations inside the pad.
    </para><para
>      As for the remaining fields, we'll examine
      <literal
moreinfo="none"
>op_sibling</literal> in <xref
linkend="internals.optree.flavours"
></xref>
      and <literal
moreinfo="none"
>op_targ</literal> in <xref
linkend="internals.optree.scratch"
></xref>
    </para><sect3
id="internals.optree.diff"
><title
>The different operations</title><para
>	Perl has currently 351 different operations, implementing all
	the built-in functions and operators, as well as the more
	structural operations required internally - entering and
	leaving a scope, compiling regular expressions and so on.
      </para><para
>	The array <varname
>PL_op_desc</varname> in
	<filename
moreinfo="none"
>opcode.h</filename> describes each operation: it may
	be easier to follow the data from which this table is
	generated, at the end of <filename
moreinfo="none"
>opcode.pl</filename>. We'll
	take a longer look at that file later on in this chapter.
      </para><para
>	Many of the operators are familiar from Perl-space, such as
	<literal
moreinfo="none"
>concat</literal> and <literal
moreinfo="none"
>splice</literal>, but
	some are used purely internally: for instance, one of the most
	common, <literal
moreinfo="none"
>gvsv</literal> fetches a scalar variable;
	<literal
moreinfo="none"
>enter</literal> and <literal
moreinfo="none"
>leave</literal> are
	block control operators, and so on.
      </para></sect3><sect3
id="internals.optree.flavours"
><title
>Different "flavours" of op</title><para
>	There are a number of different "flavours" of op structure,
	related to the arguments of an operator and how it fits
	together with other ops in the op tree. For instance,
	<literal
moreinfo="none"
>scalar</literal> is a unary operator, a
	<type
>UNOP</type>. This extends the basic op structure above
	with a link to the argument:

	<programlisting
format="linespecific"
>struct unop {
    BASEOP
    OP *    op_first;
};</programlisting>

	Binary operators, such as <literal
moreinfo="none"
>i_add</literal>, (integer
	addition) have both a <literal
moreinfo="none"
>first</literal> and a
	<literal
moreinfo="none"
>last</literal>:
	<programlisting
format="linespecific"
>struct binop {
    BASEOP
    OP *    op_first;
    OP *    op_last;
};</programlisting>
      </para><para
>	List operators are more interesting; they too have a
	<literal
moreinfo="none"
>first</literal> and a <literal
moreinfo="none"
>last</literal>, but
	they also have some ops in the middle, too. This is where
	<literal
moreinfo="none"
>op_sibling</literal> above comes in; it connects ops
	"sibling" ops on the same level in a list. For instance, look
	at the following code and the graph of its op tree:
	<programlisting
format="linespecific"
>open FILE, "foo";
print FILE "hi\n";
close FILE;</programlisting>
	<mediaobject
><imageobject
><imagedata
fileref="siblings.eps"
format="eps"
></imagedata></imageobject><imageobject
><imagedata
fileref="siblings.gif"
format="gif"
></imagedata></imageobject></mediaobject></para><para
>	The dashed lines represent <literal
moreinfo="none"
>op_sibling</literal>
	connections. The root operator of every program is the list
	operator <literal
moreinfo="none"
>leave</literal>, and its children are the
	statements in the program, separated by
	<literal
moreinfo="none"
>nextstate</literal> (next statement)
	operators. <literal
moreinfo="none"
>open</literal> is also a list operator, as
	is <literal
moreinfo="none"
>print</literal>. The first child of
	<literal
moreinfo="none"
>print</literal> is <literal
moreinfo="none"
>pushmark</literal>, which
	puts a mark on the stack (see <xref
linkend="internals.optree.argstack"
></xref>)
	so that Perl knows how many arguments on the stack belong to
	<literal
moreinfo="none"
>print</literal>. The <literal
moreinfo="none"
>rv2gv</literal> turns a
	reference to the filehandle <varname
>FILE</varname> into a GV,
	so that <literal
moreinfo="none"
>print</literal> can print to it, and the
	final child is the constant <literal
moreinfo="none"
>"hi\n"</literal>.
      </para><para
>	Some operators hold information about the program; these are
	COPs, or "code operators". Their definition is in
	<filename
moreinfo="none"
>cop.h</filename>:
<programlisting
format="linespecific"
>struct cop {
    BASEOP
    char *  cop_label;  /* label for this construct */
#ifdef USE_ITHREADS
    char *  cop_stashpv;    /* package line was compiled in */
    char *  cop_file;   /* file name the following line # is from */
#else
    HV *    cop_stash;  /* package line was compiled in */
    GV *    cop_filegv; /* file the following line # is from */
#endif
    U32     cop_seq;    /* parse sequence number */
    I32     cop_arybase;    /* array base this line was compiled with */
    line_t      cop_line;       /* line # of this command */
    SV *    cop_warnings;   /* lexical warnings bitmask */
    SV *    cop_io;     /* lexical IO defaults */
};
	</programlisting>
	COPs are inserted between every statement; they contain the
	label (for <literal
moreinfo="none"
>goto</literal>, <literal
moreinfo="none"
>next</literal>
	and so on) of the statement, the file name, package and line
	number of the statement and lexical hints such as the current
	value of <varname
>$[</varname>, warnings and IO settings. Note
	that this doesn't contain the current CV or the padlist -
	these are kept on a special stack called the "context stack". 
      </para><para
>	The final type of op is the null op: any op with type zero
	means that a previous op has been optimized away; we'll look
	at how this is done later in this chapter, but for now, you
	should skip over the null op when you see it in op trees.
      </para></sect3><sect3
id="internals.optree.tied"
><title
> Tying it all together </title><para
>	We've so far seen a little of how the op tree is connected
	together with <literal
moreinfo="none"
>op_first</literal>,
	<literal
moreinfo="none"
>op_last</literal>, <literal
moreinfo="none"
>op_sibling</literal>, and
	so on. Now we'll look at how the tree gets manufactured, as
	how it gets executed.
      </para><sect4
><title
>"Tree" order</title><para
>	  After our investigation of the parser in the previous
	  chapter, it should now be straightforward to see how the op
	  tree is created. The parser calls routines in
      <filename
moreinfo="none"
>op.c</filename> which create the op structures, 
      passing ops further "down" the parse tree as arguments. This
      threads together a tree as shown in the diagram above. For
      comparison, here is the what the example in that chapter
      (<literal
moreinfo="none"
>$a = $b + $c</literal>) really looks like as an op 
      tree:
	<mediaobject
><imageobject
><imagedata
fileref="abc.eps"
format="eps"
></imagedata></imageobject><imageobject
><imagedata
fileref="abc.gif"
format="gif"
></imagedata></imageobject></mediaobject>
      Again, you can see the places where an op was optimized away and
      became a null op. This is not so different from the simplified
      version we gave earlier.
	</para></sect4><sect4
><title
> Execution Order </title><para
> 
	  The second thread through the op tree, indicated by the
	  dotted line in our diagrams, is the execution order. This is
	  the order in which Perl must actually perform the operations
	  in order to run the program. The main loop of Perl is very,
	  very simple, and you can see it in
	  <filename
moreinfo="none"
>run.c</filename>:
	  <programlisting
format="linespecific"
>    while ((PL_op = CALL_FPTR(PL_op-&gt;op_ppaddr)(aTHX))) {
        PERL_ASYNC_CHECK();
    }</programlisting>
	  That's it. That's all the Perl interpreter
	  is. <varname
>PL_op</varname> represents the op that's
	  currently being executed. Perl calls the function pointer
	  for that op and expects another op to be returned; this
	  return value is then set to <varname
>PL_op</varname>, which
	  is executed in turn. Since everything apart from conditional
	  operators (for obvious reasons) just return
	  <varname
>PL_op-&gt;op_next</varname>, the execution order
	  through a program can be found by chasing the trail of
	  <varname
>op_next</varname> pointers from the start node to
	  the root.
	</para><para
>	  We can trace the execution order in several ways: if Perl is
	  built with debugging (<xref
linkend="developing.minusd"
></xref>), then we
	  can say 
	  <screen
format="linespecific"
><userinput
moreinfo="none"
>perl -Dt -e 'open ...'</userinput></screen>
	</para><para
>	  Alternatively, and perhaps more simply, the compiler module
	  <classname
>B::Terse</classname> has an option to print the
	  execution order, <literal
moreinfo="none"
>-exec</literal>.  For instance, in
	  our "open-print-close" example above, the execution order
	  is:

	  <screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -MO=Terse,-exec -e 'open FILE, "foo"; ...'</userinput>
<computeroutput
moreinfo="none"
>OP (0x8111510) enter
COP (0x81121c8) nextstate
OP (0x8186f30) pushmark
SVOP (0x8186fe0) gv  GV (0x8111bd8) *FILE
SVOP (0x8186f10) const  PV (0x810dd98) "foo"
LISTOP (0x810a170) open [1]
COP (0x81114d0) nextstate
OP (0x81114b0) pushmark
SVOP (0x8118318) gv  GV (0x8111bd8) *FILE
UNOP (0x8111468) rv2gv
SVOP (0x8111448) const  PV (0x8111bfc) "hi\n"
LISTOP (0x8111488) print
COP (0x8111fe0) nextstate
SVOP (0x8111fc0) gv  GV (0x8111bd8) *FILE
UNOP (0x8111fa0) close
LISTOP (0x8111420) leave [1]</computeroutput></screen>
	  This program, just like every other program, starts with the
	  <literal
moreinfo="none"
>enter</literal> and <literal
moreinfo="none"
>nextstate</literal>
	  ops to enter a scope and begin a new statement
	  respectively. Then a mark is placed on the argument stack:
	  marks represent the start of a set of arguments, and a list
	  operator can retrieve all the arguments by pushing values
	  off the stack until it finds a mark. Hence, we're notifying
	  Perl of the beginning of the arguments to the
	  <literal
moreinfo="none"
>open</literal> operator.
	</para><para
>	  The arguments in this case are merely the file handle to be
	  opened and the file name; after operators put these two
	  arguments on the stack, <literal
moreinfo="none"
>open</literal> can be
	  called. This is the end of the first statement.
	</para><para
>	  Next, the arguments to <literal
moreinfo="none"
>print</literal> begin. This
	  is slightly more tricky, because while
	  <literal
moreinfo="none"
>open</literal> can only take a true filehandle,
	  <literal
moreinfo="none"
>print</literal> may take any sort of
	  reference. Hence, <literal
moreinfo="none"
>gv</literal> returns the GV and
	  then this is turned into the appropriate filehandle type by
	  the <literal
moreinfo="none"
>rv2gv</literal> operator. After the filehandle
	  come the arguments to be printed; in this case, a constant
	  (<literal
moreinfo="none"
>"hi\n"</literal>). Now all the arguments have been
	  placed on the stack, <literal
moreinfo="none"
>print</literal> can be
	  called. This is the end of the second statement.
	</para><para
>	  Finally, a filehandle is put on the stack and closed. Note
	  that at this point, the connections between the operators -
	  unary, binary, etc. - are not important; all manipulation of
	  values comes not by looking at the children of the operators
	  but by looking at the stack. The types of op are important
	  for the construction of the tree in "tree order", but the
	  stack and the <literal
moreinfo="none"
>op_next</literal> pointers are the
	  only important things for the execution of the tree in
	  execution order.
	</para><sidebar
><para
>	    How is the execution order determined? The function
	    <function
moreinfo="none"
>linklist</function> in <filename
moreinfo="none"
>op.c</filename>
	    takes care of threading the <literal
moreinfo="none"
>op_next</literal>
	    pointers in prefix order. It does so by recursively
	    applying the following rule:
	    <itemizedlist
><listitem
><para
>If there is a child for the current operator,
		  visit the child first, then its siblings, then the
		  current op.</para></listitem></itemizedlist>
	    Hence, the starting operator is always the first child of
	    the root operator, (always <literal
moreinfo="none"
>enter</literal>) the
        second op to be executed is its sibling,
        <literal
moreinfo="none"
>nextstate</literal>, and then the children of the next
        op are visited. Similarly, the root itself
        (<literal
moreinfo="none"
>leave</literal>) is always the last
	    operator to be executed. Null operators are skipped over
	    during optimization.
	  </para></sidebar></sect4></sect3></sect2><sect2
id="internals.optree.ppcode"
><title
> PP Code </title><para
>      We know the order of execution of the operations, and what some
      of them do. Now it's time to look at how they're actually
      implemented - the source code inside the interpreter that
      actually carries out <literal
moreinfo="none"
>print</literal>,
      <literal
moreinfo="none"
>+</literal>, and other operations.
    </para><para
>      The functions which implement operations are known as "PP Code"
      - "Push / Pop Code" - because most of their work involves
      popping off elements from a stack, performing some operation on
      it, and then pushing the result back. PP code can be found in
      several files: <filename
moreinfo="none"
>pp_hot.c</filename> contains frequently
      used code, put into a single object to encourage CPU caching;
      <filename
moreinfo="none"
>pp_ctl.c</filename> contains operations related to
      flow control; <filename
moreinfo="none"
>pp_sys.c</filename> contains the
      system-specific operations such as file and network handling;
      <literal
moreinfo="none"
>pack</literal> and <literal
moreinfo="none"
>unpack</literal> recently
      moved to <filename
moreinfo="none"
>pp_pack.c</filename>, and
      <filename
moreinfo="none"
>pp.c</filename> contains everything else.
    </para><sect3
id="internals.optree.argstack"
><title
>The argument stack</title><para
>	We've already talked a little about the argument stack. The
	Perl interpreter makes use of several stacks, but
	the argument stack is the main one. 
      </para><para
>	The best way to see how the argument stack is used is to watch
	it in operation. With a debugging build of Perl, the
	<literal
moreinfo="none"
>-Ds</literal> command line switch prints out the
	contents of the stack in symbolic format between
	operations. Here is a portion of the output of running
	<userinput
moreinfo="none"
>$a=5; $b=10; print $a+$b;</userinput>:
	<screen
format="linespecific"
>(-e:1)  nextstate
    =&gt;
(-e:1)  pushmark
    =&gt;  *
(-e:1)  gvsv(main::a)
    =&gt;  *  IV(5)
(-e:1)  gvsv(main::b)
    =&gt;  *  IV(5)  IV(10)
(-e:1)  add
    =&gt;  *  IV(15)
(-e:1)  print
    =&gt;  SV_YES
	</screen>
	At the beginning of a statement, the stack is typically
	empty. First, Perl pushes a mark onto the stack to know when
	to stop pushing off arguments for
	<literal
moreinfo="none"
>print</literal>. Next, the values of
	<varname
>$a</varname> and <varname
>$b</varname> are retrieved
	and pushed onto the stack.
      </para><para
>	The addition operator is a binary operator, and hence,
	logically, it takes two values off the stack, adds them
	together and puts the result back onto the stack. Finally,
	<literal
moreinfo="none"
>print</literal> takes all of the values off the stack
	up to the previous bookmark and prints them out. Let's not
	forget that <literal
moreinfo="none"
>print</literal> itself has a return
	value, the true value <varname
>SV_YES</varname> which it
	pushes back onto the stack.
      </para></sect3><sect3
><title
>Stack manipulation</title><para
>	Let's now take a look at one of the PP functions, the integer
	addition function <literal
moreinfo="none"
>pp_i_add</literal>. The code may
	look formidable, but it's a good example of how the PP
	functions manipulate values on the stack. 
	<programlistingco
><areaspec
><area
coords="1"
id="internals.optree.stack.1"
></area><area
coords="3"
id="internals.optree.stack.2"
></area><area
coords="5"
id="internals.optree.stack.3"
></area><area
coords="6"
id="internals.optree.stack.4"
></area><area
coords="7"
id="internals.optree.stack.5"
></area></areaspec><programlisting
format="linespecific"
>PP(pp_i_add)
{
    dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
    {
      dPOPTOPiirl_ul;
      SETi( left + right );
      RETURN;
    }
}</programlisting><calloutlist
><callout
arearefs="internals.optree.stack.1"
><para
>		In case you haven't guessed,
		<emphasis
>everything</emphasis> in this function is a
		macro. This first line declares the function
		<function
moreinfo="none"
>pp_i_add</function> to be the appropriate
		type for a PP function.
	      </para></callout><callout
arearefs="internals.optree.stack.2"
><para
>		Since following macros will need to manipulate the
		stack, the first thing we need is a local copy of the
		stack pointer, <varname
>SP</varname>. And since this
		is C, we need to declare this in advance:
		<literal
moreinfo="none"
>dSP</literal> declares a stack pointer. Then
		we need an SV to hold the return value, a
		"target". This is declared with
		<literal
moreinfo="none"
>dATARGET</literal>; see <xref
linkend="internals.optree.scratch"
></xref> for more on how targets
		work. Finally, there is a chance that the addition
		operator has been overloaded using the
		<classname
>overload</classname> pragma. The
		<literal
moreinfo="none"
>tryAMAGICbin</literal> macro tests to see if
		it is appropriate to perform "A" (overload) magic on
		either of the scalars in a binary operation, and if
		so, does the addition using a magic method call.
	      </para></callout><callout
arearefs="internals.optree.stack.3"
><para
>		We will deal with two values, <varname
>left</varname>
		and <varname
>right</varname>. The
		<literal
moreinfo="none"
>dPOPTOPiirl_ul</literal> macro pops two SVs
		off the top of the stack, converts them to two
		integers (hence <literal
moreinfo="none"
>ii</literal>) and stores them
		into automatic variables <varname
>right</varname> and
		<varname
>left</varname>. (hence <literal
moreinfo="none"
>rl</literal>)
	      </para><sidebar
><para
>		    The <literal
moreinfo="none"
>_ul</literal>? Look up the definition
		    in <filename
moreinfo="none"
>pp.h</filename> and work it out...
		  </para></sidebar></callout><callout
arearefs="internals.optree.stack.4"
><para
>		We add the two values together, and set the integer
		value of the target to the result, pushing the target
		to the top of the stack.
	      </para></callout><callout
arearefs="internals.optree.stack.5"
><para
>		As mentioned above, operators are expected to return
		the next op to be executed, and in most cases this is
		simply the value of <varname
>op_next</varname>. Hence
		<literal
moreinfo="none"
>RETURN</literal> performs a normal return,
		copying our local stack pointer <varname
>SP</varname>
		which we obtained above back into the global stack
		pointer variable, and then returning the
		<varname
>op_next</varname>.
	      </para></callout></calloutlist></programlistingco>
      </para><para
>	As you might have guessed, there are a number of macros for
	controlling what happens to the stack; these can be found in
	<filename
moreinfo="none"
>pp.h</filename>. The more common of these are:
	<variablelist
><varlistentry
><term
><literal
moreinfo="none"
>POPs</literal></term><listitem
><para
>		Pop an <type
>SV</type> off the stack and return it. 
	      </para></listitem></varlistentry><varlistentry
><term
><literal
moreinfo="none"
>POPpx</literal></term><listitem
><para
>		Pop a string off the stack and return it. (Note:
		requires a variable "<type
>STRLEN</type>
		<varname
>n_a</varname>" to be in scope.)</para></listitem></varlistentry><varlistentry
><term
><literal
moreinfo="none"
>POPn</literal></term><listitem
><para
>		Pop an NV off the stack.
	      </para></listitem></varlistentry><varlistentry
><term
><literal
moreinfo="none"
>POPi</literal></term><listitem
><para
>Pop an IV off the stack.
	      </para></listitem></varlistentry><varlistentry
><term
><literal
moreinfo="none"
>TOPs</literal></term><listitem
><para
>		Return the top SV on the stack, but do not pop
		it. (The macros <literal
moreinfo="none"
>TOPpx</literal>,
		<literal
moreinfo="none"
>TOPn</literal>, etc. are analogous)
	      </para></listitem></varlistentry><varlistentry
><term
><literal
moreinfo="none"
>TOPm1s</literal></term><listitem
><para
>		Return the penultimate SV on the stack. (There is no
		<literal
moreinfo="none"
>TOPm1px</literal>, etc.)
	      </para></listitem></varlistentry><varlistentry
><term
><literal
moreinfo="none"
>PUSHs</literal></term><listitem
><para
>		Push the scalar onto the stack; you must ensure that
		the stack has enough space to accommodate it.
	      </para></listitem></varlistentry><varlistentry
><term
><literal
moreinfo="none"
>PUSHn</literal></term><listitem
><para
>		Set the NV of the target to the given value, and push
		it onto the stack. <literal
moreinfo="none"
>PUSHi</literal>, etc. are
		analogous.
	      </para><para
>		There is also an <literal
moreinfo="none"
>XPUSHs</literal>,
		<literal
moreinfo="none"
>XPUSHn</literal>, etc. which extends the
		stack if necessary.
	      </para></listitem></varlistentry><varlistentry
><term
><literal
moreinfo="none"
>SETs</literal></term><listitem
><para
>		This sets the top element of the stack to the given
		SV. <literal
moreinfo="none"
>SETn</literal>, etc. are analogous.
	      </para></listitem></varlistentry><varlistentry
><term
><literal
moreinfo="none"
>dTOPss</literal>, <literal
moreinfo="none"
>dPOPss</literal></term><listitem
><para
>		These declare a variable called <varname
>sv</varname>,
		and either return the top entry from
		the stack or pop an entry and set
		<varname
>sv</varname> to it.
	      </para></listitem></varlistentry><varlistentry
><term
><literal
moreinfo="none"
>dTOPnv</literal>, <literal
moreinfo="none"
>dPOPnv</literal></term><listitem
><para
>		These are similar, but declare a variable called
		<varname
>value</varname> of the appropriate
		type. <literal
moreinfo="none"
>dTOPiv</literal> and so on are analogous.
	      </para></listitem></varlistentry></variablelist>
      </para><para
>	In some cases, the PP code is purely concerned with
	rearranging the stack, and the PP function will call out to
	another function in <filename
moreinfo="none"
>doop.c</filename> to actually
	perform the relevant operation.
      </para></sect3></sect2><sect2
><title
> The opcode table and <filename
moreinfo="none"
>opcodes.pl</filename></title><para
>      The header files for the opcode tables are generated from a Perl
      program called <filename
moreinfo="none"
>opcode.pl</filename>. Here is a sample
      entry for an op:
      <programlisting
format="linespecific"
>index             index                      ck_index isT@     S S S?  </programlisting>
      The entry is in five columns.
    </para><para
>      The first column is the internal name of the operator. When
      <filename
moreinfo="none"
>opcode.pl</filename> is run, it will create an enum
      including the symbol <literal
moreinfo="none"
>OP_INDEX</literal>.
    </para><para
>      The second column is the English description of the operator
      which will be printed during error messages.
    </para><para
>      The third column is the name of the "check" function which will
      be used to optimize this tree; see <xref
linkend="internals.optree.optimize"
></xref>.
    </para><para
>      Then come additional flags plus a character which specifies the
      "flavour" of the op: in this case, <literal
moreinfo="none"
>index</literal> is a
      list op, since it can take more than two parameters, so it has
      the symbol <literal
moreinfo="none"
>@</literal>.
    </para><para
>      Finally, the "prototype" for the function is given: <literal
moreinfo="none"
>S S
      S?</literal> translates to the Perl prototype
      <literal
moreinfo="none"
>$$;$</literal>, which is indeed the prototype for
      <literal
moreinfo="none"
>CORE::index</literal>.
    </para><para
>      While most people will never need to edit the op table, it is as
      well to understand how Perl "knows" what the ops look
      like. There is a full description of the format of the table,
      including details of the meanings of the flags, in
      <filename
moreinfo="none"
>opcodes.pl</filename>.
    </para></sect2><sect2
id="internals.optree.scratch"
><title
> Scatchpads and Targets </title><para
>      PP code is the guts of Perl execution, and hence is highly
      optimized for speed. One thing that you don't want to do in
      time-critical areas is create and destroy SVs, because
      allocating and freeing memory is a slow process. So Perl
      allocates for each op a <firstterm
>target</firstterm> SV which
      is created at compile time. We've seen above that PP code gets
      the target and uses the <literal
moreinfo="none"
>PUSH</literal> macros to push
      the target onto the stack. 
    </para><para
>      Targets live on the scratchpad, just like lexical
      variables. <literal
moreinfo="none"
>op_targ</literal> for an op is an offset in
      the current pad; it is the element number in the pad's
      array which stores the SV that should be used as the
      target. Perl arranges that ops can reuse the same target if they
      are not going to collide on the stack; similarly, it also
      directly uses lexical variables on the pad as targets if
      appropriate instead of going through a <literal
moreinfo="none"
>padsv</literal>
      operation to extract them. (This is a standard compiler
      technique called "binding".)
    </para><para
>      You can tell if an SV is a target by its flags: targets (also
      known as temporaries) have the <literal
moreinfo="none"
>TEMP</literal> flag set,
      and SVs bound to lexical variables on the pad have the
      <literal
moreinfo="none"
>PADMY</literal> flag set.
    </para></sect2><sect2
id="internals.optree.optimize"
><title
> The Optimizer </title><para
>      Between compiling the op tree and executing it, Perl goes
      through three stages of optimization.
    </para><para
>      The first stage actually happens as the tree is being
      constructed. Once Perl creates an op, it passes it off to a
      check routine. We saw above how the check routines are assigned
      to operators in the op table; an <literal
moreinfo="none"
>index</literal> op
      will be passed to <literal
moreinfo="none"
>ck_index</literal>. This routine may
      manipulate the op in any way it pleases, including freeing it,
      replacing it with a different op, or adding new ops above or
      below it. They are sometimes called in a chain: for instance,
      the check routine for <literal
moreinfo="none"
>index</literal> simply tests to
      see if the string being sought is a constant, and if so,
      performs a Fast Boyer-Moore string compilation to speed up the
      search at runtime; then it calls the general function-checking
      routine <function
moreinfo="none"
>ck_fun</function>. 
    </para><para
>      Secondly, the constant folding routine
      <function
moreinfo="none"
>fold_constants</function> is called if
      appropriate. This tests to see whether all of the descendents of
      the op are constants, and if they are, runs the operator as if
      it was a little program, collects the result and replaces the op
      with a constant op reflecting that result. You can tell if
      constants have been folded by using the "deparse" compiler
      backend (see <xref
linkend="compiler.deparse"
></xref>):
      <screen
format="linespecific"
><prompt
moreinfo="none"
> %</prompt> <userinput
moreinfo="none"
>perl -MO=Deparse -e 'print (3+5+8+$foo)'</userinput>
<computeroutput
moreinfo="none"
>print 16 + $foo;
	</computeroutput></screen>
      Here, the <literal
moreinfo="none"
>3+5</literal> has been constant-folded into
      <literal
moreinfo="none"
>8</literal>, and then <literal
moreinfo="none"
>8+8</literal> is
      constant-folded to 16.
    </para><para
>      Finally, the peephole optimizer <function
moreinfo="none"
>peep</function> is
      called. This examines each op in the tree in execution order,
      and attempts to determine "local" optimizations by "thinking
      ahead" one or two ops and seeing if multiple operations can be
      combined into one. It also checks for lexical issues such as the
      effect of <literal
moreinfo="none"
>use strict</literal> on bareword constants.
    </para></sect2><sect2
><title
>Summary</title><para
>      Perl's fundamental operations are represented by a series of
      structures, analogous to the structures which make up Perl's
      internal values. These ops are threaded together in two ways -
      firstly, into an op tree during the parsing process, where each
      op dominates its arguments, and secondly, by a thread of
      execution which establishes the order in which Perl has to run
      the ops.
    </para><para
>      To run the ops, Perl uses the code in
      <filename
moreinfo="none"
>pp*.c</filename>, which is particularly
      macro-heavy. Most of the macros are concerned with manipulating
      the argument stack, which is the means by which Perl passes data
      between operations.
    </para><para
>      Once the op tree is constructed, there are a number of means by
      which it is optimized - check routines and constant folding
      which takes place after each op is created, and a peephole
      optimizer which performs a "dry run" over the execution order.
    </para></sect2></sect1><sect1
id="internals.execution"
><title
> Execution </title><para
>      Once we have constructed an op code tree from a program,
      executing the code is a simple matter of following the chain of
      <varname
>op_next</varname> pointers, and executing the
      operations specified by each op. The code which does this is in
      <filename
moreinfo="none"
>run.c</filename>:

<programlisting
format="linespecific"
>    while ((PL_op = CALL_FPTR(PL_op-&gt;op_ppaddr)(aTHX))) {
        PERL_ASYNC_CHECK();
    }</programlisting>

      That's to say, we start with the first op,
      <varname
>PL_op</varname>, and we call the function in its
      <varname
>op_ppaddr</varname> slot. This will return another op,
      which we assign to <varname
>PL_op</varname>, or a null pointer
      meaning the end of the program. In between executing ops, we
      perform the "asynchronous check", which despatches signal
      handlers and other events which may occur between operations.
    </para><para
>      As we know from looking at XS programming, Perl keeps values
      between operations on the argument stack. The job of ops is to
      manipulate the arguments on the stack. For instance, the
      <literal
moreinfo="none"
>add</literal> operator is implemented like this: (in
      <filename
moreinfo="none"
>pp_hot.c</filename>)
      <programlisting
format="linespecific"
>PP(pp_and)
{
    dSP;
    if (!SvTRUE(TOPs))
        RETURN;
    else {
        --SP;
        RETURNOP(cLOGOP-&gt;op_other);
    }
}</programlisting>
      If the SV on the top of the argument stack does not have a true
      value, then the <literal
moreinfo="none"
>and</literal> cannot be true, so we
      simply return the next op in the sequence. We don't even need to
      look at the right hand side of the <literal
moreinfo="none"
>and</literal>. If it
      is true, however, we can discard it by popping the stack and we
      need to execute the right hand side (stored in
      <varname
>op_other</varname>) to determine whether that is true
      as well. Hence, we return the chain of operations starting at
      <varname
>op_other</varname>; the <varname
>op_next</varname>
      pointers of these operations will be arranged so as to meet up
      with the operation after <varname
>and</varname>.
    </para></sect1><sect1
id="internals.compiler"
><title
> The Perl Compiler</title><para
>    We'll finish off our tour of the perl internals by discussing the
    oft misunderstood Perl compiler.
  </para><sect2
><title
>What is the Perl Compiler?</title><para
>      In 1996, someone announced a challenge - the first person to
      write a compiler suite for Perl would win a laptop. Malcolm
      Beattie stepped up to the challenge, and won the laptop with his
      <classname
>B</classname> suite of modules. Many of these modules
      have now been brought into the Perl core as standard modules.
    </para><para
>      The Perl compiler is not just for compiling Perl code to a
      standalone executable - in fact, some would argue that it's not
      <emphasis
>at all</emphasis> for compiling Perl into a standalone
      executable. We've already seen the use of the
      <classname
>B::Terse</classname> and
      <classname
>B::Tree</classname> modules to help us visualise the
      Perl op tree, and this should give us a hint as to what the Perl
      compiler is actually all about.
    </para><para
>      The compiler comes in three parts: a frontend module,
      <classname
>O</classname>, which does little other than turn on
      Perl's <literal
moreinfo="none"
>-c</literal> (compile only, do not run) flag,
      and loads up a backend module, such as
      <classname
>B::Terse</classname> which performs a specific
      compiler task, and the <classname
>B</classname> module which
      acts as a low-level driver.
    </para><para
>      The <classname
>B</classname>, at the heart of the compiler, is a
      stunningly simple XS module which makes Perl's internal
      object-like structures - SVs, ops, and so on - into real
      Perl-space objects. This provides us with a degree of
      introspection: we can, for instance, write a backend module
      which traverses the op tree of a compiled program and dump out
      its state to a file. (This is exactly what the
      <classname
>B::Bytecode</classname> module does.)
    </para><para
>      It's important to know what the Perl compiler is not. It's not
      something which will magically make your code go faster, or take
      up less space, or be more reliable. The backends which generate
      standalone code generally do exactly the opposite. All the
      compiler is, essentially, is a way of getting access to the op
      tree and doing something potentially interesting with it. Let's
      now take a look at some of the interesting things that can be
      done with it.
    </para></sect2><sect2
><title
><classname
>B::</classname> Modules</title><para
>      There are twelve backend modules to the compiler in the Perl
      core, and many more besides on CPAN. Here we'll briefly examine
      those which are particularly helpful to internals hackers or
      particularly interesting.
    </para><sect3
><title
><classname
>B::Concise</classname></title><para
>	<classname
>B::Concise</classname> was written quite recently
	by Stephen McCamant to provide a generic way of getting
	concise information about the op tree. It is highly
	customizable, and can be used to emulate
	<classname
>B::Terse</classname> and
	<classname
>B::Debug</classname>. (see below)
      </para><para
>	Here's the basic output from <classname
>B::Concise</classname>:
	  <screen
format="linespecific"
>	    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -MO=Concise -e 'print $a+$b'</userinput>
1r &lt;@&gt; leave[t1] vKP/REFC -&gt;(end)
1k    &lt;0&gt; enter -&gt;1l
1l    &lt;;&gt; nextstate(main 7 -e:1) v -&gt;1m
1q    &lt;@&gt; print vK -&gt;1r
1m       &lt;0&gt; pushmark s -&gt;1n
1p       &lt;2&gt; add[t1] sK/2 -&gt;1q
-           &lt;1&gt; ex-rv2sv sK/1 -&gt;1o
1n             &lt;$&gt; gvsv(*a) s -&gt;1o
-           &lt;1&gt; ex-rv2sv sK/1 -&gt;1p
1o             &lt;$&gt; gvsv(*b) s -&gt;1p</screen>
      </para><para
>	Each line consists of five main parts:
	<itemizedlist
><listitem
><para
>	      a label for this operator (in this case, <literal
moreinfo="none"
>1r</literal>)
	    </para></listitem><listitem
><para
>	      a type signifier (<literal
moreinfo="none"
>@</literal> is a list operator - think
	      arrays)
	    </para></listitem><listitem
><para
>	      the name of the op and its target, if any, plus any other information
	      about it
	    </para></listitem><listitem
><para
>	      the flags for this operator. Here, <literal
moreinfo="none"
>v</literal>
	      signifies void context and <literal
moreinfo="none"
>K</literal> shows
	      that this operator has children. The private flags are
	      shown after the slash, and are written out as a longer
	      abbreviation than just one character:
	      <literal
moreinfo="none"
>REFC</literal> shows that this op is
	      refcounted.
	    </para></listitem><listitem
><para
>	      finally, the label for the next operator in the tree, if there
	      is one.
	    </para></listitem></itemizedlist>		
      </para><para
>	Note also that, for instance, ops which have been optimized
	away to a null are left as "ex-...". The exact meanings of the
	flags and the op classes are given in the
	<classname
>B::Concise</classname> documentation:
	<programlisting
format="linespecific"
>=head2 OP flags abbreviations

    v      OPf_WANT_VOID    Want nothing (void context)
    s      OPf_WANT_SCALAR  Want single value (scalar context)
    l      OPf_WANT_LIST    Want list of any length (list context)
    K      OPf_KIDS         There is a firstborn child.
    P      OPf_PARENS       This operator was parenthesized.
                             (Or block needs explicit scope entry.)
    R      OPf_REF          Certified reference.
                             (Return container, not containee).
    M      OPf_MOD          Will modify (lvalue).
    S      OPf_STACKED      Some arg is arriving on the stack.
    *      OPf_SPECIAL      Do something weird for this op (see op.h)

=head2 OP class abbreviations

    0      OP (aka BASEOP)  An OP with no children
    1      UNOP             An OP with one child
    2      BINOP            An OP with two children
    |      LOGOP            A control branch OP
    @      LISTOP           An OP that could have lots of children
    /      PMOP             An OP with a regular expression
    $      SVOP             An OP with an SV
    "      PVOP             An OP with a string
    {      LOOP             An OP that holds pointers for a loop
    ;      COP              An OP that marks the start of a statement</programlisting>
      </para><para
>	As with many of the debugging <classname
>B::</classname>
	modules, you can use the <literal
moreinfo="none"
>-exec</literal> flag to
	walk the op tree in execution order, following the chain of
	<varname
>op_next</varname>'s from the start of the tree:
	  <screen
format="linespecific"
>	    <prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -MO=Concise,-exec -e 'print $a+$b'</userinput>
1k &lt;0&gt; enter 
1l &lt;;&gt; nextstate(main 7 -e:1) v
1m &lt;0&gt; pushmark s
1n &lt;$&gt; gvsv(*a) s
1o &lt;$&gt; gvsv(*b) s
1p &lt;2&gt; add[t1] sK/2
1q &lt;@&gt; print vK
1r &lt;@&gt; leave[t1] vKP/REFC
-e syntax OK
	</screen>
      </para><para
>	Amongst other options, (again, see the documentation)
	<classname
>B::Concise</classname> supports a
	<literal
moreinfo="none"
>-tree</literal> option for tree-like ASCII art
	graphs, and the curious but fun <literal
moreinfo="none"
>-linenoise</literal> option.
      </para></sect3><sect3
><title
><classname
>B::Debug</classname></title><para
>	<classname
>B::Debug</classname> dumps out
	<emphasis
>all</emphasis> of the information in the op tree;
	for anything bigger than a trivial program, this is just way
	too much information. Hence, to sensibly make use of it, it's
	a good idea to go through with <classname
>B::Terse</classname>
	or <classname
>B::Concise</classname> first, and find which ops
	you're interested in, and then grep for them. 
      </para><para
>	Some output from <classname
>B::Debug</classname> looks like
	this:

	<programlisting
format="linespecific"
>LISTOP (0x81121a8)
        op_next         0x0
        op_sibling      0x0
        op_ppaddr       PL_ppaddr[OP_LEAVE]
        op_targ         1
        op_type         178
        op_seq          6433
        op_flags        13
        op_private      64
        op_first        0x81121d0
        op_last         0x8190498
        op_children     3
OP (0x81121d0)
        op_next         0x81904c0
        op_sibling      0x81904c0
        op_ppaddr       PL_ppaddr[OP_ENTER]
        op_targ         0
        op_type         177
        op_seq          6426
        op_flags        0
        op_private      0</programlisting>

	As you should know from the ops chapter, this is all the
	information contained in the op structure: the type of op and
	its address, the ops related to it, the C function pointer
	implementing the PP function, the target on the scratchpad
	this op uses, its type, sequence number, and public and
	private flags. It also does similar dumps for SVs. You may
	find the <classname
>B::Flags</classname> module useful for
	"Englishifying" the flags.
      </para></sect3><sect3
id="compiler.deparse"
><title
><classname
>B::Deparse</classname></title><para
>	<classname
>B::Deparse</classname> takes a Perl program and
	turns it into a Perl program. This doesn't sound very
	impressive, but it actually does so by decompiling the op tree
	back into Perl. While this has interesting uses for things
	like serializing subroutines, it's interesting for internals
	hackers because it shows us how Perl understands certain
	constructs. For instance, we can see that logical operators
	and binary "if" are equivalent:

	<screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
> perl -MO=Deparse -e '$a and do {$b}'</userinput>
<computeroutput
moreinfo="none"
>if ($a) {
    do {
        $b;
    };
}
-e syntax OK</computeroutput></screen>

	We can also see, for instance, how the magic that is added by
	command line switches goes into the op tree:

	<screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -MO=Deparse -ane 'print'</userinput>
<computeroutput
moreinfo="none"
>LINE: while (defined($_ = &lt;ARGV&gt;)) {
    @F = split(" ", $_, 0);
    print $_;
}
-e syntax OK</computeroutput></screen>
      </para></sect3></sect2><sect2
><title
>What <classname
>B</classname> and <classname
>O</classname>
    Provide</title><para
>      To see how we can built compilers and introspective modules with
      <classname
>B</classname>, we need to see what
      <classname
>B</classname> and the compiler front-end
      <classname
>O</classname> give us. We'll start with
      <classname
>O</classname>, since it's simpler.
    </para><sect3
><title
><classname
>O</classname></title><para
>	The guts of the <classname
>O</classname> module are very small
	- only 48 lines of code - because all it intends to do is set
	up the environment ready for a back-end module. The back-ends
	are expected to provide a subroutine called
	<function
moreinfo="none"
>compile</function> which processes the options that
	are passed to it and then returns a subroutine reference which
	does the actual compilation. <classname
>O</classname> then
	calls this subroutine reference in a CHECK block.
      </para><para
>	CHECK blocks were specifically designed for the compiler -
	they're called after Perl has finished constructing the op
	tree and before it starts running the
	code. <classname
>O</classname> calls the
	<classname
>B</classname> subroutine
	<function
moreinfo="none"
>minus_c</function> which, as its name implies, is
	equivalent to the command-line <literal
moreinfo="none"
>-c</literal> flag to
	perl: compile but do not execute the code. It then ensures
	that any BEGIN blocks are accessible to the back-end modules,
	and then calls <function
moreinfo="none"
>compile</function> from the back-end
	processor with any options from the command line.
      </para></sect3><sect3
><title
><classname
>B</classname></title><para
>	As we have mentioned, the B module allows Perl-level access to
	ops and internal variables. There are two key ways to get this
	access: from the op tree, or from a user-specified Perl "thing".
      </para><para
>	To get at the op tree, <classname
>B</classname> provides the
	<function
moreinfo="none"
>main_root</function> and
	<function
moreinfo="none"
>main_start</function> functions. These return
	<classname
>B::OP</classname>-derived objects representing the
	root of the op tree and the start of the tree in execution order
	respectively:
	<screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
> perl -MB -le 'print B::main_root; print B::main_start'</userinput>
<computeroutput
moreinfo="none"
>B::LISTOP=SCALAR(0x8104180)
B::OP=SCALAR(0x8104180)</computeroutput>
	</screen>
      </para><para
>	For everything else, you can use the
	<function
moreinfo="none"
>svref_2object</function> function which turns some
	kind of reference into the appropriate
	<classname
>B::SV</classname>-derived object:
	<screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
> perl -MB -l
	  $a = 5; print B::svref_2object(\$a); 
	  @a=(1,2,3); print B::svref_2object(\@a);
	  </userinput>
	  <computeroutput
moreinfo="none"
>B::IV=SCALAR(0x811f9b8)
B::AV=SCALAR(0x811f9b8)
	  </computeroutput>
	</screen>
	(Yes, it's normal that the objects will have the same addresses.)
      </para><para
>	In this tutorial we'll concentrate on the op-derived classes,
	because they're the most useful feature of
	<classname
>B</classname> for compiler construction; the SV
	classes are a lot simpler and quite analogous.
      </para></sect3></sect2><sect2
><title
>Using <classname
>B</classname> for Simple Things</title><para
></para><para
>      OK, so now we have the objects - what can we do with them?
      <classname
>B</classname> provides accessor methods similar to
      the fields of the structures in <filename
moreinfo="none"
>op.h</filename> and
      <filename
moreinfo="none"
>sv.h</filename>. For instance, we can find out the
      type of the root op like this:
<screen
format="linespecific"
><userinput
moreinfo="none"
>$op=B::main_root; print $op-&gt;type;</userinput>
<computeroutput
moreinfo="none"
>178</computeroutput></screen>
      Oops: <varname
>op_type</varname> is actually an enum, so we
      can't really get much from looking at that directly; however,
      <classname
>B</classname> also gives us the
      <function
moreinfo="none"
>name</function> method, which is a little friendlier:
<screen
format="linespecific"
><userinput
moreinfo="none"
>$op=B::main_root; print $op-&gt;name;</userinput>
<computeroutput
moreinfo="none"
>leave</computeroutput></screen>
      We can also use <function
moreinfo="none"
>flags</function>,
      <function
moreinfo="none"
>private</function>, <function
moreinfo="none"
>targ</function>, and so
      on - in fact, everything we saw prefixed by
      <function
moreinfo="none"
>op_</function> in the <classname
>B::Debug</classname>
      example above. 
    </para><para
>      What about traversing the op tree, then? You should be happy to
      learn that <function
moreinfo="none"
>first</function>,
      <function
moreinfo="none"
>sibling</function>, <function
moreinfo="none"
>next</function> and
      friends return the <classname
>B::OP</classname> object for the
      related op. That's to say, you can follow the op tree in
      execution order by doing something like this:
<programlisting
format="linespecific"
>#!/usr/bin/perl -cl
use B; 
CHECK { 
	  $op=B::main_start; 
	  print $op-&gt;name while $op=$op-&gt;next;
} 

print $a+$b;
...
      </programlisting>
    </para><para
>      Except that's not quite there; when you get to the last op in
      the sequence, the "enter" at the root of the tree,
      <function
moreinfo="none"
>op_next</function> will be a null
      pointer. <classname
>B</classname> represents a null pointer by
      the <classname
>B::NULL</classname> object, which has no
      methods. This has the handy property that if
      <varname
>$op</varname> is a <classname
>B::NULL</classname>, then
      <varname
>$$op</varname> will be zero. So we can print the name
      of each op in execution order by saying:
      <programlisting
format="linespecific"
>	  $op=B::main_start; 
	  print $op-&gt;name while $op=$op-&gt;next and $$op;</programlisting>
    </para><para
>      Walking the tree in normal order is a bit more tricky, since we
      have to make the right moves appropriate for each type of op: we
      need to look at both <varname
>first</varname> and
      <varname
>last</varname> links from binary ops, for instance, but
      only the <varname
>first</varname> from a unary op. Thankfully,
      <classname
>B</classname> provides a function which does this all
      for us: <function
moreinfo="none"
>walkoptree_slow</function>. This arranges to
      call a user-specified method on each op in turn. Of course, to
      make it useful, we have to define the method...
    <programlisting
format="linespecific"
>#!/usr/bin/perl -cl
use B; 
CHECK { 
      B::walkoptree_slow(B::main_root, "print_it", 0); 
      sub B::OP::print_it { my $self = shift; print $self-&gt;name }
} 

print $a+$b;
...</programlisting>
      Since all ops inherit from <classname
>B::OP</classname>, this
      duly produces:
<screen
format="linespecific"
><computeroutput
moreinfo="none"
>leave
enter
nextstate
print
pushmark
add
null
gvsv
null
gvsv
     </computeroutput>
      </screen>
      We can also use the knowledge that
      <function
moreinfo="none"
>walkoptree_slow</function> passes the recursion level
      as a parameter to the callback method, and prettify the tree a
      little, like this:
<programlisting
format="linespecific"
>      sub B::OP::print_it {
          my ($self,$level)=@_;
          print "    "x$level, $self-&gt;name
      }
      </programlisting>
<screen
format="linespecific"
><computeroutput
moreinfo="none"
>leave
    enter
    nextstate
    print
        pushmark
        add
            null
                gvsv
            null
                gvsv
      </computeroutput>
    </screen>
      See how we're starting to approximate
      <classname
>B::Terse</classname>? Actually,
      <classname
>B::Terse</classname> uses the
      <function
moreinfo="none"
>B::peekop</function> function, a little like this:
<programlisting
format="linespecific"
>      sub B::OP::print_it {
          my ($self,$level)=@_;
          print "    "x$level, B::peekop($self);
      }
      </programlisting>
<screen
format="linespecific"
><computeroutput
moreinfo="none"
>LISTOP (0x81142c8) leave
    OP (0x81142f0) enter
    COP (0x8114288) nextstate
    LISTOP (0x8114240) print
        OP (0x8114268) pushmark
        BINOP (0x811d920) add
            UNOP (0x8115840) null
                SVOP (0x8143158) gvsv
            UNOP (0x811d900) null
                SVOP (0x8115860) gvsv
      </computeroutput>
      </screen>
      All that's missing is that <classname
>B::Terse</classname>
      provides slightly more information based on each different type
      of op, and that can be easily done by putting methods in the
      individual op classes: <classname
>B::LISTOP</classname>,
      <classname
>B::UNOP</classname> and so on.
    </para><para
>      Let's
      finish off our little compiler - let's call it
      <classname
>B::Simple</classname> - by turning it into a module
      that can be used from the <classname
>O</classname>
      front-end. This is easy enough to do in our case, once we
      remember that <function
moreinfo="none"
>compile</function> has to return a
      callback subroutine reference:
      <programlisting
format="linespecific"
>package B::Simple;
use B qw(main_root peekop walkoptree_slow);

sub B::OP::print_it {
    my ($self,$level)=@_;
    print "    "x$level, peekop($self);
}

sub compile {
    return sub { walkoptree_slow(main_root, "print_it", 0); }
}

1;</programlisting>
      If we save the above code as <filename
moreinfo="none"
>B/Simple.pm</filename>,
      we can run it on our own programs with <userinput
moreinfo="none"
>perl
	-MO=Simple ...</userinput>. We have a backend compiler module!
    </para></sect2></sect1><sect1
><title
>Summary</title><para
>      In our whirlwind tour of the Perl internals, we've looked at
      where to find things in the Perl source tree, the outline of the
      process that Perl goes through to execute a program, how the
      parser and tokeniser work, as well as the way that Perl's
      fundamental operations are coded. Finally, we've examined the
      Perl compiler; how to use it to debug Perl programs, and how to
      write compiler modules.
    </para><para
>      Hopefully, we've given you enough information about how the Perl
      internals work so that if you want to investigate Perl's
      behaviour, you'll now have some idea where to start digging into
      the source. If you want a more gentle introduction to the Perl
      internals than this chapter, you can take a look at the
      <filename
moreinfo="none"
>perlhack</filename> documentation which comes with
      Perl, or the extended <ulink
url="http://www.netthink.co.uk/downloads/internals/book.html"
>Perl
      Internals tutorial</ulink>. If you want to dive into the deep
      end, <filename
moreinfo="none"
>perlguts</filename> in the Perl documentation
      tells you far more than you needed to know about Perl's internals.
    </para></sect1></chapter><chapter
><title
>Hacking Perl</title><para
>Perl, just like any other piece of software, is not a finished
product; Perl is still being developed, and has a lively development
community. Both of the authors are regular contributors to Perl, and
we'd like to encourage you to get think about getting involved with
Perl's continued maintainance and development. This chapter will tell
you what you need to know to start. </para><sect1
><title
>The Development Process</title><sect2
><title
>Perl Versioning</title><para
>Perl has two types of version number: versions before 5.6.0 used a
number of the form <literal
moreinfo="none"
>x.yyy_zz</literal>; <literal
moreinfo="none"
>x</literal>
was the major version number, (Perl 4, Perl 5) <literal
moreinfo="none"
>y</literal> was
the minor release number, and <literal
moreinfo="none"
>z</literal> was the patchlevel.
Major releases represented, for instance, either a complete rewrite or a
major upheaval of the internals; minor releases sometimes added
non-essential functionality, and releases changing the patchlevel were
primarily to fix bugs. Releases where <literal
moreinfo="none"
>z</literal> was 50 or
more were unstable, developers' releases working towards the next minor
release.</para><para
>Now, since, 5.6.0, Perl uses the more standard open source version
numbering system - version numbers are of the form
<literal
moreinfo="none"
>x.y.z</literal>; releases where <literal
moreinfo="none"
>y</literal> is
even are stable releases, and releases where it is odd are part of the
<firstterm
>development track</firstterm>.</para></sect2><sect2
><title
>The Development Tracks</title><para
>Perl development has four major aims: extending portability, fixing
bugs, optimizations, and adding language features. Patches to Perl are
usually made against the latest copy of the development release; the
very latest copy, stored in the Perl repository (see <xref
linkend="perlrep"
></xref> below) is usually called `bleadperl'.</para><para
>The bleadperl eventually becomes the new minor release, but patches
are also picked up by the maintainer of the stable release for
inclusion.  While there are no hard and fast rules, and everything is
left to the discretion of the maintainer, in general, patches which
are bug fixes or address portability concerns (which include taking
advantage of new features in some platforms, such as large file
support or 64 bit integers) are merged into the stable release as
well, whereas new language features tend to be left until the next
minor release. Optimizations may or may not be included, depending on
their impact on the source.</para></sect2><sect2
><title
>Perl 5 Porters</title><para
>All Perl development goes on on the <literal
moreinfo="none"
>perl5-porters</literal>
mailing list; if you are planning to get involved, a subscription to
this is essential. </para><para
>You can subscribe by sending an email to
<literal
moreinfo="none"
>perl5-porters-subscribe@perl.org</literal>; you'll be asked
to send an email to confirm, and then you should start receiving mail
from the list. To send mail, to the list, address the mail to
<literal
moreinfo="none"
>perl5-porters@perl.org</literal>; you don't have to be
subscribed to post, and the list is not moderated. If, for whatever reason,
you decide to unsubscribe, simply mail
<literal
moreinfo="none"
>perl5-porters-unsubscribe@perl.org</literal>.</para><para
>The list usually receives between 200 and 400 mails a week. If this is
too much for you, you can subscribe instead to a daily digest service
by mailing <literal
moreinfo="none"
>perl5-porters-digest-subscribe@perl.org</literal>.</para><para
>There is also a <ulink
url="http://simon-cozens.org/writings/p5p.faq"
><literal
moreinfo="none"
>perl5-porters</literal>
FAQ</ulink> which explains a lot of this, plus more about how to
behave on P5P and how to submit patches to Perl.</para></sect2><sect2
><title
>Pumpkins and Pumpkings</title><para
>Development is very loosely organised around the release managers of
the stable and the development tracks; these are the two
``pumpkings''.</para><para
>Perl development can also be divided up into several smaller
sub-systems: the regular expression engine, the configuration process,
the documentation, and so on. Responsibility for each of these areas
is known as a ``pumpkin'', and hence those who semi-officially take
responsibility for are called ``pumpkings''.</para><para
>You're probably wondering why the silly names. It stems from the days
before Perl was kept under version control, and people had to manually
`check out' a chunk of the Perl source to avoid conflicts by
announcing their intentions to the mailing list; while they were
discussing what this should be called, one of Chip Salzenburg's
co-workers told him about a system they had used for preventing two
people using a tape drive at once: there was a stuffed pumpkin in the
office, and nobody could use the drive unless they had the pumpkin.</para></sect2><sect2
id="perlrep"
><title
>The Perl Repository</title><para
>Now Perl is kept in a version control system called <ulink
url="http://www.perforce.com/"
>Perforce</ulink>, which is hosted by
ActiveState, Inc. There is no public access to the system itself, but
various methods have been devised to allow developers near-realtime
access. </para><para
>Firstly, there is the 
<ulink
url="ftp://ftp.linux.activestate.com/pub/staff/gsar/APC/"
>Archive
of Perl Changes.</ulink> This FTP site contains both the current state
of all the maintained Perl versions, and also a directory of changes
made to the repository.</para><para
>Since it's a little inconvenient to keep up to date using FTP, the
directories are also available via the software synchronisation
protocol <ulink
url="http://rsync.samba.org/"
>rsync</ulink>. If you
have <command
moreinfo="none"
>rsync</command> installed, you can synchronise your
working directory with bleadperl by issuing the command

<screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>rsync -avz rsync://ftp.linux.activestate.com/perl-current/ .</userinput></screen></para><sidebar
><para
>	  If you use this route, you should periodically add the
	  <option
>--delete</option> option to <command
moreinfo="none"
>rsync</command>
	  to clean out any files which have been deleted from the
	  repository. Once, a proposed feature and its test were both
	  removed from Perl, and those following bleadperl by rsync
	  reported test failures for a test which no longer existed.
	</para></sidebar><para
>There are also periodic snapshots of bleadperl released by the
development pumpking, particularly when some important change
happens. These are usually available from a variety of URLs, and
always from <ulink
url="ftp://ftp.funet.fi/pub/languages/perl/snap/"
></ulink>.</para></sect2></sect1><sect1
><title
>Debugging Aids</title><para
>There are a number of tools available to developers to help them find
and examine bugs in Perl; these tools are, of course, also useful to
those creating XS extensions and applications with embedded
Perl. There are four major categories: Perl modules such as
<classname
>Devel::Peek</classname> which allow us to get information
about Perl's operation, <literal
moreinfo="none"
>perl</literal>'s own debugging mode,
convenience functions built into <literal
moreinfo="none"
>perl</literal> that we can call to get
debugging information, and external applications.</para><sect2
><title
>Debugging Modules</title><para
>We've already seen in Chapter 3 how the
<classname
>Devel::Peek</classname> module can dump information about
SVs; we've also seen the <classname
>B::Terse</classname> module for
dumping the op tree. The op tree diagrams in the previous chapter were
produced using the CPAN module <classname
>B::Tree</classname>. There are
other modules which we can use to help us get similar information</para><sect3
><title
>The compiler modules</title><para
>Due to the way the compiler works, we can use it to get at a lot of
information about the op tree. The most extensive information can be
found using the <classname
>B::Debug</classname> module, which dumps
all the fields of all <type
>OP</type>s and <type
>SV</type>s in the op
tree.</para><para
><classname
>B::Deparse</classname> is useful for understanding the
tokeniser - it attempts to turn the op tree back into usable Perl
code. For instance, we can see how <literal
moreinfo="none"
>perl</literal> implements the
<userinput
moreinfo="none"
>-p</userinput> switch by running the following code:

<screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -MO=Deparse -pe 's/2000/2001/g'</userinput>
<computeroutput
moreinfo="none"
>LINE: while (defined($_ = &lt;ARGV&gt;)) {
    s/2000/2001/g;
}
continue {
    print $_;
}</computeroutput></screen></para><para
>Another useful module is <classname
>B::Graph</classname>, which
produces the same information as <classname
>B::Debug</classname>, but
does so in the form of a graph.</para></sect3><sect3
><title
>Other Modules</title><para
>The core module <classname
>re</classname> has a debugging mode,
<userinput
moreinfo="none"
>use re 'debug';</userinput>, which traces the execution of
regular expressions. We can use this, for instance, to examine the
regular expression engine's backtracking behaviour:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -e 'use re "debug"; "aaa" =~/\w+\d/;'</userinput>
<computeroutput
moreinfo="none"
>Compiling REx `\w+\d'
size 4 first at 2
   1: PLUS(3)
   2:   ALNUM(0)
   3: DIGIT(4)
   4: END(0)
stclass `ALNUM' plus minlen 2 
Matching REx `\w+\d' against `aaa'
  Setting an EVAL scope, savestack=3
   0 &lt;&gt; &lt;aaa&gt;             |  1:  PLUS
                           ALNUM can match 3 times out of 32767...
  Setting an EVAL scope, savestack=3
   3 &lt;aaa&gt; &lt;&gt;             |  3:    DIGIT
                              failed...
   2 &lt;aa&gt; &lt;a&gt;             |  3:    DIGIT
                              failed...
   1 &lt;a&gt; &lt;aa&gt;             |  3:    DIGIT
                              failed...
                            failed...
Freeing REx: `\w+\d'</computeroutput></screen><para
>Turning to CPAN, the <classname
>Devel::Leak</classname> module can be
used to detect and trace memory leaks in <literal
moreinfo="none"
>perl</literal>.</para></sect3></sect2><sect2
id="developing.minusd"
><title
>The Built-in Debugger : <literal
moreinfo="none"
>perl -D</literal></title><para
>	If you configure Perl passing the flag
	<userinput
moreinfo="none"
>-Doptimize='-g'</userinput> to
	<literal
moreinfo="none"
>Configure</literal>, it will do two things - first,
	it will tell the C compiler to add special debugging
	information to the object files it produces, and we'll see how
	that's used in a moment, but it will also define the
	preprocessor macro <constant
>DEBUGGING</constant>, which turns
	on some special debugging options.</para><note
><para
>	  If you're running <filename
moreinfo="none"
>Configure</filename> manually,
	  you can turn on debugging in the following way:
<screen
format="linespecific"
><computeroutput
moreinfo="none"
>By default, perl5 compiles with the -O flag to use the optimizer.
Alternately, you might want to use the symbolic debugger, which uses
the -g flag (on traditional Unix systems).  Either flag can be
specified here.  To use neither flag, specify the word "none".

What optimizer/debugger flag should be used? [-O2] </computeroutput><userinput
moreinfo="none"
>-g</userinput></screen></para></note><para
>This allows us to use the <userinput
moreinfo="none"
>-D</userinput> flag on the <literal
moreinfo="none"
>perl</literal>
command line to select the level of debugging we require. The most
useful debugging options are as follows:</para><sect3
><title
><userinput
moreinfo="none"
>-Ds</userinput></title><para
>This turns on stack snapshots, printing a summary of what's on the
argument stack each time an operation is performed; this is not
<emphasis
>too</emphasis> useful on its own, but is highly recommended
when combined with the <userinput
moreinfo="none"
>-Dt</userinput> switch. Here we can
see how Perl builds up lists by putting successive values onto the
stack, and performs array assignment:</para><screenco
><areaspec
><area
coords="9"
id="ds.1"
></area><area
coords="12"
id="ds.2"
></area><area
coords="13"
id="ds.3"
></area><area
coords="14"
id="ds.4"
></area><area
coords="15"
id="ds.5"
></area></areaspec><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Ds -e '@a = (1,2,3)'</userinput>

EXECUTING...

    =&gt;  
    =&gt;  
    =&gt;  
    =&gt;  *  
    =&gt;  *  IV(1)  
    =&gt;  *  IV(1)  IV(2)  
    =&gt;  *  IV(1)  IV(2)  IV(3)  
    =&gt;  *  IV(1)  IV(2)  IV(3)  *  
    =&gt;  *  IV(1)  IV(2)  IV(3)  *  GV()  
    =&gt;  *  IV(1)  IV(2)  IV(3)  *  AV()  
    =&gt;  </screen><calloutlist
><callout
arearefs="ds.1"
><para
>Perl pushes each of the values of the list onto the argument
stack. The asterisk before the list represents an entry in the mark stack.</para></callout><callout
arearefs="ds.2"
><para
>Once the list has been built up, Perl places another mark between the
right hand side of an assignment and the left hand side, so it knows
how many elements are due for assignment.</para></callout><callout
arearefs="ds.3"
><para
>The array is first placed on the stack as a glob, an entry into the
symbol table.</para></callout><callout
arearefs="ds.4"
><para
>The <function
moreinfo="none"
>rv2av</function> operator resolves the glob into an
<type
>AV</type>.</para></callout><callout
arearefs="ds.5"
><para
>Finally, once the assignment has been made, everything from the first
mark is popped off the stack.</para></callout></calloutlist></screenco></sect3><sect3
><title
><userinput
moreinfo="none"
>-Dt</userinput></title><para
>This option traces each individual op as it is executed. Let's see the
code above again, but this time with a listing of the ops:</para><screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl -Dst -e '@a = (1,2,3)'</userinput>
<computeroutput
moreinfo="none"
>
EXECUTING...

    =&gt;  
(-e:0)  enter
    =&gt;  
(-e:0)  nextstate
    =&gt;  
(-e:1)  pushmark
    =&gt;  *  
(-e:1)  const(IV(1))
    =&gt;  *  IV(1)  
(-e:1)  const(IV(2))
    =&gt;  *  IV(1)  IV(2)  
(-e:1)  const(IV(3))
    =&gt;  *  IV(1)  IV(2)  IV(3)  
(-e:1)  pushmark
    =&gt;  *  IV(1)  IV(2)  IV(3)  *  
(-e:1)  gv(main::a)
    =&gt;  *  IV(1)  IV(2)  IV(3)  *  GV()  
(-e:1)  rv2av
    =&gt;  *  IV(1)  IV(2)  IV(3)  *  AV()  
(-e:1)  aassign
    =&gt;  
(-e:1)  leave</computeroutput></screen></sect3><sect3
><title
><userinput
moreinfo="none"
>-Dr</userinput></title><para
>The <userinput
moreinfo="none"
>-Dr</userinput> flag is exactly identical to the
<userinput
moreinfo="none"
>use re 'debug';</userinput> module discussed above.</para></sect3><sect3
><title
><userinput
moreinfo="none"
>-Dl</userinput></title><para
>This option reports when <literal
moreinfo="none"
>perl</literal> reaches an <function
moreinfo="none"
>ENTER</function> or
<function
moreinfo="none"
>LEAVE</function> statement, and reports on which line and in
which file the statement occurred. </para></sect3><sect3
><title
><userinput
moreinfo="none"
>-Dx</userinput></title><para
>This is roughly equivalent to <classname
>B::Terse</classname> - it
produces a dump of the op tree using the <function
moreinfo="none"
>op_dump</function>
function described below. It's a handy compromise between
<classname
>B::Terse</classname> and <classname
>B::Debug</classname>.</para></sect3><sect3
><title
><userinput
moreinfo="none"
>-Do</userinput></title><para
>This turns on reporting of method resolution: that is, what happens
when Perl calls a method on an object or class; it tells you when, for
instance, <methodname
>DESTROY</methodname> methods are called, as well
as what happens during inheritance lookups.</para></sect3></sect2><sect2
><title
>Debugging Functions</title><para
>In addition to this, the Perl core itself defines a number of
functions to aid debugging the internal goings-on. These can either be
called from debugging sections of your own code, or from a source
level debugger. (see below)</para><sect3
><title
><function
moreinfo="none"
>sv_dump</function></title><funcsynopsis
><funcprototype
><funcdef
>void <function
moreinfo="none"
>sv_dump</function></funcdef><paramdef
>SV* sv</paramdef></funcprototype></funcsynopsis><para
>This is roughly equivalent to the <classname
>Devel::Peek</classname>
module - it allows you to inspect any of Perl's data types. The
principle differences between this and
<classname
>Devel::Peek</classname> is that it is not recursive - for
instance, a reference will be dumped like this:

<screen
format="linespecific"
><computeroutput
moreinfo="none"
>SV = RV(0x814fd10) at 0x814ec80
  REFCNT = 1
  FLAGS = (ROK)
  RV = 0x814ec5c</computeroutput></screen>

and its referent is not automatically dumped. However, it does allow
you to get at values that are not attached to a variable, such as
arrays and scalars used to hold data internal to <literal
moreinfo="none"
>perl</literal>.</para></sect3><sect3
><title
><function
moreinfo="none"
>op_dump</function></title><funcsynopsis
><funcprototype
><funcdef
>void <function
moreinfo="none"
>op_dump</function></funcdef><paramdef
>OP* op</paramdef></funcprototype></funcsynopsis><para
>The <userinput
moreinfo="none"
>-Dx</userinput> debugging option is implemented,
essentially, by calling <function
moreinfo="none"
>op_dump(PL_mainroot)</function>. It
takes an op, and lists the op's type, flags, important additional
fields and recursively calls itself on the op's children.</para></sect3><sect3
><title
><function
moreinfo="none"
>dump_sub</function></title><funcsynopsis
><funcprototype
><funcdef
>void <function
moreinfo="none"
>dump_sub</function></funcdef><paramdef
>GV* gv</paramdef></funcprototype></funcsynopsis><para
>This extracts the <type
>CV</type> from a glob and runs
<function
moreinfo="none"
>op_dump</function> on the root of its op tree.</para></sect3></sect2><sect2
><title
>External Debuggers</title><para
>
There's another way to debug your code, which is usually more useful 
when you're fiddling around in C. A <firstterm
>source level
debugger</firstterm> allows you to step through your C code line by
line or function by function, and execute C code on the fly, just like
you'd do with the built-in Perl debugger.</para><para
>Source level debuggers come in many shapes and sizes: if you're
working in a graphical environment such as Microsoft Visual Studio,
you may find that there's a debugging mode built into
it. Just like with compilers, there are also command-line versions,
and we're going to look at another free tool, the GNU Debugger,
(<command
moreinfo="none"
>gdb</command>) although much of what we say will be more or
less applicable to other similar debuggers, such as DDD.</para><sect3
><title
>Compiling for debugging</title><para
>Unfortunately, before you can use the debugger on a C program, you
must compile it with special options. As we've seen above, the
debugging option (usually <option
>-g</option> on command-line
compilers) embeds information into the binary detailing the file name
and line number for each operation, so that the debugger can, for
instance, stop at a specific line in a C source file.</para><para
>So, before using the debugger, you must recompile Perl with the
<userinput
moreinfo="none"
>-Doptimize='-g'</userinput> option to
<filename
moreinfo="none"
>Configure</filename>, as shown in <xref
linkend="developing.minusd"
></xref></para></sect3><sect3
><title
>Invoking the debugger</title><para
>We'll assume you're using <command
moreinfo="none"
>gdb</command>, and you've compiled
Perl with the <option
>-g</option> flag. If you type <userinput
moreinfo="none"
>gdb
perl</userinput> in the directory in which you built Perl, you should
see the following:

<screen
format="linespecific"
><prompt
moreinfo="none"
>% </prompt> <userinput
moreinfo="none"
>gdb perl</userinput>
<computeroutput
moreinfo="none"
>GNU gdb 5.0
Copyright 2000 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i686-pc-linux-gnu"...
(gdb) </computeroutput></screen></para><para
>	  If, however, you see the words <computeroutput
moreinfo="none"
>(no debugging
	  symbols found)</computeroutput>, you're either in the wrong
	  place or you didn't compile Perl with debugging support.</para><para
>	  You can type <userinput
moreinfo="none"
>help</userinput> at any time to get
	  a summary of the commands, or <userinput
moreinfo="none"
>quit</userinput>
	  (or just press
<keycombo
moreinfo="none"
><keycap
moreinfo="none"
>Ctrl</keycap><keycap
moreinfo="none"
>D</keycap></keycombo>) to leave the debugger.</para><para
>	  You can run <literal
moreinfo="none"
>perl</literal> without any intervention from the debugger
	  by simply typing <userinput
moreinfo="none"
>run</userinput>; this is
	  equivalent to executing <literal
moreinfo="none"
>perl</literal> with no command line options,
	  and means that it will take a program from standard input.
	</para><para
>	  To pass command line options to <literal
moreinfo="none"
>perl</literal>, put them after the
	  <userinput
moreinfo="none"
>run</userinput> command, like this:

	  <screen
format="linespecific"
><computeroutput
moreinfo="none"
>(gdb)</computeroutput> <userinput
moreinfo="none"
>run -Ilib -MDevel::Peek -e '$a="X"; $a++; Dump($a)'</userinput>
<computeroutput
moreinfo="none"
>Starting program: /home/simon/patchbay/perl/perl -Ilib -MDevel::Peek -e '$a="X"; $a++; Dump($a)'
SV = PV(0x8146fdc) at 0x8150a18
  REFCNT = 1
  FLAGS = (POK,pPOK)
  PV = 0x8154620 "Y"\0
  CUR = 1
  LEN = 2

Program exited normally.</computeroutput></screen>
	</para></sect3><sect3
><title
>Setting breakpoints</title><para
>	  Running through a program normally isn't very exciting,
	  though. The most important thing you'll want to do is to
	  choose a place to freeze execution of the program, so that
	  you can examine further what's going on at that point.
	</para><para
>	  The <userinput
moreinfo="none"
>break</userinput> command is used to set a
	  breakpoint, a point in the program at which the debugger
	  will halt execution and bring us back to the
	  <computeroutput
moreinfo="none"
>(gdb)</computeroutput> prompt.
	</para><para
>	  <userinput
moreinfo="none"
>break</userinput> can be given either the name of
	  a function, or a location in the source code of the form
	  <userinput
moreinfo="none"
><replaceable
>filename.c</replaceable>:<replaceable
>lineno</replaceable></userinput>. For
	  instance, in the version of Perl installed here, the main op
	  despatch code is at <userinput
moreinfo="none"
>run.c:53</userinput>:

	  <screen
format="linespecific"
><computeroutput
moreinfo="none"
>(gdb)</computeroutput> <userinput
moreinfo="none"
>break run.c:53</userinput>
<computeroutput
moreinfo="none"
>Breakpoint 1 at 0x80ba331: file run.c, line 53.</computeroutput></screen>

	  This sets breakpoint number 1, which will be triggered when
	  execution gets to line 53 of <filename
moreinfo="none"
>run.c</filename>.
	</para><note
><title
>Setting breakpoints</title><para
>	    Blank lines, or lines containing comments or preprocessor
	    directives will never get executed, but if you do set a
	    breakpoint on them, the debugger should stop at the next
	    line containing code. This also applies for sections of
	    code which are <literal
moreinfo="none"
>#ifdef</literal>'d out.
	  </para><para
>	    If you give <userinput
moreinfo="none"
>break</userinput> a function name,
	    be sure to give the name in the <literal
moreinfo="none"
>Perl_</literal>
	    namespace: that is, <function
moreinfo="none"
>Perl_runops_debug</function>
	    instead of <function
moreinfo="none"
>runops_debug</function>.
	  </para></note><para
>	  Now when you use <userinput
moreinfo="none"
>run</userinput>, execution will
	  halt when it gets to the specified place, and
	  <command
moreinfo="none"
>gdb</command> will display the number of the
	  breakpoint that was triggered, and the line of code in
	  question for you:

	  <screen
format="linespecific"
><computeroutput
moreinfo="none"
>(gdb)</computeroutput> <userinput
moreinfo="none"
>run -e1</userinput>
<computeroutput
moreinfo="none"
>Starting program: /home/simon/patchbay/perl/perl -e1

Breakpoint 1, Perl_runops_debug () at run.c:53
53	    } while ((PL_op = CALL_FPTR(PL_op-&gt;op_ppaddr)(aTHX)));</computeroutput></screen>
	</para><para
>	  You can now use the backtrace command,
	  <userinput
moreinfo="none"
>bt</userinput>, to examine the call stack and
	  find out how you got there: (<userinput
moreinfo="none"
>where</userinput> is
	  also available as a synonym for <userinput
moreinfo="none"
>bt</userinput>)
	  <screen
format="linespecific"
><computeroutput
moreinfo="none"
>(gdb)</computeroutput> <userinput
moreinfo="none"
>bt</userinput>
<computeroutput
moreinfo="none"
>#0  Perl_runops_debug () at run.c:53
#1  0x805dc9f in S_run_body (oldscope=1) at perl.c:1458
#2  0x805d871 in perl_run (my_perl=0x8146b98) at perl.c:1380
#3  0x805a4d5 in main (argc=2, argv=0xbffff8cc, env=0xbffff8d8)
    at perlmain.c:52
#4  0x40076dcc in __libc_start_main () from /lib/libc.so.6
	    </computeroutput></screen></para><para
>	  This tells us that we're currently in
	  <function
moreinfo="none"
>Perl_runops_debug</function>, after being called
	  by <function
moreinfo="none"
>S_run_body</function> on line 1380 of
	  <filename
moreinfo="none"
>perl.c</filename>. <command
moreinfo="none"
>gdb</command> also
	  displays the value of the arguments to each function,
	  although many of them (those given as hexadecimal numbers)
	  are pointers.
        </para><para
>	  Execution can be restarted by typing
	  <userinput
moreinfo="none"
>continue</userinput>; if the code containing a
	  breakpoint is executed again, the debugger will halt once
	  more. If not, the program will run until termination.
	</para><para
>	  You may set multiple breakpoints, simply by issuing more
	  <userinput
moreinfo="none"
>break</userinput> commands. If multiple
	  breakpoints are set, the debugger will stop each time
	  execution reaches any of the breakpoints in force.
	</para><para
>	  Unwanted breakpoints can be deleted using the
	  <userinput
moreinfo="none"
>delete</userinput> command; on its own,
	  <userinput
moreinfo="none"
>delete</userinput> will delete all
	  breakpoints. To delete a given breakpoint, use
	  <userinput
moreinfo="none"
>delete <replaceable
>n</replaceable></userinput>
	  where <replaceable
>n</replaceable> is the number of the
	  breakpoint.
	</para><para
>	  To temporarily turn off a breakpoint, use the
	  <userinput
moreinfo="none"
>disable</userinput> and
	  <userinput
moreinfo="none"
>enable</userinput> commands.
	</para><para
>	  Good breakpoints to choose when debugging <literal
moreinfo="none"
>perl</literal> include the
	  main op despatch code shown above,
	  <function
moreinfo="none"
>main</function>,
	  <function
moreinfo="none"
>S_parse_body</function>,
	  <function
moreinfo="none"
>perl_construct</function>,
	  <function
moreinfo="none"
>perl_destruct</function> and
	  <function
moreinfo="none"
>Perl_yyparse</function>. (Not for the faint of heart.)
	</para></sect3><sect3
><title
>Stepping through a program</title><para
>	  While it's perfectly possible to work out the flow of
	  execution just by using breakpoints, it's a lot easier to
	  watch the statements as they get executed. The key commands
	  for this are <userinput
moreinfo="none"
>step</userinput>,
	  <userinput
moreinfo="none"
>next</userinput>, and <userinput
moreinfo="none"
>finish</userinput>.</para><para
>	  <userinput
moreinfo="none"
>step</userinput> traces the flow of execution
	  step by step; let's see what happens when we break at the
	  main op despatch look and step through execution:
	</para><screen
format="linespecific"
><computeroutput
moreinfo="none"
>(gdb)</computeroutput> <userinput
moreinfo="none"
>run -e1</userinput>
<computeroutput
moreinfo="none"
>Starting program: /home/simon/patchbay/perl/perl -e1

Breakpoint 1, Perl_runops_debug () at run.c:53
53	    } while ((PL_op = CALL_FPTR(PL_op-&gt;op_ppaddr)(aTHX)));
(gdb) <userinput
moreinfo="none"
>step</userinput>

Perl_pp_enter () at pp_hot.c:1587
1587	    djSP;
(gdb) <userinput
moreinfo="none"
>step</userinput>
1589	    I32 gimme = OP_GIMME(PL_op, -1);
(gdb)
1591	    if (gimme == -1) {
(gdb)
1592		if (cxstack_ix &gt;= 0)
(gdb)
1595		    gimme = G_SCALAR;</computeroutput></screen><tip
><para
>Pressing <keycap
moreinfo="none"
>Return</keycap> repeats the last command.</para></tip><para
>	  As we <userinput
moreinfo="none"
>step</userinput>ped into the first op,
	  <function
moreinfo="none"
>enter</function>, <command
moreinfo="none"
>gdb</command> loaded up
	  <filename
moreinfo="none"
>pp_hot.c</filename> and entered
	  <function
moreinfo="none"
>Perl_pp_enter</function> function. The function in
	  question begins like this:
	  <programlisting
format="linespecific"
>  1585  PP(pp_enter)
  1586  {
  1587      djSP;
  1588      register PERL_CONTEXT *cx;
  1589      I32 gimme = OP_GIMME(PL_op, -1);
  1590  
  1591      if (gimme == -1) {
  1592          if (cxstack_ix &gt;= 0)
  1593              gimme = cxstack[cxstack_ix].blk_gimme;
  1594          else
  1595              gimme = G_SCALAR;
  1596      }
  1597  ...</programlisting>
	</para><para
>	  <command
moreinfo="none"
>gdb</command> first stopped at line 1587, which is
	  the first line in the function. The first three lines of the
	  function are, as you might expect, variable
	  definitions. <command
moreinfo="none"
>gdb</command> does not normally stop
	  on variable definitions, unless they are also
	  assignments. <constant
>djSP</constant> happens to be a macro
	  which expands to

	  <programlisting
format="linespecific"
>register SV **sp = PL_stack_sp</programlisting>

	  declaring a local copy of the stack pointer. The next line,
	  however, is not an assignment, which is why
	  <userinput
moreinfo="none"
>step</userinput> causes <command
moreinfo="none"
>gdb</command> to
	  move on to line 1589. <command
moreinfo="none"
>gdb</command> also skips
	  blank space, so the next line it stops on is 1591.
	</para><para
>	  Since the program enters the <literal
moreinfo="none"
>if</literal>
	  statement, we know the <varname
>gimme</varname>, the context
	  in which this piece of Perl is being executed, is
	  <literal
moreinfo="none"
>-1</literal>, signifying `not yet known'. Next we
	  go from the inner <literal
moreinfo="none"
>if</literal> statement to the
	  <literal
moreinfo="none"
>else</literal> branch, meaning that
	  <varname
>cx_stack_ix</varname>, the index into the context
	  stack, is less than zero. Hence <varname
>gimme</varname> is
	  set to <constant
>G_SCALAR</constant>.</para><para
>	  What does this mean in Perl terms? The context stack holds
	  the context for each block; when you call a sub in list
	  context, an entry is popped onto the context stack
	  signifying this. This allows the code which implements
	  <literal
moreinfo="none"
>return</literal> to determine which context is
	  expected. Since we are in the outermost block of the
	  program, there are no entries on the context stack at the
	  moment. The code we have just executed sets the context of
	  the outer block to scalar context. (Unfortunately,
	  <function
moreinfo="none"
>wantarray</function> is only useful inside a
	  subroutine, so the usual way of demonstrating this won't
	  work. You'll just have to take our word for it.)</para><para
>	  Sometimes <userinput
moreinfo="none"
>step</userinput> is too slow-going, and
	  you don't want to descend into a certain function and
	  execute every line in it. For instance, you'll notice after
	  a while that <function
moreinfo="none"
>ENTER</function> and
	  <function
moreinfo="none"
>SAVETMPS</function> often appear next to each
	  other and cause <function
moreinfo="none"
>Perl_push_scope</function> and
	  <function
moreinfo="none"
>Perl_save_int</function> to be executed. If you're
	  not interested in debugging those functions, you can skip
	  over them using the <userinput
moreinfo="none"
>next</userinput> command;
	  they will still be executed, but the debugger will not trace
	  their execution:

	  <screen
format="linespecific"
><computeroutput
moreinfo="none"
>Breakpoint 2, Perl_pp_enter () at pp_hot.c:1598
1598	    ENTER;
(gdb) <userinput
moreinfo="none"
>next</userinput>
1600	    SAVETMPS;
(gdb) 
1601	    PUSHBLOCK(cx, CXt_BLOCK, SP);
(gdb) 
1603	    RETURN;
(gdb) </computeroutput></screen></para><para
>	  Alternatively, you can run the current function to its
	  conclusion without tracing it using the
	  <userinput
moreinfo="none"
>finish</userinput> command.

	  <screen
format="linespecific"
>	    <computeroutput
moreinfo="none"
>(gdb) <userinput
moreinfo="none"
>step</userinput>
Perl_runops_debug () at run.c:42
42		PERL_ASYNC_CHECK();
(gdb) 
43		if (PL_debug) {
(gdb) 
53	    } while ((PL_op = CALL_FPTR(PL_op-&gt;op_ppaddr)(aTHX)));
(gdb) 
Perl_pp_nextstate () at pp_hot.c:37
37	    PL_curcop = (COP*)PL_op;
(gdb) <userinput
moreinfo="none"
>finish</userinput>
Run till exit from #0  Perl_pp_nextstate () at pp_hot.c:37
0x80ba64b in Perl_runops_debug () at run.c:53
53	    } while ((PL_op = CALL_FPTR(PL_op-&gt;op_ppaddr)(aTHX)));
Value returned is $1 = (OP *) 0x814cb68</computeroutput></screen>

	  Here we step over the main op despatch loop until
	  <function
moreinfo="none"
>Perl_pp_nextstate</function> is called. Since
	  we're not particularly interested in that function, we call
	  <userinput
moreinfo="none"
>finish</userinput> to let it run. The debugger
	  then confirms that it's running
	  <function
moreinfo="none"
>Perl_pp_nextstate</function> until the function
	  exits, displays where it has returned to, and the value
	  returned from the function.</para><tip
><title
>Emacs makes it easy</title><para
>	    If you're a user of the <command
moreinfo="none"
>emacs</command> editor,
	    you might find the <literal
moreinfo="none"
>gdb</literal> major mode to be
	    extremely helpful; it automatically opens any source files
	    that <command
moreinfo="none"
>gdb</command> refers to, and can trace the
	    flow of control in the source buffers, making it very easy
	    for you to see what's going on around the source that's
	    currently being executed.
	  </para></tip><tip
><title
>Alternatives to <command
moreinfo="none"
>gdb</command></title><para
>	    If you're not a fan of command-line debugging, you may
	    wish to investigate alternatives to
	    <command
moreinfo="none"
>gdb</command>. For Windows users, Microsoft
	    Visual C can't be beaten; for Unix users, Tim recommends
	    <command
moreinfo="none"
>ddd</command>, which is a graphical front-end to
	    <command
moreinfo="none"
>gdb</command>. <command
moreinfo="none"
>ddd</command> extends the
	    usual source-navigation functions of a debugger with an
	    interactive graphical display of data, including arrays
	    and structures.
	  </para></tip></sect3><sect3
><title
>Evaluating expressions</title><para
>	  We can now perform most of the debugging we need with ease,
	  but there's one more feature of <command
moreinfo="none"
>gdb</command> that
	  makes it even easier. The <userinput
moreinfo="none"
>print</userinput>
	  command allows you to execute C expressions on the fly and
	  display their results.
	</para><para
>	  There is, unfortunately, one drawback;
	  <command
moreinfo="none"
>gdb</command> doesn't know anything about
	  pre-processor macros, so you need to expand the macros
	  yourself. For instance, to find the reference count of an
	  SV, you can't say

	  <screen
format="linespecific"
><computeroutput
moreinfo="none"
>(gdb) <userinput
moreinfo="none"
>print SvREFCNT(sv)</userinput>
No symbol "SvREFCNT" in current context.</computeroutput></screen>
	  Instead, you have to say:
	  <screen
format="linespecific"
><computeroutput
moreinfo="none"
>(gdb) <userinput
moreinfo="none"
>print sv-&gt;sv_refcnt</userinput>
$1</computeroutput></screen>
	  Or even, to look at the contents of the SV,
	  <screen
format="linespecific"
><computeroutput
moreinfo="none"
>(gdb) <userinput
moreinfo="none"
>print *sv</userinput>
$2 = {sv_any = 0x8147a10, sv_refcnt = 1, sv_flags = 536870923}</computeroutput></screen>
	</para><para
>	  You may also use <userinput
moreinfo="none"
>print</userinput> to call C
	  functions, such as the debugging functions mentioned above:

	  <screen
format="linespecific"
>	    <computeroutput
moreinfo="none"
>(gdb) <userinput
moreinfo="none"
>print Perl_sv_dump(sv)</userinput>
SV = PV(0x8146d14) at 0x8150824
  REFCNT = 1
  FLAGS = (POK,READONLY,pPOK)
  PV = 0x8151968 "hello"\0
  CUR = 5
  LEN = 6
$9 = void</computeroutput></screen>

	  Using these functions in conjunction with the
	  execution-tracing commands of <command
moreinfo="none"
>gdb</command> should
	  allow you to examine almost every area of Perl's internals.</para></sect3><sect3
><title
>Debugging XS code</title><para
>	  There's one little wrinkle, however, when it comes to
	  debugging XS modules. The first problem with XS is that the
	  modules are usually dynamically loaded into memory; that
	  means that when <literal
moreinfo="none"
>perl</literal> starts, the functions aren't loaded,
	  and that means that when <command
moreinfo="none"
>gdb</command> starts, it
	  can't find them.</para><para
>	  The solution to this is to choose a breakpoint after the XS
	  module has been dynamically loaded; a good place is
	  <function
moreinfo="none"
>S_run_body</function> - here the
	  <userinput
moreinfo="none"
>BEGIN</userinput> blocks have been processed and
	  hence all <userinput
moreinfo="none"
>use</userinput>'d modules have been
	  loaded. This is just before the main part of the script is
	  executed. If this is too late for your debugging, another
	  good place to stop is inside the dynamic loading module,
	  <classname
>DynaLoader</classname>. <function
moreinfo="none"
>XS_DynaLoader_dl_load_file</function>
	  is called for each module that needs to be dynamically loaded.
	</para><note
><para
>	    Don't forget that to effectively debug an XS module,
	    you'll need to recompile it with the debugging flag,
	    <userinput
moreinfo="none"
>-g</userinput>. The "official" way to do this
	    is to run <filename
moreinfo="none"
>Makefile.PL</filename> as follows:

	    <screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>perl Makefile.PL OPTIMIZE=-g</userinput></screen>

	    However, it's also possible to hack the
	    <userinput
moreinfo="none"
>OPTIMIZE=</userinput> line in the
	    <filename
moreinfo="none"
>Makefile</filename> itself. (But don't tell
	    anyone I said that.)
	  </para></note><para
>	  The next small problem is that the function names of XS
	  functions are mangled from the names you give them in the
	  <filename
moreinfo="none"
>.xs</filename> file. You should look at the
	  <filename
moreinfo="none"
>.c</filename> file produced by
	  <command
moreinfo="none"
>xsubpp</command> to determine the real function name.
	</para><para
>	  For instance, the XS function
	  <function
moreinfo="none"
>sdbm_TIEHASH</function> in the XS code for the
	  <classname
>SDBM_File</classname> becomes
	  <function
moreinfo="none"
>XS_SDBM_File_TIEHASH</function>.
	</para><para
>	  The rules for this mangling are regular (<xref
linkend="advxs.inside"
></xref>):

	  <itemizedlist
><listitem
><para
>The <userinput
moreinfo="none"
>PREFIX</userinput> given in the XS
		file is removed from the function name. Hence,
		<function
moreinfo="none"
>sdbm_</function> is stripped off to leave
		<function
moreinfo="none"
>TIEHASH</function>. </para></listitem><listitem
><para
>		The <userinput
moreinfo="none"
>PACKAGE</userinput> name
		(<userinput
moreinfo="none"
>SDBM_File</userinput>) undergoes
		"C-ification" (Any package separators,
		<userinput
moreinfo="none"
>::</userinput>, are converted to
		underscores) and this is added to the beginning of the
		name: <function
moreinfo="none"
>SDBM_File_TIEHASH</function>
	      </para></listitem><listitem
><para
>		Finally, <function
moreinfo="none"
>XS_</function> is prefixed to the
		name to give <function
moreinfo="none"
>XS_SDBM_File_TIEHASH</function>.
	      </para></listitem></itemizedlist>
	</para></sect3></sect2></sect1><sect1
><title
>Creating a Patch</title><sect2
><title
>How to Solve Problems</title><para
>There are a few standard design goals that you should hold in mind
when considering how to approach a Perl patch; there's also quite a
lot of unwritten folklore that explains why certain patches `feel'
better than others. Here is an incomplete list of some of the more
important principles that we've picked up over the years.</para><itemizedlist
><listitem
><para
>The most important rule of all: you may not break old code. Perl 5
can still quite happily run some code that is positively ancient, even
dating back to the Perl 1 days; we pride ourselves on backwards
compatibility. Hence, nothing that you do should break that compatibility.</para><para
>This has a few direct implications: adding new syntax is
tricky. Adding new operators is pretty much right out - if I wanted to
introduce a <function
moreinfo="none"
>chip</function> operator which took a character
off the beginning of a string, that would break any code which defined
a <function
moreinfo="none"
>chip</function> subroutine itself. </para></listitem><listitem
><para
>Solve problems as generally as possible - platform specific
<userinput
moreinfo="none"
>ifdef</userinput>s are frowned upon unless absolutely and
obviously necessary. Try to avoid repetition of code. If you've got a
good, general routine that can be used in other places of the Perl
core, move it out to a separate function and change the rest of the
core to use it.</para><para
>For instance, there needed to be a way for Perl to perform arbitrary
transformations on incoming data - for example, to mark it as
UTF8-encoded, or convert it between different character encodings. The
intial idea was to extend the source filter mechanism to apply not
just to the source file input, but also to any filehandle. However,
the more general solution was an extension of the Perl IO abstraction
to a `layered' model where transformation functions could be applied
to various layers; then source filters could be re-implemented in
terms of this new IO system.</para></listitem><listitem
><para
>Change as <emphasis
>little</emphasis> as possible to get the job done,
especially when you're not well-known as a solid porter.  Big sweeping
changes scare people, whether or not they're correct. It's a lot
easier to check a ten-line patch for potential bugs than a
hundred-line patch.</para></listitem><listitem
><para
>Don't do it in the core unless it needs to be done in the core. If you
can do it in a Perl module or an XS module, it's unlikely that you
need to do it in the core.</para><para
>As an example, DBM capability was moved out of the core into a bunch
of XS modules; this also had the advantage that you could switch
between different DBM libraries at runtime, and you had the
extensibility of the <function
moreinfo="none"
>tie</function> system that could be
used for things other than DBMs.</para></listitem><listitem
><para
>Try to avoid introducing restrictions - even on things you haven't
thought of yet. Always leave the door open for more interesting work
along the same lines.</para><para
>A good example of this is lvalue subroutines, which were introduced in
Perl 5.6.0 - once you have lvalue subroutines, why not lvalue
method calls or even lvalue overloaded operators?</para></listitem></itemizedlist><para
>Some of the goals, however, are just things which you have to pick up
in time and/or may depend on the outlook of the pumpking and any major
work that's going on at the time - for instance, during the
reorganisation of the IO system mentioned above, any file handling
patches would be carefully scrutinised to make sure they wouldn't have
to be rewritten once the new system was in place. Hence, it's not
really possible to give hard-and-fast design goals, but if you stick to
the above, you won't go far wrong.</para></sect2><sect2
><title
>Autogenerated files</title><para
>One thing you need to be careful of is that a number of files should
not be patched directly, since they are generated from other (usually
Perl) programs.</para><para
>Most of these files are clearly marked, but the most important one
bears repeating: if you add a new function to the core, you must add
an entry to the table at the end of
<filename
moreinfo="none"
>embed.pl</filename>. This ensures a number of things:
firstly, that a correct function prototype is generated and placed in
<filename
moreinfo="none"
>protos.h</filename>; secondly, that any documentation for
that function is automatically extracted, and thirdly, that the
namespace for the function is automatically handled. (See the note
below)</para><para
>The syntax for entries in the table is explained in the documentation
file <filename
moreinfo="none"
>perlguts.pod</filename></para><note
><para
>
Perl's internal functions are carefully named so that when Perl is
embedded in another C program, they do not override any functions that
the C program defines. Hence, all internal functions should be named
<function
moreinfo="none"
>Perl_something</function>, apart from static functions which
are by convention named
<function
moreinfo="none"
>S_something</function>. <filename
moreinfo="none"
>embed.h</filename> uses a
complicated system of automatically-generated
<userinput
moreinfo="none"
>#define</userinput>s to allow you to call your function as
<function
moreinfo="none"
>something()</function> inside the core and in XSUBs, but
<function
moreinfo="none"
>Perl_something</function> must be used by embedders. </para></note><para
>You must remember to rerun <filename
moreinfo="none"
>embed.pl</filename> after doing
this. The Make target <userinput
moreinfo="none"
>regen_headers</userinput> will call
all the Perl programs which generate other files.</para><para
>	A special exception is <filename
moreinfo="none"
>perly.c</filename>, which is
	generated from running <command
moreinfo="none"
>byacc</command> on
	<filename
moreinfo="none"
>perly.y</filename> and then being fixed up with a patch. In
	the <emphasis
>extraordinarily</emphasis> unlikely event that you need
	to fiddle with the Perl grammar in <filename
moreinfo="none"
>perly.y</filename>, you
	can run the Make target <userinput
moreinfo="none"
>run_byacc</userinput> to call
	<command
moreinfo="none"
>byacc</command> and then fix up the resulting C file; if you
	are changing <filename
moreinfo="none"
>perly.y</filename>, it's polite to drop
	the VMS porters mailing list (vmsperl@perl.org) a copy of the
	patch, as they use a different way of generating <filename
moreinfo="none"
>perly.c</filename>.
      </para><para
>For changes which involve autogenerated files, such as adding a
function to the core or changing a function's prototype, it's only
necessary to provide a patch for the generating program and leave a
note to the effect that <userinput
moreinfo="none"
>regen_headers</userinput> should be
run. You should not include, for instance, a patch to
<filename
moreinfo="none"
>protos.h</filename>.</para></sect2><sect2
><title
>The Patch Itself</title><para
>Patching styles vary, but the recommended style for Perl is a unified
diff. If you're changing a small number of files, copy, say,
<filename
moreinfo="none"
>sv.c</filename> to <filename
moreinfo="none"
>sv.c~</filename>, make your
changes, and then run:
<screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>diff -u <replaceable
>sv.c~</replaceable> <replaceable
>sv.c</replaceable> &gt; <replaceable
>/tmp/patch</replaceable> </userinput>
<prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>diff -u <replaceable
>sv.h~</replaceable> <replaceable
>sv.h</replaceable> &gt;&gt; <replaceable
>/tmp/patch</replaceable> </userinput></screen>
and so on for each file you change.</para><para
>If you are doing this, remember to run <command
moreinfo="none"
>diff</command> from
the root of the Perl source directory. Hence, if you're patching XS
files in <filename
moreinfo="none"
>ext/</filename>, you should say:
<screen
format="linespecific"
><prompt
moreinfo="none"
>%</prompt> <userinput
moreinfo="none"
>diff -u <replaceable
>ext/Devel/Peek/Peek.xs~</replaceable> <replaceable
>ext/Devel/Peek/Peek.xs</replaceable> &gt;&gt; <replaceable
>/tmp/patch</replaceable> </userinput></screen></para><para
>For larger patches, you may find it easier to do something like this:

<screen
format="linespecific"
><prompt
moreinfo="none"
>/home/me/work %</prompt> <userinput
moreinfo="none"
>rsync -avz rsync://ftp.linux.activestate.com/perl-current/ bleadperl</userinput>
<prompt
moreinfo="none"
>/home/me/work %</prompt> <userinput
moreinfo="none"
>cp -R bleadperl myperl</userinput>
<prompt
moreinfo="none"
>/home/me/work %</prompt> <userinput
moreinfo="none"
>cd myperl</userinput>
<prompt
moreinfo="none"
>/home/me/work/myperl %</prompt> <replaceable
>Make your changes...</replaceable>
<prompt
moreinfo="none"
>/home/me/work/myperl %</prompt> <userinput
moreinfo="none"
>cd ..</userinput>
<prompt
moreinfo="none"
>/home/me/work %</prompt> <userinput
moreinfo="none"
>diff -ruN bleadperl myperl &gt; /tmp/patch</userinput></screen>

	This will create a patch which turns the current bleadperl
	into your personal perl source tree. If you do this, please
	remember to prune your patch for autogenerated files and also
	things which do not belong in the source distribution. (Any
	test data you have used, or messages about binary files.)</para><note
><title
><command
moreinfo="none"
>makepatch</command></title><para
>	  An alternative tool which may make patching easier is Johan
	  Vroman's <command
moreinfo="none"
>makepatch</command>, available from
	  <filename
moreinfo="none"
>$CPAN/authors/id/JV/</filename>. This automates
	  many of the above steps. Some swear by it, but some of us
	  are stuck in their ways and do things the old way...
	</para></note></sect2><sect2
><title
>Documentation</title><para
>	If you change a feature of Perl which is visible to the user,
	you must, must, must update the documentation. Patches are not
	complete if they do not contain documentation.
      </para><para
>	Remember that if you introduce a new warning or error, you
	need to document it in <filename
moreinfo="none"
>pod/perldiag.pod</filename>.</para><para
>	Perl 5.6.0 introduced a system for providing documentation for
	internal functions, similar to Java's
	<command
moreinfo="none"
>javadoc</command>. This `apidoc' is extracted by
	<filename
moreinfo="none"
>embed.pl</filename> and ends up in two files:
	<filename
moreinfo="none"
>pod/perlapi.pod</filename> is the file containing
	documentation for functions which are deemed suitable for XS
	authors<footnote
><para
>Chapter 4 of this book was developed
	by starting from <filename
moreinfo="none"
>pod/perlapi.pod</filename>, and, in
	fact, we contributed back some pieces of chapter 4 as
	apidoc.</para></footnote>, and
	<filename
moreinfo="none"
>pod/perlintern.pod</filename> contains the
	documentation for all other functions. (`Internal' functions)</para><remark
>If <filename
moreinfo="none"
>perlapi.pod</filename> is the XS interface
shouldn't PUSH[inpu] and XPUSH[inpu] be moved to
<filename
moreinfo="none"
>perlintern.pod</filename> folowing the recent comment by
Sarathay that XS writers should not use them (I added comment to that
effect in advxs chapter.</remark><para
>apidoc is simply POD embedded in C comments; you should be able to
pick up how it is used by looking around the various C files. If you
add apidoc to a function, you should turn on the <literal
moreinfo="none"
>d</literal>
flag in that function's <filename
moreinfo="none"
>embed.pl</filename> entry.</para></sect2><sect2
><title
>Testing</title><para
>The <filename
moreinfo="none"
>t/</filename> directory in the Perl source tree contains
at great many (294, at last count) regression test scripts which
ensure that Perl is behaving as it should. When you change something,
you should make sure that your changes have not caused any of the
scripts to break - they have been specially designed to try out as
many unexpected interactions as possible. </para><para
>You should also add tests to the suite if you change a feature, so
that your changes don't get disturbed by future patching
activity. Tests are in the ordinary style used for modules, so
remember to update the <literal
moreinfo="none"
>"1..n"</literal> line at the top of
the test.</para></sect2><sect2
><title
>Submitting your patch</title><para
>Once you've put together a patch, which includes documentation and new
tests, it's time to submit it to P5P. Your subject line should include
the tag <literal
moreinfo="none"
>[PATCH]</literal>, with optionally a version number
or name, or the name of the file you're patching: <literal
moreinfo="none"
>[PATCH
bleadperl]</literal>, or <literal
moreinfo="none"
>[PATCH sv.c]</literal>. This is to
allow the pumpking to easily distinguish possible patches to be
integrated from the usual list discussion. You should also put a brief
description of what you're solving on the subject line: for instance,
<literal
moreinfo="none"
>[PATCH blead] Fix B::Terse indentation</literal>. </para><para
>The body of your mail should be a brief discussion of the problem
(just some Perl code which demonstrates the problem is adequate) and
how you've solved it. Then insert your patch directly into the body of
the mail - try to avoid sending it as an attachment. Also, be careful
with cut-and-pasting your patch in, because this may corrupt line
wrapping or convert tabs to spaces.</para><para
>Once you're ready, take a deep breath, and hit send!</para></sect2></sect1><sect1
><title
>Perl 6 : The Future of Perl</title><sect2
><title
>A History</title><para
>	At the Perl Conference in July 2000, Chip Salzenburg called a
	`brainstorming session' meeting of some eminent members of the
	Perl community to discuss the state of Perl. Chip wanted some
	form of `Perl Constitution' to resolve some perceived problems
	in Perl 5 development, but Jon Orwant suggested (in a
	particularly vivid and colourful way) that there were deeper
	problems in the state of Perl and the Perl community that
	should be fixed by a completely new version of Perl.
      </para><para
>	The majority consensus was that this was a good idea, and
	Larry picked up on it. It was then presented to the main
	perl5-porters meeting the same afternoon, and various people
	offered to take some roles in the development team. Larry
	announced the start of Perl 6 development in his keynote
	`State of the Onion' address the following day.
      </para><para
>	There was then a period of feeling around for the best way to
	organise the development structure of Perl 6; the
	single-mailing-list model of Perl 5 was prone to infighting,
	and the pumpking system was problematic as Perl was beginning
	to get too big for a single person to maintain and cases of
	`pumpking burnout' too common.
      </para><para
>	The concensus was that design should be split between a number
	of `working groups', and these would each have a chair. The
	first two working groups were perl6-language and
	perl6-internals, for language design proposals and
	implementation design respectively. The busier working groups
	spawned sub-groups for discussion of more focused topics, and
	developers were encouraged to express their desires for
	language change in formal `Requests for Changes'.</para><para
>	The comments stage ended on October 1st, 2000, after 361 RFCs were
	submitted. These went to Larry, who sat down to the gruelling task of
	reading each one to assess its merits. Larry then responded by
	unfolding the language design in a series of articles called
	"Apocalypses". Damian Conway, who through generous sponsorship
	has been working full-time for the Perl community, has been
	assisting Larry, and has also produced explanatory articles
	called "Exegeses". This process will continue well into 2002.
      </para><para
>	On the other side of things, the Perl 6 internals started an
	almost independent sub-project, to write a generic interpreter
	that could be used for Perl 6, Perl 5 and perhaps other
	dynamic languages as well. Dan Sugalski volunteered to be the
	internals designer for this interpreter (codenamed "Parrot",
	after a particularly pervasive April Fool's joke) and
	explained his decisions in a series of Parrot Design
	Documents; when enough of the design was ready, Simon stepped
	up to be the release manager in another futile attempt to put
	off finishing this book. The first public release of Parrot
	happened on Monday 10th of September 2001.
      </para><para
>	At the time of writing, Parrot has support for pluggable data
	types, both simple and aggregate, can compile and execute
	three "mini-languages", (mini-Scheme, mini-Perl and a language
	specially written for Parrot, Jako) and has the beginnings of
	an x86 Just-In-Time compiler. 
      </para><para
>	You can get the latest release of Parrot from CPAN in <ulink
url="http://www.cpan.org/authors/id/S/SI/SIMON/"
>Simon's home
	directory</ulink> or by CVS from <ulink
url="http://cvs.perl.org/"
>the perl.org CVS server</ulink>.
      </para></sect2><sect2
><title
>Design and Implementation</title><para
>	Dan has been keeping one thing in mind while designing Parrot:
	speed. The Parrot interpreter will run Perl 6 very fast, and
	most of the other elements of the design filter down from
	that. However, we're not forgetting the lessons learnt from
	the Perl 5 internals, and the guts of Parrot are designed to
	be clearly understandable and easily maintainable.
      </para><para
>	Parrot deviates from the normal techniques used in building a
	virtual machine by choosing a register rather than a stack
	architecture. Although a register-based machine is slightly
	more difficult to compile for, it has several advantages:
	firstly, it allows us to use standard compiler optimization
	techniques tailored for ordinary register-based CPUs;
	secondly, it eliminates many of the stack-manipulation
	operations which take up much of the time of a VM such Perl
	5's; finally, by more closely resembling the underlying
	hardware, it ought to be more straightforward to compile down
	to native code. 
      </para><para
>	Parrot's data abstraction is done via a system of "PMC"s -
	Parrot Magic Cookies. These are the equivalent of SVs, but are
	much more sophisticated. Instead of calling a function on an
	SV, the PMC carries around with it a vtable (a structure of
	function pointers) full of the functions that it can
	perform. In a sense, it is an object on which we can call
	methods. In fact, the PMC abstraction acts as an abstract
	virtual class, with each language providing vtables which
	implement the interface; Perl classes will have, for instance,
	an addition function which will do the right thing on a Perl
	value, and Python classes may provide a function which does
	something different. In this way, the core of Parrot can be
	language-agnostic, with individual "users" of Parrot providing
	data types to fit the needs of their language.
      </para><para
>	Finally, Parrot will have the ability to add in, on a
	lexically scoped basis, custom ops in addition to its core
	set. This will allow languages which do certain things wildly
	differently from how Parrot expects to still be able to use
	the interpreter. 
      </para></sect2><sect2
><title
>What happens next</title><para
>	Parrot and the design of Perl 6 are developing in parallel;
	Larry will continue to produce Apocalypses explaining the
	design, whereas the Parrot hackers are nearing the point where
	it's worth thinking about compiling real languages onto the
	VM.
      </para><para
>	The immediate goals for Parrot now are to add subroutine and
	symbol table support, which should be everything needed for a
	sensible interpreter. By the time the language design firms
	up, we'll be able to switch emphasis towards writing a
	compiler from Perl 6 down to Parrot assembler.
      </para></sect2><sect2
><title
>The future for Perl 5</title><para
>	So if Perl 6 is coming and it's going to be so cool, why have
	we just written a book about Perl 5? Well, for starters, Perl
	6 is going to take quite a while to get completed - writing a
	Perl interpreter from scratch is quite an ambitious exercise! 
	- and it'll then also take a very long time to become
	generally accepted.
      </para><para
>	Perl 5 will continue to be developed, up until the release of
	version 5.8.0, and even then maintainance will continue
	throughout the lifespan of Perl 6. Perl 5 is not going to
	become unsupported.
      </para><para
>	In short, Perl 5 isn't going away anytime soon. Remember how
	long it took to get rid of all those Perl 4 interpreters and
	code everywhere?  That was when we <emphasis
>wanted</emphasis>
	to get rid of it; now that Perl 6 is likely to be
	non-compatible with Perl 5, we can expect real uptake to be
	even slower. Since there's an awful lot of working Perl 5 code
	out there, people aren't going to want to break it all by
	upgrading to Perl 6.
      </para></sect2></sect1><sect1
><title
>Summary</title><para
>      This chapter looked at how to develop <filename
moreinfo="none"
>perl</filename>
      itself; the development process and the perl5-porters mailing
      list. As well as looking at some of the tools available to help
      us develop, such as <filename
moreinfo="none"
>perl</filename>'s debugging mode
      and the GNU Debugger, we also looked at the less technical parts
      of being a Perl porter - how to approach Perl maintainance, and
      how to get patches submitted and integrated to the Perl core.
    </para><para
>      We also looked at Perl 6, and gave a glimpse as to how things
      are likely to be in the future.
    </para></sect1><sect1
><title
>Related Reading</title><para
>      More thoughts on patching Perl can be found in the perl5-porters
      FAQ at <ulink
url="http://simon-cozens.org/writings/p5p.faq"
></ulink>, Simon's
      <ulink
url="http://simon-cozens.org/writings/perlhacktut.html"
>So You
	Want To Be A Perl Porter?</ulink>, and in
      <filename
moreinfo="none"
>pod/perlhack.pod</filename>,
      <filename
moreinfo="none"
>Porting/patching.pod</filename> and
      <filename
moreinfo="none"
>Porting/pumpking.pod</filename> in the Perl distribution.</para></sect1></chapter></book>
